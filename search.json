[
  {
    "objectID": "content/Cours_6/index.html",
    "href": "content/Cours_6/index.html",
    "title": "OOP Design Patterns",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBehavioral Design Pattern\n\n\nDécouvrir les design paterns, et connaitre les plus standards\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreation Design Patterns\n\n\nLearn creational design pattern\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython-Specific Design Patterns\n\n\nLearn about Python-specific design patterns, including context managers and descriptors, to write more efficient and Pythonic code.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStructural Design Patterns\n\n\nDécouvrir les design paterns, et connaitre les plus standards\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP\n\n\n\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "OOP Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html",
    "href": "content/Cours_6/3-Structural_patterns.html",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "Structural patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient.\n\n\nThe Adapter pattern allows objects with incompatible interfaces to collaborate.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nIntegrates incompatible interfaces\nImproves reusability of existing code\nEnhances flexibility in system design\n\n\n\n\n\nThe Bridge pattern separates an object’s abstraction from its implementation, allowing them to vary independently.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDecouples abstraction from implementation\nImproves extensibility\nHides implementation details from clients\n\n\n\n\n\nThe Composite pattern lets you compose objects into tree structures and then work with these structures as if they were individual objects.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSimplifies client code when working with complex hierarchies\nMakes it easy to add new types of components\nProvides flexibility in structuring data\n\n\n\n\n\nThe Decorator pattern lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAdds responsibilities to objects dynamically\nProvides a flexible alternative to subclassing\nAllows for a mix-and-match approach to adding features\n\n\n\n\n\nThe Facade pattern provides a simplified interface to a complex subsystem.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSimplifies interface to a complex subsystem\nDecouples client code from subsystem\nProvides a context for usage\n\n\n\n\n\nThe Flyweight pattern lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nReduces memory usage when dealing with a large number of similar objects\nImproves performance in applications with many objects\nCentralizes state for many virtual objects\n\n\n\n\n\nThe Proxy pattern lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nControls access to the original object\nCan manage the lifecycle of the original object\nAdds a level of indirection for distributed, controlled, or intelligent access\n\n\n\n\n\nStructural design patterns provide various ways to organize code for better structure, flexibility, and efficiency. They help in creating relationships between entities, making systems easier to maintain and extend. By understanding and applying these patterns, developers can create more robust and scalable software architectures.",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#adapter-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#adapter-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Adapter pattern allows objects with incompatible interfaces to collaborate.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nIntegrates incompatible interfaces\nImproves reusability of existing code\nEnhances flexibility in system design",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#bridge-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#bridge-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Bridge pattern separates an object’s abstraction from its implementation, allowing them to vary independently.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDecouples abstraction from implementation\nImproves extensibility\nHides implementation details from clients",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#composite-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#composite-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Composite pattern lets you compose objects into tree structures and then work with these structures as if they were individual objects.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSimplifies client code when working with complex hierarchies\nMakes it easy to add new types of components\nProvides flexibility in structuring data",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#decorator-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#decorator-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Decorator pattern lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAdds responsibilities to objects dynamically\nProvides a flexible alternative to subclassing\nAllows for a mix-and-match approach to adding features",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#facade-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#facade-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Facade pattern provides a simplified interface to a complex subsystem.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSimplifies interface to a complex subsystem\nDecouples client code from subsystem\nProvides a context for usage",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#flyweight-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#flyweight-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Flyweight pattern lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nReduces memory usage when dealing with a large number of similar objects\nImproves performance in applications with many objects\nCentralizes state for many virtual objects",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#proxy-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#proxy-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Proxy pattern lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nControls access to the original object\nCan manage the lifecycle of the original object\nAdds a level of indirection for distributed, controlled, or intelligent access",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#conclusion",
    "href": "content/Cours_6/3-Structural_patterns.html#conclusion",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "Structural design patterns provide various ways to organize code for better structure, flexibility, and efficiency. They help in creating relationships between entities, making systems easier to maintain and extend. By understanding and applying these patterns, developers can create more robust and scalable software architectures.",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/1-Python_Design_Pattern.html",
    "href": "content/Cours_6/1-Python_Design_Pattern.html",
    "title": "Python-Specific Design Patterns",
    "section": "",
    "text": "Context managers in Python provide a clean way to manage resources, ensuring proper acquisition and release.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation of __exit__ parameters: - exc_type: The type of the exception that occurred, or None if no exception occurred. - exc_value: The exception instance, or None if no exception occurred. - traceback: A traceback object, or None if no exception occurred.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDescriptors provide a way to customize attribute access in Python classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation of __get__ parameters: - obj: The instance that the attribute was accessed through, or None when the attribute is accessed through the class. - objtype: The class that was used to access the attribute. This is set even when called on an instance.\nThe difference between __get__ and getattr: - __get__ is a method of the descriptor object itself. It’s called when accessing an attribute that is a descriptor. - getattr is a built-in function that retrieves an attribute from an object. Inside __get__, we often use getattr to access the actual stored value.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, let’s break down how this works step by step:\n\nWhen @LazyProperty is applied to the data method in DataProcessor:\n\nAn instance of LazyProperty is created, with the data method as its function attribute.\nThis LazyProperty instance replaces the data method in the class dictionary.\n\nWhen we create a DataProcessor instance:\n\nNo data is loaded yet. The filename is stored, but data is not accessed.\n\nThe first time processor.data is accessed:\n\nPython sees that data is a descriptor (it has a __get__ method) and calls LazyProperty.__get__(processor, DataProcessor).\nInside __get__:\n\nIt checks if obj (processor) is None. It’s not, so it continues.\nIt calls self.function(obj), which is equivalent to calling the original data method.\nThis prints “Loading data…” and reads the file.\nThe result is stored back into the processor instance using setattr(obj, self.name, value).\nThe value is returned.\n\n\nThe second time processor.data is accessed:\n\nPython first looks for an instance attribute named data.\nIt finds one (because we set it in step 3d), so it returns that value directly.\nThe LazyProperty.__get__ method is not called this time.\n\n\nThe key point is that after the first access, the LazyProperty descriptor is effectively replaced by the computed value. This is why the “Loading data…” message only appears once.\nThese examples demonstrate how context managers and descriptors can be used to create more robust, efficient, and Pythonic code. Context managers excel at resource management, while descriptors offer powerful ways to customize attribute behavior.",
    "crumbs": [
      "Python-Specific Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/1-Python_Design_Pattern.html#context-managers",
    "href": "content/Cours_6/1-Python_Design_Pattern.html#context-managers",
    "title": "Python-Specific Design Patterns",
    "section": "",
    "text": "Context managers in Python provide a clean way to manage resources, ensuring proper acquisition and release.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation of __exit__ parameters: - exc_type: The type of the exception that occurred, or None if no exception occurred. - exc_value: The exception instance, or None if no exception occurred. - traceback: A traceback object, or None if no exception occurred.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python-Specific Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/1-Python_Design_Pattern.html#descriptors",
    "href": "content/Cours_6/1-Python_Design_Pattern.html#descriptors",
    "title": "Python-Specific Design Patterns",
    "section": "",
    "text": "Descriptors provide a way to customize attribute access in Python classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation of __get__ parameters: - obj: The instance that the attribute was accessed through, or None when the attribute is accessed through the class. - objtype: The class that was used to access the attribute. This is set even when called on an instance.\nThe difference between __get__ and getattr: - __get__ is a method of the descriptor object itself. It’s called when accessing an attribute that is a descriptor. - getattr is a built-in function that retrieves an attribute from an object. Inside __get__, we often use getattr to access the actual stored value.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, let’s break down how this works step by step:\n\nWhen @LazyProperty is applied to the data method in DataProcessor:\n\nAn instance of LazyProperty is created, with the data method as its function attribute.\nThis LazyProperty instance replaces the data method in the class dictionary.\n\nWhen we create a DataProcessor instance:\n\nNo data is loaded yet. The filename is stored, but data is not accessed.\n\nThe first time processor.data is accessed:\n\nPython sees that data is a descriptor (it has a __get__ method) and calls LazyProperty.__get__(processor, DataProcessor).\nInside __get__:\n\nIt checks if obj (processor) is None. It’s not, so it continues.\nIt calls self.function(obj), which is equivalent to calling the original data method.\nThis prints “Loading data…” and reads the file.\nThe result is stored back into the processor instance using setattr(obj, self.name, value).\nThe value is returned.\n\n\nThe second time processor.data is accessed:\n\nPython first looks for an instance attribute named data.\nIt finds one (because we set it in step 3d), so it returns that value directly.\nThe LazyProperty.__get__ method is not called this time.\n\n\nThe key point is that after the first access, the LazyProperty descriptor is effectively replaced by the computed value. This is why the “Loading data…” message only appears once.\nThese examples demonstrate how context managers and descriptors can be used to create more robust, efficient, and Pythonic code. Context managers excel at resource management, while descriptors offer powerful ways to customize attribute behavior.",
    "crumbs": [
      "Python-Specific Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_5/index.html",
    "href": "content/Cours_5/index.html",
    "title": "Project and Package",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrganizing Python Projects\n\n\nLearn how to organize Python projects effectively and create packages for distribution.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Package Management and Virtual Environments\n\n\nLearn to create a package and manage virtual environment\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\nTP: Creating a Linear Regression Package\n\n\nA hands-on practical exercise on creating a simple machine learning package for linear regression, exploring package management, testing, manual publishing, and automating…\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnderstanding imports\n\n\n\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnit Testing in Python\n\n\nLearn how to write and run unit tests in Python using the pytest framework.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Project and Package"
    ]
  },
  {
    "objectID": "content/Cours_5/4-Tests.html",
    "href": "content/Cours_5/4-Tests.html",
    "title": "Unit Testing in Python",
    "section": "",
    "text": "Unit testing is a software development practice where individual components or functions of a program are tested in isolation. The primary goals of unit testing are:\n\nTo verify that each part of the program works correctly on its own.\nTo catch and fix bugs early in the development process.\nTo facilitate refactoring and maintenance of code.\nTo serve as documentation for how components should behave.\n\nA unit test typically follows this pattern: 1. Set up the test conditions. 2. Call the function or method being tested. 3. Assert that the output or behavior matches the expected result.\nPython offers several frameworks to help write and run unit tests efficiently. While the built-in unittest module is available, many developers prefer pytest for its simplicity and powerful features.\n\n\n\nunittest: Python’s built-in testing framework.\npytest: A more advanced, feature-rich testing framework.\nnose: An extension of unittest (less common nowadays).\n\nWe’ll focus on pytest due to its popularity and ease of use, especially when integrated with modern Python project management tools like Poetry.\n\n\n\n\nInstall pytest:\npip install pytest\nWrite a test file (e.g., test_example.py):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nRun tests:\npytest\n\n\n\n\n\nAdd pytest to your project’s dev-dependencies:\npoetry add --dev pytest\nUpdate your pyproject.toml:\n[tool.poetry.dev-dependencies]\npytest = \"^7.4.0\"\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\nThis configuration tells pytest to look for tests in the tests directory.\nOrganize your project structure:\nmyproject/\n├── src/\n│   └── mypackage/\n│       └── example.py\n├── tests/\n│   └── test_example.py\n└── pyproject.toml\nWrite your tests in the tests directory.\nRun tests using Poetry:\npoetry run pytest\n\n\n\n\nYou can add more options to your pyproject.toml:\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\naddopts = \"-v --cov=src\"\nThis configuration: - Runs tests verbosely (-v) - Includes coverage reporting (--cov=src)\n\n\n\nTo make running tests easier, you can add a script to your pyproject.toml:\n[tool.poetry.scripts]\ntest = \"pytest\"\nNow you can run tests with:\npoetry run test\n\n\n\nFor CI/CD pipelines, you can use Poetry to install dependencies and run tests:\n# Example GitHub Actions workflow\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: 3.9\n    - name: Install dependencies\n      run: |\n        pip install poetry\n        poetry install\n    - name: Run tests\n      run: poetry run pytest\nThis setup ensures your tests are run automatically on every push or pull request.\n\n\n\n\nWrite tests for all new features and bug fixes.\nAim for high test coverage, but focus on critical paths.\nUse meaningful test names that describe the behavior being tested.\nKeep tests independent and avoid dependencies between tests.\nUse fixtures and parametrization to reduce code duplication in tests.\n\nBy integrating pytest with Poetry, you create a streamlined development workflow where dependency management, building, and testing are all handled by a single tool.",
    "crumbs": [
      "Unit Testing in Python"
    ]
  },
  {
    "objectID": "content/Cours_5/4-Tests.html#unit-testing-in-python",
    "href": "content/Cours_5/4-Tests.html#unit-testing-in-python",
    "title": "Unit Testing in Python",
    "section": "",
    "text": "Unit testing is a software development practice where individual components or functions of a program are tested in isolation. The primary goals of unit testing are:\n\nTo verify that each part of the program works correctly on its own.\nTo catch and fix bugs early in the development process.\nTo facilitate refactoring and maintenance of code.\nTo serve as documentation for how components should behave.\n\nA unit test typically follows this pattern: 1. Set up the test conditions. 2. Call the function or method being tested. 3. Assert that the output or behavior matches the expected result.\nPython offers several frameworks to help write and run unit tests efficiently. While the built-in unittest module is available, many developers prefer pytest for its simplicity and powerful features.\n\n\n\nunittest: Python’s built-in testing framework.\npytest: A more advanced, feature-rich testing framework.\nnose: An extension of unittest (less common nowadays).\n\nWe’ll focus on pytest due to its popularity and ease of use, especially when integrated with modern Python project management tools like Poetry.\n\n\n\n\nInstall pytest:\npip install pytest\nWrite a test file (e.g., test_example.py):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nRun tests:\npytest\n\n\n\n\n\nAdd pytest to your project’s dev-dependencies:\npoetry add --dev pytest\nUpdate your pyproject.toml:\n[tool.poetry.dev-dependencies]\npytest = \"^7.4.0\"\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\nThis configuration tells pytest to look for tests in the tests directory.\nOrganize your project structure:\nmyproject/\n├── src/\n│   └── mypackage/\n│       └── example.py\n├── tests/\n│   └── test_example.py\n└── pyproject.toml\nWrite your tests in the tests directory.\nRun tests using Poetry:\npoetry run pytest\n\n\n\n\nYou can add more options to your pyproject.toml:\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\naddopts = \"-v --cov=src\"\nThis configuration: - Runs tests verbosely (-v) - Includes coverage reporting (--cov=src)\n\n\n\nTo make running tests easier, you can add a script to your pyproject.toml:\n[tool.poetry.scripts]\ntest = \"pytest\"\nNow you can run tests with:\npoetry run test\n\n\n\nFor CI/CD pipelines, you can use Poetry to install dependencies and run tests:\n# Example GitHub Actions workflow\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: 3.9\n    - name: Install dependencies\n      run: |\n        pip install poetry\n        poetry install\n    - name: Run tests\n      run: poetry run pytest\nThis setup ensures your tests are run automatically on every push or pull request.\n\n\n\n\nWrite tests for all new features and bug fixes.\nAim for high test coverage, but focus on critical paths.\nUse meaningful test names that describe the behavior being tested.\nKeep tests independent and avoid dependencies between tests.\nUse fixtures and parametrization to reduce code duplication in tests.\n\nBy integrating pytest with Poetry, you create a streamlined development workflow where dependency management, building, and testing are all handled by a single tool.",
    "crumbs": [
      "Unit Testing in Python"
    ]
  },
  {
    "objectID": "content/Cours_5/TP.html",
    "href": "content/Cours_5/TP.html",
    "title": "TP: Creating a Linear Regression Package",
    "section": "",
    "text": "In this TP, you’ll create a simple machine learning package focused on linear regression. You’ll use modern Python tools like Poetry for package management, implement basic classes, write tests, set up continuous integration, manually publish your package, and finally automate the publishing process."
  },
  {
    "objectID": "content/Cours_5/TP.html#introduction",
    "href": "content/Cours_5/TP.html#introduction",
    "title": "TP: Creating a Linear Regression Package",
    "section": "",
    "text": "In this TP, you’ll create a simple machine learning package focused on linear regression. You’ll use modern Python tools like Poetry for package management, implement basic classes, write tests, set up continuous integration, manually publish your package, and finally automate the publishing process."
  },
  {
    "objectID": "content/Cours_5/TP.html#objectives",
    "href": "content/Cours_5/TP.html#objectives",
    "title": "TP: Creating a Linear Regression Package",
    "section": "Objectives",
    "text": "Objectives\nBy the end of this TP, you will:\n\nSet up a Python project using Poetry\nImplement a basic linear regression class\nWrite unit tests for your implementation\nUse GitHub Actions for continuous integration\nManually publish your package to PyPI\nAutomate the publishing process using GitHub Actions"
  },
  {
    "objectID": "content/Cours_5/TP.html#prerequisites",
    "href": "content/Cours_5/TP.html#prerequisites",
    "title": "TP: Creating a Linear Regression Package",
    "section": "Prerequisites",
    "text": "Prerequisites\n\nBasic understanding of Python and object-oriented programming\nFamiliarity with linear regression concepts\nGit and GitHub account\nPython 3.8 or higher installed"
  },
  {
    "objectID": "content/Cours_5/TP.html#step-1-setting-up-the-project",
    "href": "content/Cours_5/TP.html#step-1-setting-up-the-project",
    "title": "TP: Creating a Linear Regression Package",
    "section": "Step 1: Setting Up the Project",
    "text": "Step 1: Setting Up the Project\nSet up your project using Poetry.\n\nInstall Poetry if you haven’t already.\nCreate a new project named finance-ml.\nEdit the pyproject.toml file to add necessary dependencies (numpy for calculations, pytest for testing).\nInstall the dependencies using Poetry.\n\nExercise 1: Set up the project structure as described above. Familiarize yourself with the pyproject.toml file and Poetry commands."
  },
  {
    "objectID": "content/Cours_5/TP.html#step-2-implementing-linear-regression",
    "href": "content/Cours_5/TP.html#step-2-implementing-linear-regression",
    "title": "TP: Creating a Linear Regression Package",
    "section": "Step 2: Implementing Linear Regression",
    "text": "Step 2: Implementing Linear Regression\nImplement a basic linear regression class.\nCreate a new file src/finance_ml/linear_models.py and implement a LinearRegression class with the following methods:\n\n__init__(self, use_intercept=True): Initialize the model parameters.\nfit(self, X, y): Fit the model to the training data.\npredict(self, X): Make predictions using the trained model.\n\nYour implementation should handle cases with and without an intercept term and use numpy for efficient calculations.\nExercise 2: Implement the LinearRegression class as described above."
  },
  {
    "objectID": "content/Cours_5/TP.html#step-3-writing-tests",
    "href": "content/Cours_5/TP.html#step-3-writing-tests",
    "title": "TP: Creating a Linear Regression Package",
    "section": "Step 3: Writing Tests",
    "text": "Step 3: Writing Tests\nWrite tests for your LinearRegression class to ensure it works correctly.\nCreate a new file tests/test_linear_models.py and write test functions to cover various scenarios and edge cases.\nExercise 3: Implement the test functions for your LinearRegression class."
  },
  {
    "objectID": "content/Cours_5/TP.html#step-4-setting-up-basic-github-actions",
    "href": "content/Cours_5/TP.html#step-4-setting-up-basic-github-actions",
    "title": "TP: Creating a Linear Regression Package",
    "section": "Step 4: Setting Up Basic GitHub Actions",
    "text": "Step 4: Setting Up Basic GitHub Actions\nSet up a basic GitHub Actions workflow to run your tests automatically.\nCreate a new file .github/workflows/tests.yml:\nname: Run Tests\n\non: [push, pull_request]\n\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: '3.8'\n    - name: Install dependencies\n      run: |\n        pip install poetry\n        poetry install\n    - name: Run tests\n      run: poetry run pytest\nExercise 4: 1. Set up a GitHub repository for your project and add the GitHub Actions workflow as shown above. 2. Push your code and verify that the tests run automatically on push and pull requests."
  },
  {
    "objectID": "content/Cours_5/TP.html#step-5-manual-package-publishing",
    "href": "content/Cours_5/TP.html#step-5-manual-package-publishing",
    "title": "TP: Creating a Linear Regression Package",
    "section": "Step 5: Manual Package Publishing",
    "text": "Step 5: Manual Package Publishing\nNow, let’s publish your package to PyPI manually using Poetry.\n\nRegister an account on PyPI (https://pypi.org/)\nBuild your package using Poetry\nPublish your package to PyPI using Poetry\n\nExercise 5: Follow the steps above to manually publish your package to PyPI. Verify that you can install your package from PyPI using pip."
  },
  {
    "objectID": "content/Cours_5/TP.html#step-6-automating-package-publishing",
    "href": "content/Cours_5/TP.html#step-6-automating-package-publishing",
    "title": "TP: Creating a Linear Regression Package",
    "section": "Step 6: Automating Package Publishing",
    "text": "Step 6: Automating Package Publishing\nFinally, let’s automate the publishing process using GitHub Actions.\nExercise 6: 1. Modify the GitHub Actions workflow you created in Step 4 to include a job for publishing the package to PyPI when pushing to the main branch. 2. Research how to securely add your PyPI credentials as secrets in GitHub Actions. 3. Update your workflow to use these secrets for authentication when publishing. 4. Test your automated publishing process by pushing a change to the main branch.\nHint: You’ll need to add a new job to your workflow, use conditional execution based on the branch, and incorporate the PyPI credentials as secrets."
  },
  {
    "objectID": "content/Projets/index.html",
    "href": "content/Projets/index.html",
    "title": "Projets",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProjets POO - Millésime 2024-2025\n\n\n\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Projets"
    ]
  },
  {
    "objectID": "content/Cours_4/4-builtin_decorator.html",
    "href": "content/Cours_4/4-builtin_decorator.html",
    "title": "Built-in Decorators and Standard Library Decorators in Python",
    "section": "",
    "text": "Python provides several built-in decorators and others in its standard library, particularly in the functools module. These decorators offer powerful functionality for common programming patterns.\n\n\n\n\nThe @property decorator is used to define methods in a class that act like attributes:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n@classmethod is used to define methods that operate on the class rather than instances:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n@staticmethod is used for methods that don’t need access to the class or instance:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThe @dataclass decorator, introduced in Python 3.7, automatically generates special methods like init(), repr(), and eq() for a class:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator simplifies the creation of classes that are primarily used to store data, reducing boilerplate code significantly.\n\n\n\n\nThe functools module in Python’s standard library provides several useful decorators:\n\n\nThis decorator implements memoization, caching the results of a function:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nIntroduced in Python 3.9, @cache is a simpler unbounded cache:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThis decorator is used when writing custom decorators to preserve the metadata of the original function:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThis decorator generates missing comparison methods for a class:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nThese built-in and standard library decorators provide powerful tools for Python developers. They offer efficient solutions for common programming patterns, from property management and method types to caching and comparison operations. Understanding and using these decorators can significantly enhance code readability and performance.",
    "crumbs": [
      "Built-in Decorators and Standard Library Decorators in Python"
    ]
  },
  {
    "objectID": "content/Cours_4/4-builtin_decorator.html#built-in-decorators",
    "href": "content/Cours_4/4-builtin_decorator.html#built-in-decorators",
    "title": "Built-in Decorators and Standard Library Decorators in Python",
    "section": "",
    "text": "The @property decorator is used to define methods in a class that act like attributes:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n@classmethod is used to define methods that operate on the class rather than instances:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n@staticmethod is used for methods that don’t need access to the class or instance:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThe @dataclass decorator, introduced in Python 3.7, automatically generates special methods like init(), repr(), and eq() for a class:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator simplifies the creation of classes that are primarily used to store data, reducing boilerplate code significantly.",
    "crumbs": [
      "Built-in Decorators and Standard Library Decorators in Python"
    ]
  },
  {
    "objectID": "content/Cours_4/4-builtin_decorator.html#decorators-from-functools",
    "href": "content/Cours_4/4-builtin_decorator.html#decorators-from-functools",
    "title": "Built-in Decorators and Standard Library Decorators in Python",
    "section": "",
    "text": "The functools module in Python’s standard library provides several useful decorators:\n\n\nThis decorator implements memoization, caching the results of a function:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nIntroduced in Python 3.9, @cache is a simpler unbounded cache:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThis decorator is used when writing custom decorators to preserve the metadata of the original function:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThis decorator generates missing comparison methods for a class:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Built-in Decorators and Standard Library Decorators in Python"
    ]
  },
  {
    "objectID": "content/Cours_4/4-builtin_decorator.html#conclusion",
    "href": "content/Cours_4/4-builtin_decorator.html#conclusion",
    "title": "Built-in Decorators and Standard Library Decorators in Python",
    "section": "",
    "text": "These built-in and standard library decorators provide powerful tools for Python developers. They offer efficient solutions for common programming patterns, from property management and method types to caching and comparison operations. Understanding and using these decorators can significantly enhance code readability and performance.",
    "crumbs": [
      "Built-in Decorators and Standard Library Decorators in Python"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html",
    "href": "content/Cours_4/3-Decorator_practically.html",
    "title": "Decorator Practically",
    "section": "",
    "text": "In Python, decorators are implemented using the @ symbol, followed by the decorator function name, placed above the function definition they’re decorating.\nLet’s start with a simple example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, uppercase_decorator is a function that takes another function as an argument, modifies its behavior (by converting the result to uppercase), and returns the modified function.\n\n\n\nDecorators can also work with functions that accept arguments:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator logs the name of the function being called before executing it.\n\n\n\nDecorators can also be applied to classes. Here’s a simple example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator adds a greet method to the Person class.\n\n\n\nWe can create decorators that accept parameters:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis repeat decorator takes an argument specifying how many times the decorated function should be called.\n\n\n\nThese examples demonstrate the basic usage of decorators in Python. They allow for modifying or enhancing the behavior of functions and classes without changing their source code. Decorators provide a clean and reusable way to extend functionality, making code more modular and easier to maintain.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html#basic-function-decorators",
    "href": "content/Cours_4/3-Decorator_practically.html#basic-function-decorators",
    "title": "Decorator Practically",
    "section": "",
    "text": "In Python, decorators are implemented using the @ symbol, followed by the decorator function name, placed above the function definition they’re decorating.\nLet’s start with a simple example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, uppercase_decorator is a function that takes another function as an argument, modifies its behavior (by converting the result to uppercase), and returns the modified function.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html#function-decorators-with-arguments",
    "href": "content/Cours_4/3-Decorator_practically.html#function-decorators-with-arguments",
    "title": "Decorator Practically",
    "section": "",
    "text": "Decorators can also work with functions that accept arguments:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator logs the name of the function being called before executing it.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html#simple-class-decorator",
    "href": "content/Cours_4/3-Decorator_practically.html#simple-class-decorator",
    "title": "Decorator Practically",
    "section": "",
    "text": "Decorators can also be applied to classes. Here’s a simple example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator adds a greet method to the Person class.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html#decorators-with-parameters",
    "href": "content/Cours_4/3-Decorator_practically.html#decorators-with-parameters",
    "title": "Decorator Practically",
    "section": "",
    "text": "We can create decorators that accept parameters:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis repeat decorator takes an argument specifying how many times the decorated function should be called.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html#conclusion",
    "href": "content/Cours_4/3-Decorator_practically.html#conclusion",
    "title": "Decorator Practically",
    "section": "",
    "text": "These examples demonstrate the basic usage of decorators in Python. They allow for modifying or enhancing the behavior of functions and classes without changing their source code. Decorators provide a clean and reusable way to extend functionality, making code more modular and easier to maintain.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_library.html",
    "href": "content/Cours_4/TP_library.html",
    "title": "TP: Optimizing Heston Model Monte Carlo Simulation",
    "section": "",
    "text": "In this practical exercise, we’ll optimize a Monte Carlo simulation for pricing options under the Heston model. We’ll start with a basic implementation and then apply various optimization techniques, including Numba and caching. This TP is not to run on website directly as numba is not available on it.\n\n\nHere’s our starting point - a basic implementation of the Heston model Monte Carlo simulation:\nimport numpy as np\nimport time\nfrom scipy.stats import norm\n\ndef generate_random_values(num_simulations, num_steps):\n    return np.random.normal(0, 1, (num_simulations, num_steps, 2))\n\ndef heston_monte_carlo(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps):\n    random_values = generate_random_values(num_simulations, num_steps)\n    dt = T / num_steps\n    prices = np.zeros((num_simulations, num_steps + 1))\n    variances = np.zeros((num_simulations, num_steps + 1))\n    \n    prices[:, 0] = S0\n    variances[:, 0] = v0\n    for sim in range(num_simulations):\n        for i in range(1, num_steps + 1):\n            dW1 = random_values[sim, i-1, 0]\n            dW2 = rho * dW1 + np.sqrt(1 - rho**2) * random_values[sim, i-1, 1]\n            \n            variances[sim, i] = np.maximum(variances[sim, i-1] + kappa * (theta - variances[sim, i-1]) * dt + \n                                         sigma * np.sqrt(variances[sim, i-1] * dt) * dW2, 0)\n            \n            prices[sim, i] = prices[sim, i-1] * np.exp((r - 0.5 * variances[sim, i-1]) * dt + \n                                                   np.sqrt(variances[sim, i-1] * dt) * dW1)\n        \n    option_prices = np.mean(np.maximum(prices[:, -1] - K, 0))\n    return np.exp(-r * T) * option_prices\n\n# Test the implementation\nnum_options = 10\nkappa, theta, sigma, rho, v0 = 2, 0.04, 0.3, -0.7, 0.04\nS0s = np.random.randint(90, 110, num_options)\nKs = np.random.randint(90, 110, num_options)\nT = 1\nr = 0.05\nnum_simulations, num_steps = 1000, 252\n\nstart_time = time.time()\nfor option_row in range(num_options):\n    S0 = S0s[option_row]\n    K = Ks[option_row]\n    price = heston_monte_carlo(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps)\n    \nprint(f\"Basic implementation took {(time.time() - start_time)/num_options:.4f} seconds per option\")\n\n\n\nYour first task is to optimize the Monte Carlo simulation using Numba. Here’s the structure you should follow:\nfrom numba import jit, prange\n\n@jit(nopython=True, cache=True, parallel=True)\ndef heston_monte_carlo_numba(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps):\n    # Your implementation here\n    pass\n\n# Test the Numba-optimized function\nnum_options = 1000\n# ... (use the same parameters as in the baseline implementation)\n\nstart_time = time.time()\nfor option_row in range(num_options):\n    S0 = S0s[option_row]\n    K = Ks[option_row]\n    price_numba = heston_monte_carlo_numba(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps)\n\nprint(f\"Numba implementation took {(time.time() - start_time)/num_options:.4f} seconds per option\")\n\n\n\nNext, implement a cached version of the Monte Carlo simulation. Here’s the structure to follow:\nfrom functools import cache\n\n@cache\ndef generate_random_values(num_simulations, num_steps):\n    return np.random.normal(0, 1, (num_simulations, num_steps, 2))\n\n@cache\ndef heston_monte_carlo_cached(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps):\n    # Your implementation here\n    pass\n\n# Test the cached implementation\nstart_time = time.time()\nfor option_row in range(num_options):\n    S0 = S0s[option_row]\n    K = Ks[option_row]\n    price_cached = heston_monte_carlo_cached(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps)\n    \nprint(f\"First run of cached implementation took {time.time() - start_time:.2f} seconds\")\n\n# Run it again to see the effect of caching\nstart_time = time.time()\nfor option_row in range(num_options):\n    S0 = S0s[option_row]\n    K = Ks[option_row]\n    price_cached = heston_monte_carlo_cached(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps)\n    \nprint(f\"Second run of cached implementation took {time.time() - start_time:.2f} seconds\")\n\n\n\n\nCompare the performance of the three implementations (basic, Numba, and cached). What speedup do you achieve with each optimization technique?\nExperiment with different numbers of simulations and time steps. How does the performance of each implementation scale?\nDiscuss the trade-offs between the different implementations in terms of speed, memory usage, and code complexity.\n\n\n\n\nAs a final task, implement a vectorized version of the initial implementation without using Numba:\ndef heston_monte_carlo_vectorized(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps):\n    # Your vectorized implementation here\n    pass\n\n# Test the vectorized implementation\nstart_time = time.time()\nfor option_row in range(num_options):\n    S0 = S0s[option_row]\n    K = Ks[option_row]\n    price_vectorized = heston_monte_carlo_vectorized(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps)\n\nprint(f\"Vectorized implementation took {(time.time() - start_time)/num_options:.4f} seconds per option\")\nCompare the performance of this vectorized implementation with the previous versions. Discuss the advantages and potential limitations of vectorization in this context.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Optimizing Heston Model Monte Carlo Simulation"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_library.html#part-1-baseline-implementation",
    "href": "content/Cours_4/TP_library.html#part-1-baseline-implementation",
    "title": "TP: Optimizing Heston Model Monte Carlo Simulation",
    "section": "",
    "text": "Here’s our starting point - a basic implementation of the Heston model Monte Carlo simulation:\nimport numpy as np\nimport time\nfrom scipy.stats import norm\n\ndef generate_random_values(num_simulations, num_steps):\n    return np.random.normal(0, 1, (num_simulations, num_steps, 2))\n\ndef heston_monte_carlo(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps):\n    random_values = generate_random_values(num_simulations, num_steps)\n    dt = T / num_steps\n    prices = np.zeros((num_simulations, num_steps + 1))\n    variances = np.zeros((num_simulations, num_steps + 1))\n    \n    prices[:, 0] = S0\n    variances[:, 0] = v0\n    for sim in range(num_simulations):\n        for i in range(1, num_steps + 1):\n            dW1 = random_values[sim, i-1, 0]\n            dW2 = rho * dW1 + np.sqrt(1 - rho**2) * random_values[sim, i-1, 1]\n            \n            variances[sim, i] = np.maximum(variances[sim, i-1] + kappa * (theta - variances[sim, i-1]) * dt + \n                                         sigma * np.sqrt(variances[sim, i-1] * dt) * dW2, 0)\n            \n            prices[sim, i] = prices[sim, i-1] * np.exp((r - 0.5 * variances[sim, i-1]) * dt + \n                                                   np.sqrt(variances[sim, i-1] * dt) * dW1)\n        \n    option_prices = np.mean(np.maximum(prices[:, -1] - K, 0))\n    return np.exp(-r * T) * option_prices\n\n# Test the implementation\nnum_options = 10\nkappa, theta, sigma, rho, v0 = 2, 0.04, 0.3, -0.7, 0.04\nS0s = np.random.randint(90, 110, num_options)\nKs = np.random.randint(90, 110, num_options)\nT = 1\nr = 0.05\nnum_simulations, num_steps = 1000, 252\n\nstart_time = time.time()\nfor option_row in range(num_options):\n    S0 = S0s[option_row]\n    K = Ks[option_row]\n    price = heston_monte_carlo(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps)\n    \nprint(f\"Basic implementation took {(time.time() - start_time)/num_options:.4f} seconds per option\")",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Optimizing Heston Model Monte Carlo Simulation"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_library.html#part-2-optimization-with-numba",
    "href": "content/Cours_4/TP_library.html#part-2-optimization-with-numba",
    "title": "TP: Optimizing Heston Model Monte Carlo Simulation",
    "section": "",
    "text": "Your first task is to optimize the Monte Carlo simulation using Numba. Here’s the structure you should follow:\nfrom numba import jit, prange\n\n@jit(nopython=True, cache=True, parallel=True)\ndef heston_monte_carlo_numba(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps):\n    # Your implementation here\n    pass\n\n# Test the Numba-optimized function\nnum_options = 1000\n# ... (use the same parameters as in the baseline implementation)\n\nstart_time = time.time()\nfor option_row in range(num_options):\n    S0 = S0s[option_row]\n    K = Ks[option_row]\n    price_numba = heston_monte_carlo_numba(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps)\n\nprint(f\"Numba implementation took {(time.time() - start_time)/num_options:.4f} seconds per option\")",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Optimizing Heston Model Monte Carlo Simulation"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_library.html#part-3-optimization-with-caching",
    "href": "content/Cours_4/TP_library.html#part-3-optimization-with-caching",
    "title": "TP: Optimizing Heston Model Monte Carlo Simulation",
    "section": "",
    "text": "Next, implement a cached version of the Monte Carlo simulation. Here’s the structure to follow:\nfrom functools import cache\n\n@cache\ndef generate_random_values(num_simulations, num_steps):\n    return np.random.normal(0, 1, (num_simulations, num_steps, 2))\n\n@cache\ndef heston_monte_carlo_cached(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps):\n    # Your implementation here\n    pass\n\n# Test the cached implementation\nstart_time = time.time()\nfor option_row in range(num_options):\n    S0 = S0s[option_row]\n    K = Ks[option_row]\n    price_cached = heston_monte_carlo_cached(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps)\n    \nprint(f\"First run of cached implementation took {time.time() - start_time:.2f} seconds\")\n\n# Run it again to see the effect of caching\nstart_time = time.time()\nfor option_row in range(num_options):\n    S0 = S0s[option_row]\n    K = Ks[option_row]\n    price_cached = heston_monte_carlo_cached(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps)\n    \nprint(f\"Second run of cached implementation took {time.time() - start_time:.2f} seconds\")",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Optimizing Heston Model Monte Carlo Simulation"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_library.html#part-4-analysis-and-comparison",
    "href": "content/Cours_4/TP_library.html#part-4-analysis-and-comparison",
    "title": "TP: Optimizing Heston Model Monte Carlo Simulation",
    "section": "",
    "text": "Compare the performance of the three implementations (basic, Numba, and cached). What speedup do you achieve with each optimization technique?\nExperiment with different numbers of simulations and time steps. How does the performance of each implementation scale?\nDiscuss the trade-offs between the different implementations in terms of speed, memory usage, and code complexity.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Optimizing Heston Model Monte Carlo Simulation"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_library.html#part-5-vectorization-bonus",
    "href": "content/Cours_4/TP_library.html#part-5-vectorization-bonus",
    "title": "TP: Optimizing Heston Model Monte Carlo Simulation",
    "section": "",
    "text": "As a final task, implement a vectorized version of the initial implementation without using Numba:\ndef heston_monte_carlo_vectorized(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps):\n    # Your vectorized implementation here\n    pass\n\n# Test the vectorized implementation\nstart_time = time.time()\nfor option_row in range(num_options):\n    S0 = S0s[option_row]\n    K = Ks[option_row]\n    price_vectorized = heston_monte_carlo_vectorized(S0, K, T, r, kappa, theta, sigma, rho, v0, num_simulations, num_steps)\n\nprint(f\"Vectorized implementation took {(time.time() - start_time)/num_options:.4f} seconds per option\")\nCompare the performance of this vectorized implementation with the previous versions. Discuss the advantages and potential limitations of vectorization in this context.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Optimizing Heston Model Monte Carlo Simulation"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html",
    "href": "content/Cours_4/2-Decorator_theory.html",
    "title": "The decorator pattern",
    "section": "",
    "text": "Decorators are a powerful and flexible design pattern in programming that allow for the dynamic modification or enhancement of object behavior without altering their structure. The concept of decorators has its roots in object-oriented programming and design patterns, evolving over time to become a fundamental feature in many modern programming languages.\n\n\n\nThe decorator pattern was first formally described in the seminal book “Design Patterns: Elements of Reusable Object-Oriented Software” by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (often referred to as the “Gang of Four” or GoF) in 1994. However, the underlying concepts had been in use for some time before that.\n\n\n\nAs object-oriented programming (OOP) gained popularity in the 1980s and early 1990s, developers faced challenges in creating flexible and maintainable code. Inheritance, while powerful, sometimes led to complex class hierarchies and the need for numerous subclasses to accommodate various combinations of behaviors.\n\n\n\nThe decorator pattern was conceived as a solution to these challenges. It provided a way to add responsibilities to objects dynamically, offering an alternative to subclassing for extending functionality. This pattern adheres to the Open/Closed Principle, one of the SOLID principles of object-oriented design, which states that software entities should be open for extension but closed for modification.\n\n\n\n\nComponent Interface: Defines the interface for objects that can have responsibilities added to them dynamically.\nConcrete Component: Defines an object to which additional responsibilities can be attached.\nDecorator: Maintains a reference to a Component object and defines an interface that conforms to Component’s interface.\nConcrete Decorator: Adds responsibilities to the component.\n\n\n\n\nThe decorator pattern offered several advantages over traditional inheritance:\n\nFlexibility: Allowed for the dynamic addition of responsibilities at runtime.\nComposition over inheritance: Promoted object composition, reducing the reliance on complex inheritance hierarchies.\nSingle Responsibility Principle: Each decorator could focus on a single concern, improving modularity.\n\n\n\n\nEarly implementations of the decorator pattern were often verbose and required significant boilerplate code. Developers had to create multiple classes to achieve the desired functionality, which, while powerful, could lead to code that was hard to read and maintain.\n\n\n\nAs the pattern gained popularity, different programming languages began to incorporate decorator-like features:\n\nJava: Introduced annotations in Java 5 (2004), which, while not identical to decorators, served similar purposes in many cases.\nC#: Added attributes, which are similar to Java’s annotations and can be used for decorator-like functionality.\nJavaScript: Proposed decorators as part of ECMAScript, though they are still in the proposal stage as of 2024.\n\n\n\n\nPython introduced decorator syntax in version 2.4 (2004), significantly simplifying the implementation of the decorator pattern. Python’s approach made decorators a first-class language feature, allowing for more readable and maintainable code.\n\n\n\nThe decorator pattern and its various implementations have had a profound impact on modern programming:\n\nAspect-Oriented Programming (AOP): Decorators are often used to implement cross-cutting concerns in AOP.\nMiddleware in Web Frameworks: Many web frameworks use decorator-like patterns for middleware implementation.\nMetaprogramming: Decorators have become a powerful tool for metaprogramming, allowing for code generation and modification at runtime.\n\n\n\n\nThe decorator pattern, from its formal description in 1994 to its various implementations in modern programming languages, has proven to be a versatile and powerful concept. It has evolved from a design pattern requiring significant implementation effort to a built-in feature in languages like Python, demonstrating its value in creating flexible, maintainable, and extensible code.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#introduction-to-decorators",
    "href": "content/Cours_4/2-Decorator_theory.html#introduction-to-decorators",
    "title": "The decorator pattern",
    "section": "",
    "text": "Decorators are a powerful and flexible design pattern in programming that allow for the dynamic modification or enhancement of object behavior without altering their structure. The concept of decorators has its roots in object-oriented programming and design patterns, evolving over time to become a fundamental feature in many modern programming languages.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#historical-context",
    "href": "content/Cours_4/2-Decorator_theory.html#historical-context",
    "title": "The decorator pattern",
    "section": "",
    "text": "The decorator pattern was first formally described in the seminal book “Design Patterns: Elements of Reusable Object-Oriented Software” by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (often referred to as the “Gang of Four” or GoF) in 1994. However, the underlying concepts had been in use for some time before that.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#object-oriented-programming-and-the-need-for-flexibility",
    "href": "content/Cours_4/2-Decorator_theory.html#object-oriented-programming-and-the-need-for-flexibility",
    "title": "The decorator pattern",
    "section": "",
    "text": "As object-oriented programming (OOP) gained popularity in the 1980s and early 1990s, developers faced challenges in creating flexible and maintainable code. Inheritance, while powerful, sometimes led to complex class hierarchies and the need for numerous subclasses to accommodate various combinations of behaviors.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#the-decorator-pattern-emerges",
    "href": "content/Cours_4/2-Decorator_theory.html#the-decorator-pattern-emerges",
    "title": "The decorator pattern",
    "section": "",
    "text": "The decorator pattern was conceived as a solution to these challenges. It provided a way to add responsibilities to objects dynamically, offering an alternative to subclassing for extending functionality. This pattern adheres to the Open/Closed Principle, one of the SOLID principles of object-oriented design, which states that software entities should be open for extension but closed for modification.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#key-concepts-of-the-decorator-pattern",
    "href": "content/Cours_4/2-Decorator_theory.html#key-concepts-of-the-decorator-pattern",
    "title": "The decorator pattern",
    "section": "",
    "text": "Component Interface: Defines the interface for objects that can have responsibilities added to them dynamically.\nConcrete Component: Defines an object to which additional responsibilities can be attached.\nDecorator: Maintains a reference to a Component object and defines an interface that conforms to Component’s interface.\nConcrete Decorator: Adds responsibilities to the component.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#advantages-over-traditional-inheritance",
    "href": "content/Cours_4/2-Decorator_theory.html#advantages-over-traditional-inheritance",
    "title": "The decorator pattern",
    "section": "",
    "text": "The decorator pattern offered several advantages over traditional inheritance:\n\nFlexibility: Allowed for the dynamic addition of responsibilities at runtime.\nComposition over inheritance: Promoted object composition, reducing the reliance on complex inheritance hierarchies.\nSingle Responsibility Principle: Each decorator could focus on a single concern, improving modularity.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#early-implementations",
    "href": "content/Cours_4/2-Decorator_theory.html#early-implementations",
    "title": "The decorator pattern",
    "section": "",
    "text": "Early implementations of the decorator pattern were often verbose and required significant boilerplate code. Developers had to create multiple classes to achieve the desired functionality, which, while powerful, could lead to code that was hard to read and maintain.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#evolution-in-different-programming-languages",
    "href": "content/Cours_4/2-Decorator_theory.html#evolution-in-different-programming-languages",
    "title": "The decorator pattern",
    "section": "",
    "text": "As the pattern gained popularity, different programming languages began to incorporate decorator-like features:\n\nJava: Introduced annotations in Java 5 (2004), which, while not identical to decorators, served similar purposes in many cases.\nC#: Added attributes, which are similar to Java’s annotations and can be used for decorator-like functionality.\nJavaScript: Proposed decorators as part of ECMAScript, though they are still in the proposal stage as of 2024.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#pythons-adoption-of-decorators",
    "href": "content/Cours_4/2-Decorator_theory.html#pythons-adoption-of-decorators",
    "title": "The decorator pattern",
    "section": "",
    "text": "Python introduced decorator syntax in version 2.4 (2004), significantly simplifying the implementation of the decorator pattern. Python’s approach made decorators a first-class language feature, allowing for more readable and maintainable code.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#impact-on-modern-programming",
    "href": "content/Cours_4/2-Decorator_theory.html#impact-on-modern-programming",
    "title": "The decorator pattern",
    "section": "",
    "text": "The decorator pattern and its various implementations have had a profound impact on modern programming:\n\nAspect-Oriented Programming (AOP): Decorators are often used to implement cross-cutting concerns in AOP.\nMiddleware in Web Frameworks: Many web frameworks use decorator-like patterns for middleware implementation.\nMetaprogramming: Decorators have become a powerful tool for metaprogramming, allowing for code generation and modification at runtime.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#conclusion",
    "href": "content/Cours_4/2-Decorator_theory.html#conclusion",
    "title": "The decorator pattern",
    "section": "",
    "text": "The decorator pattern, from its formal description in 1994 to its various implementations in modern programming languages, has proven to be a versatile and powerful concept. It has evolved from a design pattern requiring significant implementation effort to a built-in feature in languages like Python, demonstrating its value in creating flexible, maintainable, and extensible code.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_2/3-Composition.html",
    "href": "content/Cours_2/3-Composition.html",
    "title": "Héritage vs Composition",
    "section": "",
    "text": "Héritage vs Composition\n\n\nDéfinitions\n\nHéritage : Une relation “est-un” où une classe dérive d’une autre, héritant de ses attributs et méthodes.\nComposition : Une relation “a-un” où une classe contient une instance d’une autre classe comme attribut.\n\n\n\nComparaison\n\nHéritage\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nComposition\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nAvantages et inconvénients\n\nHéritage\nAvantages : - Permet une réutilisation directe du code - Représente bien les relations hiérarchiques naturelles - Facilite le polymorphisme\nInconvénients : - Peut créer un couplage fort entre les classes - Peut devenir complexe avec l’héritage multiple - Peut violer le principe de substitution de Liskov si mal utilisé\n\n\nComposition\nAvantages : - Offre une plus grande flexibilité - Permet une meilleure encapsulation - Facilite les changements de comportement à l’exécution\nInconvénients : - Peut nécessiter plus de code initial - Peut être moins intuitif pour représenter certaines relations\n\n\n\nQuand utiliser l’un ou l’autre ?\n\nUtilisez l’héritage quand :\n\nIl existe une relation “est-un” claire et logique\nVous voulez réutiliser le code dans plusieurs classes dérivées\nLe comportement de la classe de base ne change pas souvent\n\nExemple : Chien est un Animal, Carré est une Forme\nUtilisez la composition quand :\n\nIl existe une relation “a-un” ou “utilise-un”\nVous voulez une plus grande flexibilité pour changer les comportements\nVous voulez éviter les problèmes liés à l’héritage multiple\n\nExemple : Voiture a un Moteur, Ordinateur a une CPU\n\n\n\nPrincipe de conception : “Favoriser la composition sur l’héritage”\nCe principe suggère d’utiliser la composition comme première approche, car elle offre généralement plus de flexibilité et un couplage plus faible. L’héritage devrait être utilisé judicieusement, lorsqu’il représente vraiment une relation “est-un”.\n\n\nExemple combinant héritage et composition\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple : - Epee hérite de Arme (relation “est-un”) - Guerrier hérite de Personnage (relation “est-un”) - Personnage utilise la composition avec Arme (relation “a-un”)\nCette approche combine les avantages de l’héritage et de la composition, permettant une structure flexible et extensible.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Héritage vs Composition"
    ]
  },
  {
    "objectID": "content/Cours_2/TP_dunder.html",
    "href": "content/Cours_2/TP_dunder.html",
    "title": "TP: Dunder Method with Tensor for Automatic Differentiation",
    "section": "",
    "text": "Imagine you have a complex mathematical function. It might look intimidating at first, but it’s actually just a composition of simple operations. For example, consider this function:\n\\(f(x, y) = (x^2 + 2y) * \\sin(x + y)\\)\nWe can break this down into simpler operations:\n\n\\(a = x^2\\)\n\\(b = 2y\\)\n\\(c = a + b\\) (which is \\(x^2 + 2y\\))\n\\(d = x + y\\)\n\\(e = \\sin(d)\\) (which is \\(\\sin(x + y)\\))\n\\(f = c * e\\) (our final result)\n\n\n\n\nNow, here’s the magic: if we know how to differentiate each of these simple operations, we can automatically compute the derivative of the entire complex function. This is the essence of automatic differentiation.\nLet’s say we want to find \\(\\frac{\\partial f}{\\partial x}\\). We can use the chain rule:\n\\(\\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial c} \\cdot \\frac{\\partial c}{\\partial x} + \\frac{\\partial f}{\\partial e} \\cdot \\frac{\\partial e}{\\partial d} \\cdot \\frac{\\partial d}{\\partial x}\\)\nBreaking it down: - \\(\\frac{\\partial f}{\\partial c} = e\\) - \\(\\frac{\\partial c}{\\partial x} = 2x\\) - \\(\\frac{\\partial f}{\\partial e} = c\\) - \\(\\frac{\\partial e}{\\partial d} = \\cos(d)\\) - \\(\\frac{\\partial d}{\\partial x} = 1\\)\nPutting it all together:\n\\(\\frac{\\partial f}{\\partial x} = e \\cdot 2x + c \\cdot \\cos(d) \\cdot 1\\)\n\n\n\nThis is where tensors come in. In our implementation, a tensor will not only store its value but also remember: 1. The operation that created it 2. The tensors that were inputs to this operation 3. How to compute its derivative with respect to its inputs\nBy doing this for each operation, we create a computational graph. When we want to compute the derivative of our final result with respect to any input, we can simply walk backwards through this graph, applying the chain rule at each step.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Dunder Method with Tensor for Automatic Differentiation"
    ]
  },
  {
    "objectID": "content/Cours_2/TP_dunder.html#understanding-tensors-and-automatic-differentiation",
    "href": "content/Cours_2/TP_dunder.html#understanding-tensors-and-automatic-differentiation",
    "title": "TP: Dunder Method with Tensor for Automatic Differentiation",
    "section": "",
    "text": "Imagine you have a complex mathematical function. It might look intimidating at first, but it’s actually just a composition of simple operations. For example, consider this function:\n\\(f(x, y) = (x^2 + 2y) * \\sin(x + y)\\)\nWe can break this down into simpler operations:\n\n\\(a = x^2\\)\n\\(b = 2y\\)\n\\(c = a + b\\) (which is \\(x^2 + 2y\\))\n\\(d = x + y\\)\n\\(e = \\sin(d)\\) (which is \\(\\sin(x + y)\\))\n\\(f = c * e\\) (our final result)\n\n\n\n\nNow, here’s the magic: if we know how to differentiate each of these simple operations, we can automatically compute the derivative of the entire complex function. This is the essence of automatic differentiation.\nLet’s say we want to find \\(\\frac{\\partial f}{\\partial x}\\). We can use the chain rule:\n\\(\\frac{\\partial f}{\\partial x} = \\frac{\\partial f}{\\partial c} \\cdot \\frac{\\partial c}{\\partial x} + \\frac{\\partial f}{\\partial e} \\cdot \\frac{\\partial e}{\\partial d} \\cdot \\frac{\\partial d}{\\partial x}\\)\nBreaking it down: - \\(\\frac{\\partial f}{\\partial c} = e\\) - \\(\\frac{\\partial c}{\\partial x} = 2x\\) - \\(\\frac{\\partial f}{\\partial e} = c\\) - \\(\\frac{\\partial e}{\\partial d} = \\cos(d)\\) - \\(\\frac{\\partial d}{\\partial x} = 1\\)\nPutting it all together:\n\\(\\frac{\\partial f}{\\partial x} = e \\cdot 2x + c \\cdot \\cos(d) \\cdot 1\\)\n\n\n\nThis is where tensors come in. In our implementation, a tensor will not only store its value but also remember: 1. The operation that created it 2. The tensors that were inputs to this operation 3. How to compute its derivative with respect to its inputs\nBy doing this for each operation, we create a computational graph. When we want to compute the derivative of our final result with respect to any input, we can simply walk backwards through this graph, applying the chain rule at each step.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Dunder Method with Tensor for Automatic Differentiation"
    ]
  },
  {
    "objectID": "content/Cours_2/TP_dunder.html#tp-instructions-implementing-a-basic-tensor-class-with-automatic-differentiation",
    "href": "content/Cours_2/TP_dunder.html#tp-instructions-implementing-a-basic-tensor-class-with-automatic-differentiation",
    "title": "TP: Dunder Method with Tensor for Automatic Differentiation",
    "section": "TP Instructions: Implementing a Basic Tensor Class with Automatic Differentiation",
    "text": "TP Instructions: Implementing a Basic Tensor Class with Automatic Differentiation\nYour task is to implement a simplified Tensor class that supports basic mathematical operations and automatic differentiation. This class will allow us to build simple computational graphs and compute gradients automatically.\nHere’s a skeleton of the Tensor class to get you started:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nYour tasks:\n\nImplement the reversed methods for already existing one like __radd__ or __rmul__.\nImplement the __sub__ and __truediv__ methods for subtraction and division operations.\nAdd support for operations between Tensors and regular numbers (scalars) in all methods.\nImplement a sin() method that computes the sine of a Tensor.\nAdd proper string representation methods (__repr__ and __str__).",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Dunder Method with Tensor for Automatic Differentiation"
    ]
  },
  {
    "objectID": "content/Cours_2/TP_dunder.html#example-usage-computing-gradients-of-a-complex-function",
    "href": "content/Cours_2/TP_dunder.html#example-usage-computing-gradients-of-a-complex-function",
    "title": "TP: Dunder Method with Tensor for Automatic Differentiation",
    "section": "Example Usage: Computing Gradients of a Complex Function",
    "text": "Example Usage: Computing Gradients of a Complex Function\nAfter implementing the Tensor class, you can use it to compute gradients of complex functions. Here’s an example using the function we discussed earlier:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis example demonstrates how your Tensor class can be used to automatically compute gradients of a complex function. The backward() method computes the gradients with respect to all input tensors.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Dunder Method with Tensor for Automatic Differentiation"
    ]
  },
  {
    "objectID": "content/Cours_2/TP_dunder.html#unitary-tests",
    "href": "content/Cours_2/TP_dunder.html#unitary-tests",
    "title": "TP: Dunder Method with Tensor for Automatic Differentiation",
    "section": "Unitary Tests",
    "text": "Unitary Tests\nHere are some unitary tests to verify your implementation. Implement your Tensor class in a file named tensor.py, and then use these tests to check your work:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Dunder Method with Tensor for Automatic Differentiation"
    ]
  },
  {
    "objectID": "content/Cours_2/1-Encapsulation.html",
    "href": "content/Cours_2/1-Encapsulation.html",
    "title": "Encapsulation en Python",
    "section": "",
    "text": "Encapsulation en Python\n\nL’encapsulation est l’un des principes fondamentaux de la programmation orientée objet. Elle consiste à regrouper les données et les méthodes qui les manipulent au sein d’une même unité (la classe) et à contrôler l’accès à ces données depuis l’extérieur de la classe.\n\nNotion de public et privé en Python\nContrairement à certains langages comme Java ou C++, Python n’a pas de mécanisme strict pour définir des attributs ou des méthodes comme “privés” ou “publics”. Cependant, Python suit une convention basée sur le nommage pour indiquer l’intention du développeur quant à l’utilisation des attributs et méthodes.\n\nAttributs et méthodes publics :\n\nNommés normalement, sans underscore.\nExemple : self.attribut, def methode(self):\nConsidérés comme faisant partie de l’interface publique de la classe.\n\nAttributs et méthodes “privés” (convention) :\n\nPréfixés par un simple underscore _.\nExemple : self._attribut, def _methode(self):\nIndique que ces éléments sont destinés à un usage interne et ne devraient pas être accédés directement depuis l’extérieur de la classe.\nCette convention est basée sur la confiance : techniquement, ces éléments restent accessibles.\n\nAttributs et méthodes “name mangling” :\n\nPréfixés par un double underscore __ (sans underscore à la fin).\nExemple : self.__attribut, def __methode(self):\nPython applique le “name mangling” : le nom est modifié en interne pour inclure le nom de la classe.\nRend l’accès depuis l’extérieur plus difficile, mais pas impossible.\n\n\n\n\nExemple d’encapsulation en Python\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nPoints importants à retenir :\n\nL’encapsulation en Python est basée sur des conventions plutôt que sur des restrictions strictes.\nLes attributs et méthodes préfixés par un underscore _ sont considérés comme internes à la classe.\nLe double underscore __ déclenche le name mangling, rendant l’accès externe plus difficile mais pas impossible.\nL’encapsulation est une question de conception et de discipline de programmation en Python.\nUtilisez des méthodes publiques (getters/setters) pour contrôler l’accès aux données internes si nécessaire.\n\n\n\nAvantages de l’encapsulation :\n\nContrôle de l’accès aux données\nFlexibilité pour modifier l’implémentation interne sans affecter le code qui utilise la classe\nPrévention des modifications accidentelles des données internes\nClarté du code en distinguant l’interface publique des détails d’implémentation\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Encapsulation en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/TP_heritage.html",
    "href": "content/Cours_2/TP_heritage.html",
    "title": "TP: Heritage avec le pricing d’option",
    "section": "",
    "text": "Ce TP est divisé en deux parties pour explorer les concepts d’héritage, d’encapsulation et de composition en programmation orientée objet (POO). Vous allez implémenter des classes pour évaluer des options financières en utilisant deux méthodes différentes : la formule de Black-Scholes et la simulation de Monte Carlo.\n\n\n\n\nLa formule de Black-Scholes est utilisée pour calculer le prix théorique d’une option européenne. Voici les principales formules :\n\n\\(d_1 = \\frac{\\ln(S/K) + (r + \\sigma^2/2)T}{\\sigma\\sqrt{T}}\\)\n\\(d_2 = d_1 - \\sigma\\sqrt{T}\\)J’a\nPrix d’un Call : \\(C = SN(d_1) - Ke^{-rT}N(d_2)\\)\nPrix d’un Put : \\(P = Ke^{-rT}N(-d_2) - SN(-d_1)\\)\n\nOù : - \\(S\\) : prix spot de l’actif sous-jacent - \\(K\\) : prix d’exercice de l’option - \\(r\\) : taux d’intérêt sans risque - \\(T\\) : temps jusqu’à l’expiration (en années) - \\(\\sigma\\) : volatilité de l’actif sous-jacent - \\(N(x)\\) : fonction de répartition de la loi normale centrée réduite\n\n\n\nLes Grecs sont des mesures de sensibilité du prix de l’option par rapport à divers paramètres :\n\nDelta (Δ) :\n\nPour un Call : \\(\\Delta_C = N(d_1)\\)\nPour un Put : \\(\\Delta_P = N(d_1) - 1\\)\n\nGamma (Γ) : \\(\\Gamma = \\frac{N'(d_1)}{S\\sigma\\sqrt{T}}\\)\nVega (ν) : \\(\\nu = S\\sqrt{T}N'(d_1)\\)\nTheta (Θ) :\n\nPour un Call : \\(\\Theta_C = -\\frac{SN'(d_1)\\sigma}{2\\sqrt{T}} - rKe^{-rT}N(d_2)\\)\nPour un Put : \\(\\Theta_P = -\\frac{SN'(d_1)\\sigma}{2\\sqrt{T}} + rKe^{-rT}N(-d_2)\\)\n\nRho (ρ) :\n\nPour un Call : \\(\\rho_C = KTe^{-rT}N(d_2)\\)\nPour un Put : \\(\\rho_P = -KTe^{-rT}N(-d_2)\\)\n\n\n\n\n\nLa méthode de Monte Carlo pour l’évaluation d’options implique les étapes suivantes :\n\nGénérer un grand nombre de trajectoires de prix pour l’actif sous-jacent en utilisant le mouvement brownien géométrique :\n\\(S_T = S_0 \\exp((r - \\frac{\\sigma^2}{2})T + \\sigma\\sqrt{T}Z)\\)\noù \\(Z\\) est une variable aléatoire normale standard.\nPour chaque trajectoire, calculer le payoff de l’option à l’échéance.\nCalculer la moyenne des payoffs actualisés :\n\\(\\text{Prix de l'option} = e^{-rT} \\frac{1}{N} \\sum_{i=1}^N \\text{Payoff}_i\\)\noù \\(N\\) est le nombre de simulations.\n\n\n\n\n\n\nCréez un fichier nommé black_scholes.py.\nImplémentez les classes suivantes :\n\nOption : Classe de base pour les options\nCall : Classe dérivée de Option pour les options d’achat\nPut : Classe dérivée de Option pour les options de vente\n\nChaque classe doit avoir les méthodes suivantes :\n\n__init__ : Constructeur avec les paramètres nécessaires\ncompute_price() : Calcule le prix de l’option\ncompute_delta() : Calcule le delta de l’option\ncompute_gamma() : Calcule le gamma de l’option\ncompute_vega() : Calcule le vega de l’option\ncompute_theta() : Calcule le theta de l’option\ncompute_rho() : Calcule le rho de l’option\n\nUtilisez la formule de Black-Scholes pour les calculs.\n\n\n\n\n\nCréez un fichier nommé monte_carlo.py.\nImplémentez les classes suivantes :\n\nDerivative : Classe de base pour les produits dérivés\nEuropeanOption : Classe dérivée de Derivative pour les options européennes\nPayoff : Classe de base pour les fonctions de payoff\nCallPayoff : Classe dérivée de Payoff pour le payoff d’une option d’achat\nPutPayoff : Classe dérivée de Payoff pour le payoff d’une option de vente\n\nLa classe Derivative doit avoir une méthode price() qui utilise la simulation de Monte Carlo.\nLes classes EuropeanOption et Payoff doivent utiliser la composition pour lier les payoffs aux options.\n\n\n\n\nVoici un ensemble de tests unitaires pour vérifier votre implémentation de la Partie 1 (Black-Scholes) :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nEt voici un ensemble de tests unitaires pour la Partie 2 (Monte Carlo) :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nCommencez par implémenter la Partie 1 (Black-Scholes) avant de passer à la Partie 2 (Monte Carlo).\nUtilisez l’encapsulation pour protéger les attributs de vos classes.\nProfitez de l’héritage pour factoriser le code commun entre les classes Call et Put.\nPour la Partie 2, utilisez la composition pour lier les payoffs aux options européennes.\nN’oubliez pas d’importer les bibliothèques nécessaires (math, numpy, scipy.stats).\nTestez votre code régulièrement en utilisant les tests unitaires fournis.\nUtilisez les formules fournies dans les rappels théoriques pour implémenter vos méthodes.\n\nBonne chance !",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Heritage avec le pricing d'option"
    ]
  },
  {
    "objectID": "content/Cours_2/TP_heritage.html#rappels-théoriques",
    "href": "content/Cours_2/TP_heritage.html#rappels-théoriques",
    "title": "TP: Heritage avec le pricing d’option",
    "section": "",
    "text": "La formule de Black-Scholes est utilisée pour calculer le prix théorique d’une option européenne. Voici les principales formules :\n\n\\(d_1 = \\frac{\\ln(S/K) + (r + \\sigma^2/2)T}{\\sigma\\sqrt{T}}\\)\n\\(d_2 = d_1 - \\sigma\\sqrt{T}\\)J’a\nPrix d’un Call : \\(C = SN(d_1) - Ke^{-rT}N(d_2)\\)\nPrix d’un Put : \\(P = Ke^{-rT}N(-d_2) - SN(-d_1)\\)\n\nOù : - \\(S\\) : prix spot de l’actif sous-jacent - \\(K\\) : prix d’exercice de l’option - \\(r\\) : taux d’intérêt sans risque - \\(T\\) : temps jusqu’à l’expiration (en années) - \\(\\sigma\\) : volatilité de l’actif sous-jacent - \\(N(x)\\) : fonction de répartition de la loi normale centrée réduite\n\n\n\nLes Grecs sont des mesures de sensibilité du prix de l’option par rapport à divers paramètres :\n\nDelta (Δ) :\n\nPour un Call : \\(\\Delta_C = N(d_1)\\)\nPour un Put : \\(\\Delta_P = N(d_1) - 1\\)\n\nGamma (Γ) : \\(\\Gamma = \\frac{N'(d_1)}{S\\sigma\\sqrt{T}}\\)\nVega (ν) : \\(\\nu = S\\sqrt{T}N'(d_1)\\)\nTheta (Θ) :\n\nPour un Call : \\(\\Theta_C = -\\frac{SN'(d_1)\\sigma}{2\\sqrt{T}} - rKe^{-rT}N(d_2)\\)\nPour un Put : \\(\\Theta_P = -\\frac{SN'(d_1)\\sigma}{2\\sqrt{T}} + rKe^{-rT}N(-d_2)\\)\n\nRho (ρ) :\n\nPour un Call : \\(\\rho_C = KTe^{-rT}N(d_2)\\)\nPour un Put : \\(\\rho_P = -KTe^{-rT}N(-d_2)\\)\n\n\n\n\n\nLa méthode de Monte Carlo pour l’évaluation d’options implique les étapes suivantes :\n\nGénérer un grand nombre de trajectoires de prix pour l’actif sous-jacent en utilisant le mouvement brownien géométrique :\n\\(S_T = S_0 \\exp((r - \\frac{\\sigma^2}{2})T + \\sigma\\sqrt{T}Z)\\)\noù \\(Z\\) est une variable aléatoire normale standard.\nPour chaque trajectoire, calculer le payoff de l’option à l’échéance.\nCalculer la moyenne des payoffs actualisés :\n\\(\\text{Prix de l'option} = e^{-rT} \\frac{1}{N} \\sum_{i=1}^N \\text{Payoff}_i\\)\noù \\(N\\) est le nombre de simulations.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Heritage avec le pricing d'option"
    ]
  },
  {
    "objectID": "content/Cours_2/TP_heritage.html#partie-1-implémentation-de-black-scholes",
    "href": "content/Cours_2/TP_heritage.html#partie-1-implémentation-de-black-scholes",
    "title": "TP: Heritage avec le pricing d’option",
    "section": "",
    "text": "Créez un fichier nommé black_scholes.py.\nImplémentez les classes suivantes :\n\nOption : Classe de base pour les options\nCall : Classe dérivée de Option pour les options d’achat\nPut : Classe dérivée de Option pour les options de vente\n\nChaque classe doit avoir les méthodes suivantes :\n\n__init__ : Constructeur avec les paramètres nécessaires\ncompute_price() : Calcule le prix de l’option\ncompute_delta() : Calcule le delta de l’option\ncompute_gamma() : Calcule le gamma de l’option\ncompute_vega() : Calcule le vega de l’option\ncompute_theta() : Calcule le theta de l’option\ncompute_rho() : Calcule le rho de l’option\n\nUtilisez la formule de Black-Scholes pour les calculs.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Heritage avec le pricing d'option"
    ]
  },
  {
    "objectID": "content/Cours_2/TP_heritage.html#partie-2-implémentation-de-monte-carlo",
    "href": "content/Cours_2/TP_heritage.html#partie-2-implémentation-de-monte-carlo",
    "title": "TP: Heritage avec le pricing d’option",
    "section": "",
    "text": "Créez un fichier nommé monte_carlo.py.\nImplémentez les classes suivantes :\n\nDerivative : Classe de base pour les produits dérivés\nEuropeanOption : Classe dérivée de Derivative pour les options européennes\nPayoff : Classe de base pour les fonctions de payoff\nCallPayoff : Classe dérivée de Payoff pour le payoff d’une option d’achat\nPutPayoff : Classe dérivée de Payoff pour le payoff d’une option de vente\n\nLa classe Derivative doit avoir une méthode price() qui utilise la simulation de Monte Carlo.\nLes classes EuropeanOption et Payoff doivent utiliser la composition pour lier les payoffs aux options.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Heritage avec le pricing d'option"
    ]
  },
  {
    "objectID": "content/Cours_2/TP_heritage.html#tests-unitaires",
    "href": "content/Cours_2/TP_heritage.html#tests-unitaires",
    "title": "TP: Heritage avec le pricing d’option",
    "section": "",
    "text": "Voici un ensemble de tests unitaires pour vérifier votre implémentation de la Partie 1 (Black-Scholes) :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nEt voici un ensemble de tests unitaires pour la Partie 2 (Monte Carlo) :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Heritage avec le pricing d'option"
    ]
  },
  {
    "objectID": "content/Cours_2/TP_heritage.html#conseils",
    "href": "content/Cours_2/TP_heritage.html#conseils",
    "title": "TP: Heritage avec le pricing d’option",
    "section": "",
    "text": "Commencez par implémenter la Partie 1 (Black-Scholes) avant de passer à la Partie 2 (Monte Carlo).\nUtilisez l’encapsulation pour protéger les attributs de vos classes.\nProfitez de l’héritage pour factoriser le code commun entre les classes Call et Put.\nPour la Partie 2, utilisez la composition pour lier les payoffs aux options européennes.\nN’oubliez pas d’importer les bibliothèques nécessaires (math, numpy, scipy.stats).\nTestez votre code régulièrement en utilisant les tests unitaires fournis.\nUtilisez les formules fournies dans les rappels théoriques pour implémenter vos méthodes.\n\nBonne chance !",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Heritage avec le pricing d'option"
    ]
  },
  {
    "objectID": "content/Cours_3/3-type_to_create.html",
    "href": "content/Cours_3/3-type_to_create.html",
    "title": "Class Creation: Standard vs type()",
    "section": "",
    "text": "In Python, we typically create classes using the class keyword. However, Python also provides a way to create classes dynamically using the type() function. Let’s compare these two methods and understand when and why you might use type() for class creation.\n\n\nHere’s how we normally create a class in Python:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nNow, let’s create the exact same class using type():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe type() function takes three arguments: 1. The name of the class as a string 2. A tuple of base classes (empty in this case) 3. A dictionary of attributes and methods\n\n\n\nLet’s see how inheritance works with both methods:\nStandard way:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUsing type():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nIt’s important to understand that these two methods are equivalent - they produce the same result. The class keyword is syntactic sugar for what type() does under the hood.\nUsing type() can be useful in scenarios where you need to create classes dynamically based on runtime information. For example:\n\nGenerating classes based on data schemas\nImplementing plugin systems\nCreating domain-specific languages\n\nHowever, for most use cases, the standard class syntax is more readable and maintainable.\n\n\n\nWhen using multiprocessing in Python, dynamically created classes can sometimes cause issues. This is because classes created with type() at runtime might not be picklable, which is required for multiprocessing in Python.\nFor example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis code might raise a PicklingError because the dynamically created class is not defined at the top level of a module.\n\n\n\nWhile type() provides a way to create classes dynamically, it’s generally better to stick with the standard class syntax for most use cases. Dynamic class creation can be powerful but can also lead to code that’s harder to understand and maintain. It’s a tool best reserved for specific scenarios where runtime class creation is necessary.\nRemember, clear and readable code is usually preferable to clever tricks. Use dynamic class creation judiciously and always consider the long-term maintainability of your code.",
    "crumbs": [
      "Class Creation: Standard vs type()"
    ]
  },
  {
    "objectID": "content/Cours_3/3-type_to_create.html#standard-class-creation",
    "href": "content/Cours_3/3-type_to_create.html#standard-class-creation",
    "title": "Class Creation: Standard vs type()",
    "section": "",
    "text": "Here’s how we normally create a class in Python:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Class Creation: Standard vs type()"
    ]
  },
  {
    "objectID": "content/Cours_3/3-type_to_create.html#class-creation-with-type",
    "href": "content/Cours_3/3-type_to_create.html#class-creation-with-type",
    "title": "Class Creation: Standard vs type()",
    "section": "",
    "text": "Now, let’s create the exact same class using type():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe type() function takes three arguments: 1. The name of the class as a string 2. A tuple of base classes (empty in this case) 3. A dictionary of attributes and methods",
    "crumbs": [
      "Class Creation: Standard vs type()"
    ]
  },
  {
    "objectID": "content/Cours_3/3-type_to_create.html#inheritance-example",
    "href": "content/Cours_3/3-type_to_create.html#inheritance-example",
    "title": "Class Creation: Standard vs type()",
    "section": "",
    "text": "Let’s see how inheritance works with both methods:\nStandard way:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUsing type():\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Class Creation: Standard vs type()"
    ]
  },
  {
    "objectID": "content/Cours_3/3-type_to_create.html#equivalence-and-use-cases",
    "href": "content/Cours_3/3-type_to_create.html#equivalence-and-use-cases",
    "title": "Class Creation: Standard vs type()",
    "section": "",
    "text": "It’s important to understand that these two methods are equivalent - they produce the same result. The class keyword is syntactic sugar for what type() does under the hood.\nUsing type() can be useful in scenarios where you need to create classes dynamically based on runtime information. For example:\n\nGenerating classes based on data schemas\nImplementing plugin systems\nCreating domain-specific languages\n\nHowever, for most use cases, the standard class syntax is more readable and maintainable.",
    "crumbs": [
      "Class Creation: Standard vs type()"
    ]
  },
  {
    "objectID": "content/Cours_3/3-type_to_create.html#potential-issues-with-multiprocessing",
    "href": "content/Cours_3/3-type_to_create.html#potential-issues-with-multiprocessing",
    "title": "Class Creation: Standard vs type()",
    "section": "",
    "text": "When using multiprocessing in Python, dynamically created classes can sometimes cause issues. This is because classes created with type() at runtime might not be picklable, which is required for multiprocessing in Python.\nFor example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis code might raise a PicklingError because the dynamically created class is not defined at the top level of a module.",
    "crumbs": [
      "Class Creation: Standard vs type()"
    ]
  },
  {
    "objectID": "content/Cours_3/3-type_to_create.html#conclusion",
    "href": "content/Cours_3/3-type_to_create.html#conclusion",
    "title": "Class Creation: Standard vs type()",
    "section": "",
    "text": "While type() provides a way to create classes dynamically, it’s generally better to stick with the standard class syntax for most use cases. Dynamic class creation can be powerful but can also lead to code that’s harder to understand and maintain. It’s a tool best reserved for specific scenarios where runtime class creation is necessary.\nRemember, clear and readable code is usually preferable to clever tricks. Use dynamic class creation judiciously and always consider the long-term maintainability of your code.",
    "crumbs": [
      "Class Creation: Standard vs type()"
    ]
  },
  {
    "objectID": "content/Cours_3/6-Protocol.html",
    "href": "content/Cours_3/6-Protocol.html",
    "title": "Protocol Classes",
    "section": "",
    "text": "Protocols, introduced in Python 3.8, provide a way to define structural subtyping (often called “duck typing”). They allow you to define interfaces in a more flexible and Pythonic way compared to abstract base classes.\n\n\n\n\nStructural Subtyping: An object is considered a subtype if it has the required methods and attributes, regardless of inheritance.\nNo Runtime Enforcement: Protocols are primarily used for static type checking and don’t enforce method implementation at runtime.\nFlexibility: Classes don’t need to explicitly inherit from a Protocol to be considered compatible.\n\n\n\n\nTo use Protocols, you need to import from the typing module:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - Drawable is a Protocol that defines an interface with a draw method. - Circle is compatible with Drawable because it has a draw method, even though it doesn’t explicitly inherit from Drawable.\n\n\n\n\nFlexibility: You can define interfaces for existing classes without modifying them.\nDuck Typing: Aligns well with Python’s “duck typing” philosophy.\nStatic Type Checking: Provides benefits of static typing without runtime overhead.\nBackwards Compatibility: Can be used with existing codebases without modification.\n\n\n\n\nLet’s look at a more comprehensive example using Protocols:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - We define multiple Protocols: Sized, Appendable, and StringContainer. - StringContainer combines multiple Protocols. - MyList is compatible with StringContainer because it implements all required methods. - process_data can work with any object that satisfies the StringContainer Protocol.\n\n\n\nWhile Protocols are primarily for static type checking, you can make them runtime-checkable:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe @runtime_checkable decorator allows isinstance() checks, but be cautious as it only checks for the existence of the methods, not their signatures.\n\n\n\nProtocols in Python provide a flexible and powerful way to define interfaces. They offer the benefits of static typing and interface definition while maintaining Python’s dynamic and duck-typed nature. Protocols are especially useful in large codebases, for defining clear contracts between different parts of a system, and for working with existing code that can’t be modified to inherit from specific base classes.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/6-Protocol.html#introduction-to-protocols",
    "href": "content/Cours_3/6-Protocol.html#introduction-to-protocols",
    "title": "Protocol Classes",
    "section": "",
    "text": "Protocols, introduced in Python 3.8, provide a way to define structural subtyping (often called “duck typing”). They allow you to define interfaces in a more flexible and Pythonic way compared to abstract base classes.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/6-Protocol.html#key-concepts",
    "href": "content/Cours_3/6-Protocol.html#key-concepts",
    "title": "Protocol Classes",
    "section": "",
    "text": "Structural Subtyping: An object is considered a subtype if it has the required methods and attributes, regardless of inheritance.\nNo Runtime Enforcement: Protocols are primarily used for static type checking and don’t enforce method implementation at runtime.\nFlexibility: Classes don’t need to explicitly inherit from a Protocol to be considered compatible.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/6-Protocol.html#basic-usage-of-protocols",
    "href": "content/Cours_3/6-Protocol.html#basic-usage-of-protocols",
    "title": "Protocol Classes",
    "section": "",
    "text": "To use Protocols, you need to import from the typing module:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - Drawable is a Protocol that defines an interface with a draw method. - Circle is compatible with Drawable because it has a draw method, even though it doesn’t explicitly inherit from Drawable.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/6-Protocol.html#advantages-of-protocols",
    "href": "content/Cours_3/6-Protocol.html#advantages-of-protocols",
    "title": "Protocol Classes",
    "section": "",
    "text": "Flexibility: You can define interfaces for existing classes without modifying them.\nDuck Typing: Aligns well with Python’s “duck typing” philosophy.\nStatic Type Checking: Provides benefits of static typing without runtime overhead.\nBackwards Compatibility: Can be used with existing codebases without modification.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/6-Protocol.html#more-complex-example",
    "href": "content/Cours_3/6-Protocol.html#more-complex-example",
    "title": "Protocol Classes",
    "section": "",
    "text": "Let’s look at a more comprehensive example using Protocols:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - We define multiple Protocols: Sized, Appendable, and StringContainer. - StringContainer combines multiple Protocols. - MyList is compatible with StringContainer because it implements all required methods. - process_data can work with any object that satisfies the StringContainer Protocol.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/6-Protocol.html#runtime-checkable-protocols",
    "href": "content/Cours_3/6-Protocol.html#runtime-checkable-protocols",
    "title": "Protocol Classes",
    "section": "",
    "text": "While Protocols are primarily for static type checking, you can make them runtime-checkable:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe @runtime_checkable decorator allows isinstance() checks, but be cautious as it only checks for the existence of the methods, not their signatures.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/6-Protocol.html#conclusion",
    "href": "content/Cours_3/6-Protocol.html#conclusion",
    "title": "Protocol Classes",
    "section": "",
    "text": "Protocols in Python provide a flexible and powerful way to define interfaces. They offer the benefits of static typing and interface definition while maintaining Python’s dynamic and duck-typed nature. Protocols are especially useful in large codebases, for defining clear contracts between different parts of a system, and for working with existing code that can’t be modified to inherit from specific base classes.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Type_Hinting.html",
    "href": "content/Cours_3/4-Type_Hinting.html",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "Type hinting, introduced in Python 3.5 (PEP 484), allows developers to indicate the expected types of variables, function parameters, and return values. While Python remains dynamically typed, type hints provide several benefits:\n\nImproved code readability\nBetter IDE support (autocomplete, error detection)\nEasier maintenance, especially for large codebases\nCatch certain types of errors before runtime\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nThe typing module provides support for type hints. It includes a collection of types and tools for working with type annotations.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nWhile Python doesn’t enforce type hints at runtime, various tools can perform static type checking:\n\n\nMypy is a static type checker for Python. It can catch many type-related errors before runtime.\nInstallation:\npip install mypy\nUsage:\nmypy your_script.py\n\n\n\nPylint is a linter that can check for coding standards, errors, and code smells. It also supports type checking.\nInstallation:\npip install pylint\nUsage:\npylint your_script.py\n\n\n\nPopular IDEs like PyCharm and VS Code have built-in support for type checking and can highlight type-related issues in real-time.\n\n\n\n\n\nStart with critical or complex functions\nUse type hints consistently throughout a module or project\nUtilize tools like Mypy to catch type-related errors\nDon’t overuse Any - it defeats the purpose of type hinting\nConsider using type hints in combination with docstrings for comprehensive documentation\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nType hinting, along with the typing module and linters, provides a powerful set of tools for improving code quality, readability, and maintainability in Python. While not enforced at runtime, these features can catch many errors early in the development process and provide better documentation and IDE support. As Python projects grow in size and complexity, incorporating type hints and static type checking becomes increasingly valuable.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Type_Hinting.html#introduction-to-type-hinting",
    "href": "content/Cours_3/4-Type_Hinting.html#introduction-to-type-hinting",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "Type hinting, introduced in Python 3.5 (PEP 484), allows developers to indicate the expected types of variables, function parameters, and return values. While Python remains dynamically typed, type hints provide several benefits:\n\nImproved code readability\nBetter IDE support (autocomplete, error detection)\nEasier maintenance, especially for large codebases\nCatch certain types of errors before runtime\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Type_Hinting.html#the-typing-module",
    "href": "content/Cours_3/4-Type_Hinting.html#the-typing-module",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "The typing module provides support for type hints. It includes a collection of types and tools for working with type annotations.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Type_Hinting.html#type-checking-and-linters",
    "href": "content/Cours_3/4-Type_Hinting.html#type-checking-and-linters",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "While Python doesn’t enforce type hints at runtime, various tools can perform static type checking:\n\n\nMypy is a static type checker for Python. It can catch many type-related errors before runtime.\nInstallation:\npip install mypy\nUsage:\nmypy your_script.py\n\n\n\nPylint is a linter that can check for coding standards, errors, and code smells. It also supports type checking.\nInstallation:\npip install pylint\nUsage:\npylint your_script.py\n\n\n\nPopular IDEs like PyCharm and VS Code have built-in support for type checking and can highlight type-related issues in real-time.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Type_Hinting.html#best-practices-for-type-hinting",
    "href": "content/Cours_3/4-Type_Hinting.html#best-practices-for-type-hinting",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "Start with critical or complex functions\nUse type hints consistently throughout a module or project\nUtilize tools like Mypy to catch type-related errors\nDon’t overuse Any - it defeats the purpose of type hinting\nConsider using type hints in combination with docstrings for comprehensive documentation",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Type_Hinting.html#example-putting-it-all-together",
    "href": "content/Cours_3/4-Type_Hinting.html#example-putting-it-all-together",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "Please enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Type_Hinting.html#conclusion",
    "href": "content/Cours_3/4-Type_Hinting.html#conclusion",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "Type hinting, along with the typing module and linters, provides a powerful set of tools for improving code quality, readability, and maintainability in Python. While not enforced at runtime, these features can catch many errors early in the development process and provide better documentation and IDE support. As Python projects grow in size and complexity, incorporating type hints and static type checking becomes increasingly valuable.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Abstract_class.html",
    "href": "content/Cours_3/5-Abstract_class.html",
    "title": "Abstract Classes",
    "section": "",
    "text": "An abstract class is a class that is designed to be inherited from, but not instantiated directly. It often contains one or more abstract methods - methods that are declared, but don’t have an implementation in the abstract class.\n\n\n\nCannot be instantiated directly\nMay contain abstract methods (methods without a body)\nMay contain concrete methods (methods with an implementation)\nSubclasses must implement all abstract methods\n\n\n\n\n\nTo define a common interface for a set of subclasses\nTo enforce certain methods to be implemented by subclasses\nTo share code among several closely related classes\n\n\n\n\n\nPython provides the abc module to work with abstract base classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - Animal is an abstract base class - make_sound is an abstract method - move is a concrete method\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nThe @abstractmethod decorator marks a method as abstract\nSubclasses must implement all abstract methods\nAbstract classes can have both abstract and concrete methods\nTrying to instantiate an abstract class directly will raise a TypeError\n\n\n\n\n\n\nEnforcing a common interface: Abstract classes ensure that all subclasses implement certain methods, guaranteeing a common interface.\nCode reuse: You can implement common functionality in the abstract base class, which all subclasses can use.\nDesigning frameworks: Abstract classes are useful when designing large frameworks where you want to provide default behaviors but require specific implementations in subclasses.\n\n\n\n\nHere’s a more practical example using shapes:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, Shape is an abstract base class that defines the common interface for all shapes. Circle and Rectangle are concrete implementations of Shape.\n\n\n\nAbstract base classes in Python provide a powerful way to define interfaces and ensure that derived classes implement certain methods. They’re useful for creating frameworks and libraries, ensuring consistency across related classes, and defining clear contracts for subclasses to follow.\nBy using abstract classes, you can create more robust and well-structured code, especially when dealing with complex hierarchies of related classes.",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Abstract_class.html#concept-and-purpose",
    "href": "content/Cours_3/5-Abstract_class.html#concept-and-purpose",
    "title": "Abstract Classes",
    "section": "",
    "text": "An abstract class is a class that is designed to be inherited from, but not instantiated directly. It often contains one or more abstract methods - methods that are declared, but don’t have an implementation in the abstract class.\n\n\n\nCannot be instantiated directly\nMay contain abstract methods (methods without a body)\nMay contain concrete methods (methods with an implementation)\nSubclasses must implement all abstract methods\n\n\n\n\n\nTo define a common interface for a set of subclasses\nTo enforce certain methods to be implemented by subclasses\nTo share code among several closely related classes",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Abstract_class.html#abstract-base-classes-abc-in-python",
    "href": "content/Cours_3/5-Abstract_class.html#abstract-base-classes-abc-in-python",
    "title": "Abstract Classes",
    "section": "",
    "text": "Python provides the abc module to work with abstract base classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - Animal is an abstract base class - make_sound is an abstract method - move is a concrete method\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nThe @abstractmethod decorator marks a method as abstract\nSubclasses must implement all abstract methods\nAbstract classes can have both abstract and concrete methods\nTrying to instantiate an abstract class directly will raise a TypeError",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Abstract_class.html#why-use-abstract-classes",
    "href": "content/Cours_3/5-Abstract_class.html#why-use-abstract-classes",
    "title": "Abstract Classes",
    "section": "",
    "text": "Enforcing a common interface: Abstract classes ensure that all subclasses implement certain methods, guaranteeing a common interface.\nCode reuse: You can implement common functionality in the abstract base class, which all subclasses can use.\nDesigning frameworks: Abstract classes are useful when designing large frameworks where you want to provide default behaviors but require specific implementations in subclasses.",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Abstract_class.html#example-shape-hierarchy",
    "href": "content/Cours_3/5-Abstract_class.html#example-shape-hierarchy",
    "title": "Abstract Classes",
    "section": "",
    "text": "Here’s a more practical example using shapes:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, Shape is an abstract base class that defines the common interface for all shapes. Circle and Rectangle are concrete implementations of Shape.",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Abstract_class.html#conclusion",
    "href": "content/Cours_3/5-Abstract_class.html#conclusion",
    "title": "Abstract Classes",
    "section": "",
    "text": "Abstract base classes in Python provide a powerful way to define interfaces and ensure that derived classes implement certain methods. They’re useful for creating frameworks and libraries, ensuring consistency across related classes, and defining clear contracts for subclasses to follow.\nBy using abstract classes, you can create more robust and well-structured code, especially when dealing with complex hierarchies of related classes.",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/TP_equity_portfolio.html",
    "href": "content/Cours_3/TP_equity_portfolio.html",
    "title": "TP",
    "section": "",
    "text": "Objective: You need to implement methods and functionalities for a Portfolio class. The class should handle the operations of initializing the portfolio with financial instrument, rebalancing its positions based on a given strategy, and providing a summary of the portfolio positions.\nTips: - Use the methods and attributes of other provided classes like Instrument, Quote, and Position. - Before starting the exercise be sure to fully understand how the object provided for it worked. - Remember to handle cases where certain attributes might be None or missing. - If you finish the exercise early, you can implement method to populate the attribute of the Portfolio class that are not handle yet.\nfrom datetime import datetime\nimport pandas as pd\nimport math\n\nclass Quote:\n    def __init__(self, date: datetime, price: float):\n        self.date = date\n        self.price = price\n\n    def __str__(self):\n        return f'(date: {self.date}, price: {self.price})'\n\n\nclass Instrument:\n    def __init__(self, ticker: str, exchange: str, quote: Quote, currency: str):\n        self.ticker: str = ticker\n        self.exchange: str = exchange\n        self.last_quote: Quote = quote\n        self.currency: str = currency\n        self.quote_history: [Quote] = []\n\n    def __str__(self):\n        print(f'Instrument with ticker {self.ticker}, currency {self.currency} and last quote {self.last_quote}')\n\n    def update_price(self, new_quote: Quote):\n        self.quote_history.append(self.last_quote)\n        self.last_quote = new_quote\n\n    def populate_quote_history_from_df(self, df_data: pd.DataFrame):\n        dates = df_data.index.to_pydatetime().tolist()\n        prices = df_data['Close'].tolist()\n        self.quote_history = [Quote(date, price) for date, price in zip(dates, prices)]\n\n    def quotes_to_dataframe(self) -&gt; pd.DataFrame:\n        data = {\n            \"Date\": [quote.date for quote in self.quote_history],\n            \"Price\": [quote.price for quote in self.quote_history]\n        }\n        df = pd.DataFrame(data)\n        df.set_index('Date', inplace=True)\n        return df\n\n\nclass Position:\n    def __init__(self, instrument: Instrument, date: datetime = datetime.now(), weight: float = 0, quantity: float = 0):\n        self.instrument = instrument\n        self.date = date\n        self.weight = weight\n        self.quantity = quantity\n\n    def update(self, date: datetime, weight: float, quantity: float):\n        if date is not None:\n            self.date = date\n        if weight is not None:\n            self.weight = weight\n        if quantity is not None:\n            self.quantity = quantity\n\nPART I: Creating the meta class strategy and one specific strategy\nCreate an abstract class Strategy that will serve as the base for all strategies. This class should: - Include an abstract method generate_signals that will generate trading signals based on input data. - Document the method generate_signals with a docstring explaining the parameters and return value: - Parameters for the class : A dictionary with tickers as keys and positions as values. The dict should be named data_for_signal_generation - Return: A dictionary with tickers as keys and signals as values.\nCreate a derived class EqualWeightStrategy from Strategy: - This class should inherit from Strategy and implement the generate_signals method. - It should calculate and return a dictionary with equal-weight signals for each ticker. - To Implement the generate_signals method: - The method should calculate equal-weight signals for each ticker by dividing 1 by the total number of tickers. - It should return a dictionary where each ticker has an equal weight as its signal.\n    from datetime import datetime\n    import pandas as pd\n    import math\n    from abc import ABC, abstractmethod\n\n    # Implement here the Part I\n\nPart II : Creating the Portfolio class 1. Class Attributes: Based on the provided code framework, create a Portfolio class which should have the following attributes: - name: Name of the portfolio. - currency: The currency in which the portfolio is denominated. - aum: Assets Under Management. - ‘nav’ : The last net asset value computed for the portfolio - historical_nav: A list that keeps track of the historical Net Asset Values. - positions: A list of Position objects representing the portfolio’s assets. - strategy: A strategy object, an instance of a class derived from the Strategy class.\n\nInitialization: Implement the __init__ method to initialize the portfolio attributes.\nInitialize Portfolio Positions: Implement a initialize_position_from_instrument_list method to initialize the portfolio’s positions with a given list of FinancialAsset objects. Each financial asset should be wrapped in a Position object.\nPositions to Dictionary: Implement the _positions_to_dict method which returns a dictionary of positions with ticker symbols as keys and Position objects as values. This will help in rebalancing operations.\nRebalancing: Implement the rebalance_portfolio method which performs the following tasks:\n\nConvert the positions list into a dictionary.\nGenerate trading signals using the provided strategy.\nUpdate the weight and quantity of each position in the portfolio based on the generated signals.\n\nPortfolio Summary: Implement the portfolio_position_summary method. This method should return a dataframe summarizing the portfolio’s current positions, including the ticker symbols, weights, quantities, and last close for the assets\n\n    # Implement here the Part II\n\nAfter implementing the Part I and Part II, you can launch this unit test to validate your code.\n    class TestPortfolio(unittest.TestCase):\n\n    def setUp(self):\n        # Setup the instruments and quotes\n        self.last_date_asset_1 = datetime(2024, 8, 29)\n        self.last_close_asset_1 = 230.02\n        self.equity_last_quote_asset_1 = Quote(self.last_date_asset_1, self.last_close_asset_1)\n        self.equity_1 = Instrument('AAPL', 'NASDAQ', self.equity_last_quote_asset_1, 'USD')\n\n        self.last_date_asset_2 = datetime(2024, 8, 29)\n        self.last_close_asset_2 = 414.75\n        self.equity_last_quote_asset_2 = Quote(self.last_date_asset_2, self.last_close_asset_2)\n        self.equity_2 = Instrument('MSFT', 'NASDAQ', self.equity_last_quote_asset_2, 'USD')\n\n        # Update prices\n        self.last_date_asset_1 = datetime(2024, 8, 30)\n        self.last_close_asset_1 = 229.0\n        self.equity_1.update_price(Quote(self.last_date_asset_1, self.last_close_asset_1))\n\n        self.last_date_asset_2 = datetime(2024, 8, 30)\n        self.last_close_asset_2 = 417.14\n        self.equity_2.update_price(Quote(self.last_date_asset_2, self.last_close_asset_2))\n\n        # Setup the portfolio strategy and portfolio\n        self.pft_strategy = EqualWeightStrategy()\n        self.portfolio = Portfolio(\"Tech Portfolio\", \"USD\", 1000000, 10000, 100, self.pft_strategy)\n        self.portfolio.initialize_position_from_instrument_list([self.equity_1, self.equity_2])\n\n    def test_initial_portfolio_summary(self):\n        # Test the initial summary of the portfolio\n        summary = self.portfolio.portfolio_position_summary()\n        expected_data = {\n            \"Ticker\": ['AAPL', 'MSFT'],\n            \"Weight\": [0, 0],\n            \"Quantity\": [0, 0],\n            \"Last close\": [229.0, 417.14]\n        }\n        expected_df = pd.DataFrame(expected_data)\n        pd.testing.assert_frame_equal(summary, expected_df)\n\n    def test_rebalance_portfolio(self):\n        # Rebalance the portfolio and check the summary\n        self.portfolio.rebalance_portfolio()\n        summary = self.portfolio.portfolio_position_summary()\n\n        # Calculate expected values\n        total_aum = self.portfolio.aum\n        expected_weight = 0.5\n        expected_quantity_1 = math.floor((total_aum * expected_weight) / self.equity_1.last_quote.price)\n        expected_quantity_2 = math.floor((total_aum * expected_weight) / self.equity_2.last_quote.price)\n\n        expected_data = {\n            \"Ticker\": ['AAPL', 'MSFT'],\n            \"Weight\": [expected_weight, expected_weight],\n            \"Quantity\": [expected_quantity_1, expected_quantity_2],\n            \"Last close\": [229.0, 417.14]\n        }\n        expected_df = pd.DataFrame(expected_data)\n\n        pd.testing.assert_frame_equal(summary, expected_df)\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "crumbs": [
      "Travaux Pratiques",
      "TP"
    ]
  },
  {
    "objectID": "content/Cours_3/TP_equity_portfolio.html#tp-instructions-implementing-a-strategy-and-a-portfolio-for-a-backtesting-task",
    "href": "content/Cours_3/TP_equity_portfolio.html#tp-instructions-implementing-a-strategy-and-a-portfolio-for-a-backtesting-task",
    "title": "TP",
    "section": "",
    "text": "Objective: You need to implement methods and functionalities for a Portfolio class. The class should handle the operations of initializing the portfolio with financial instrument, rebalancing its positions based on a given strategy, and providing a summary of the portfolio positions.\nTips: - Use the methods and attributes of other provided classes like Instrument, Quote, and Position. - Before starting the exercise be sure to fully understand how the object provided for it worked. - Remember to handle cases where certain attributes might be None or missing. - If you finish the exercise early, you can implement method to populate the attribute of the Portfolio class that are not handle yet.\nfrom datetime import datetime\nimport pandas as pd\nimport math\n\nclass Quote:\n    def __init__(self, date: datetime, price: float):\n        self.date = date\n        self.price = price\n\n    def __str__(self):\n        return f'(date: {self.date}, price: {self.price})'\n\n\nclass Instrument:\n    def __init__(self, ticker: str, exchange: str, quote: Quote, currency: str):\n        self.ticker: str = ticker\n        self.exchange: str = exchange\n        self.last_quote: Quote = quote\n        self.currency: str = currency\n        self.quote_history: [Quote] = []\n\n    def __str__(self):\n        print(f'Instrument with ticker {self.ticker}, currency {self.currency} and last quote {self.last_quote}')\n\n    def update_price(self, new_quote: Quote):\n        self.quote_history.append(self.last_quote)\n        self.last_quote = new_quote\n\n    def populate_quote_history_from_df(self, df_data: pd.DataFrame):\n        dates = df_data.index.to_pydatetime().tolist()\n        prices = df_data['Close'].tolist()\n        self.quote_history = [Quote(date, price) for date, price in zip(dates, prices)]\n\n    def quotes_to_dataframe(self) -&gt; pd.DataFrame:\n        data = {\n            \"Date\": [quote.date for quote in self.quote_history],\n            \"Price\": [quote.price for quote in self.quote_history]\n        }\n        df = pd.DataFrame(data)\n        df.set_index('Date', inplace=True)\n        return df\n\n\nclass Position:\n    def __init__(self, instrument: Instrument, date: datetime = datetime.now(), weight: float = 0, quantity: float = 0):\n        self.instrument = instrument\n        self.date = date\n        self.weight = weight\n        self.quantity = quantity\n\n    def update(self, date: datetime, weight: float, quantity: float):\n        if date is not None:\n            self.date = date\n        if weight is not None:\n            self.weight = weight\n        if quantity is not None:\n            self.quantity = quantity\n\nPART I: Creating the meta class strategy and one specific strategy\nCreate an abstract class Strategy that will serve as the base for all strategies. This class should: - Include an abstract method generate_signals that will generate trading signals based on input data. - Document the method generate_signals with a docstring explaining the parameters and return value: - Parameters for the class : A dictionary with tickers as keys and positions as values. The dict should be named data_for_signal_generation - Return: A dictionary with tickers as keys and signals as values.\nCreate a derived class EqualWeightStrategy from Strategy: - This class should inherit from Strategy and implement the generate_signals method. - It should calculate and return a dictionary with equal-weight signals for each ticker. - To Implement the generate_signals method: - The method should calculate equal-weight signals for each ticker by dividing 1 by the total number of tickers. - It should return a dictionary where each ticker has an equal weight as its signal.\n    from datetime import datetime\n    import pandas as pd\n    import math\n    from abc import ABC, abstractmethod\n\n    # Implement here the Part I\n\nPart II : Creating the Portfolio class 1. Class Attributes: Based on the provided code framework, create a Portfolio class which should have the following attributes: - name: Name of the portfolio. - currency: The currency in which the portfolio is denominated. - aum: Assets Under Management. - ‘nav’ : The last net asset value computed for the portfolio - historical_nav: A list that keeps track of the historical Net Asset Values. - positions: A list of Position objects representing the portfolio’s assets. - strategy: A strategy object, an instance of a class derived from the Strategy class.\n\nInitialization: Implement the __init__ method to initialize the portfolio attributes.\nInitialize Portfolio Positions: Implement a initialize_position_from_instrument_list method to initialize the portfolio’s positions with a given list of FinancialAsset objects. Each financial asset should be wrapped in a Position object.\nPositions to Dictionary: Implement the _positions_to_dict method which returns a dictionary of positions with ticker symbols as keys and Position objects as values. This will help in rebalancing operations.\nRebalancing: Implement the rebalance_portfolio method which performs the following tasks:\n\nConvert the positions list into a dictionary.\nGenerate trading signals using the provided strategy.\nUpdate the weight and quantity of each position in the portfolio based on the generated signals.\n\nPortfolio Summary: Implement the portfolio_position_summary method. This method should return a dataframe summarizing the portfolio’s current positions, including the ticker symbols, weights, quantities, and last close for the assets\n\n    # Implement here the Part II\n\nAfter implementing the Part I and Part II, you can launch this unit test to validate your code.\n    class TestPortfolio(unittest.TestCase):\n\n    def setUp(self):\n        # Setup the instruments and quotes\n        self.last_date_asset_1 = datetime(2024, 8, 29)\n        self.last_close_asset_1 = 230.02\n        self.equity_last_quote_asset_1 = Quote(self.last_date_asset_1, self.last_close_asset_1)\n        self.equity_1 = Instrument('AAPL', 'NASDAQ', self.equity_last_quote_asset_1, 'USD')\n\n        self.last_date_asset_2 = datetime(2024, 8, 29)\n        self.last_close_asset_2 = 414.75\n        self.equity_last_quote_asset_2 = Quote(self.last_date_asset_2, self.last_close_asset_2)\n        self.equity_2 = Instrument('MSFT', 'NASDAQ', self.equity_last_quote_asset_2, 'USD')\n\n        # Update prices\n        self.last_date_asset_1 = datetime(2024, 8, 30)\n        self.last_close_asset_1 = 229.0\n        self.equity_1.update_price(Quote(self.last_date_asset_1, self.last_close_asset_1))\n\n        self.last_date_asset_2 = datetime(2024, 8, 30)\n        self.last_close_asset_2 = 417.14\n        self.equity_2.update_price(Quote(self.last_date_asset_2, self.last_close_asset_2))\n\n        # Setup the portfolio strategy and portfolio\n        self.pft_strategy = EqualWeightStrategy()\n        self.portfolio = Portfolio(\"Tech Portfolio\", \"USD\", 1000000, 10000, 100, self.pft_strategy)\n        self.portfolio.initialize_position_from_instrument_list([self.equity_1, self.equity_2])\n\n    def test_initial_portfolio_summary(self):\n        # Test the initial summary of the portfolio\n        summary = self.portfolio.portfolio_position_summary()\n        expected_data = {\n            \"Ticker\": ['AAPL', 'MSFT'],\n            \"Weight\": [0, 0],\n            \"Quantity\": [0, 0],\n            \"Last close\": [229.0, 417.14]\n        }\n        expected_df = pd.DataFrame(expected_data)\n        pd.testing.assert_frame_equal(summary, expected_df)\n\n    def test_rebalance_portfolio(self):\n        # Rebalance the portfolio and check the summary\n        self.portfolio.rebalance_portfolio()\n        summary = self.portfolio.portfolio_position_summary()\n\n        # Calculate expected values\n        total_aum = self.portfolio.aum\n        expected_weight = 0.5\n        expected_quantity_1 = math.floor((total_aum * expected_weight) / self.equity_1.last_quote.price)\n        expected_quantity_2 = math.floor((total_aum * expected_weight) / self.equity_2.last_quote.price)\n\n        expected_data = {\n            \"Ticker\": ['AAPL', 'MSFT'],\n            \"Weight\": [expected_weight, expected_weight],\n            \"Quantity\": [expected_quantity_1, expected_quantity_2],\n            \"Last close\": [229.0, 417.14]\n        }\n        expected_df = pd.DataFrame(expected_data)\n\n        pd.testing.assert_frame_equal(summary, expected_df)\n\n\nif __name__ == '__main__':\n    unittest.main()",
    "crumbs": [
      "Travaux Pratiques",
      "TP"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html",
    "href": "content/Cours_1/3-NaissancePOO.html",
    "title": "Naissance de la POO",
    "section": "",
    "text": "Après l’émergence des concepts de la POO avec Simula et Smalltalk, de nombreux langages de programmation ont adopté et adapté ces principes. Nous allons nous concentrer sur deux langages majeurs : C++ et Python.\n\n\n\nC++, développé par Bjarne Stroustrup dans les années 1980, a été conçu comme une extension du langage C intégrant les concepts de la POO.\n\n\n\nCompatibilité avec C : Permet une transition en douceur pour les programmeurs C\nSupport de la POO : Classes, héritage, polymorphisme\nGénéricité : Templates pour une programmation générique\nGestion manuelle de la mémoire : Offre un contrôle précis mais exige plus de responsabilité du programmeur\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Vehicule {\nprotected:\n    std::string marque;\n    std::string modele;\n\npublic:\n    Vehicule(std::string m, std::string mod) : marque(m), modele(mod) {}\n    \n    virtual void afficher() const {\n        std::cout &lt;&lt; \"Vehicule: \" &lt;&lt; marque &lt;&lt; \" \" &lt;&lt; modele &lt;&lt; std::endl;\n    }\n};\n\nclass Voiture : public Vehicule {\nprivate:\n    int nombrePortes;\n\npublic:\n    Voiture(std::string m, std::string mod, int portes) \n        : Vehicule(m, mod), nombrePortes(portes) {}\n    \n    void afficher() const override {\n        std::cout &lt;&lt; \"Voiture: \" &lt;&lt; marque &lt;&lt; \" \" &lt;&lt; modele \n                  &lt;&lt; \" (\" &lt;&lt; nombrePortes &lt;&lt; \" portes)\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Vehicule* v1 = new Vehicule(\"Générique\", \"Modèle X\");\n    Vehicule* v2 = new Voiture(\"Renault\", \"Clio\", 5);\n    \n    v1-&gt;afficher();  // Affiche: Vehicule: Générique Modèle X\n    v2-&gt;afficher();  // Affiche: Voiture: Renault Clio (5 portes)\n    \n    delete v1;\n    delete v2;\n    return 0;\n}\n\n\n\n\nHéritage multiple : Permet à une classe d’hériter de plusieurs classes\nPolymorphisme par pointeurs et références : Utilisation de pointeurs pour le polymorphisme\nSurcharge d’opérateurs : Permet de définir le comportement des opérateurs pour les classes personnalisées\n\n\n\n\n\nPython, créé par Guido van Rossum à la fin des années 1980, a adopté la POO d’une manière plus souple et accessible.\n\n\n\nSyntaxe simple et lisible : Facilite l’apprentissage et la lecture du code\nTypage dynamique : Les types sont déterminés à l’exécution\n“Tout est objet” : Même les fonctions sont des objets de première classe\nGestion automatique de la mémoire : Garbage collection intégré\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDuck Typing : “Si ça marche comme un canard et ça caquète comme un canard, alors c’est un canard”\nMéthodes spéciales : Permettent de définir le comportement des objets (ex: __str__, __len__)\nPropriétés : Permettent de contrôler l’accès aux attributs de manière élégante\nHéritage multiple : Supporté, mais avec une résolution de méthode (MRO) spécifique\n\n\n\n\n\n\n\n\nC++ : Syntaxe plus verbeuse, types explicites\nPython : Syntaxe concise, types inférés\n\n\n\n\n\nC++ : Généralement plus rapide, contrôle précis de la mémoire\nPython : Plus lent, mais développement plus rapide\n\n\n\n\n\nC++ : Manuelle (new/delete), risque de fuites mémoire\nPython : Automatique (garbage collection)\n\n\n\n\n\nC++ : Statiquement typé, compilation nécessaire\nPython : Dynamiquement typé, interprété\n\n\n\n\n\nL’adoption de la POO dans ces langages modernes a eu plusieurs effets :\n\nStandardisation des pratiques : Concepts POO communs entre les langages\nAmélioration de la réutilisabilité : Bibliothèques et frameworks basés sur la POO\nFacilitation du développement à grande échelle : Meilleure organisation du code pour les grands projets\nAdaptation à différents domaines : Du développement système (C++) au scripting et à l’analyse de données (Python)\n\n\n\n\nL’intégration de la POO dans des langages comme C++ et Python a démocratisé son utilisation et a fourni aux développeurs des outils puissants pour créer des logiciels complexes et maintenables. Chaque langage a adapté les principes de la POO à sa philosophie, offrant ainsi une diversité d’approches pour résoudre les problèmes de programmation.",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#introduction",
    "href": "content/Cours_1/3-NaissancePOO.html#introduction",
    "title": "Naissance de la POO",
    "section": "",
    "text": "Après l’émergence des concepts de la POO avec Simula et Smalltalk, de nombreux langages de programmation ont adopté et adapté ces principes. Nous allons nous concentrer sur deux langages majeurs : C++ et Python.",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#c-lévolution-du-c-vers-la-poo",
    "href": "content/Cours_1/3-NaissancePOO.html#c-lévolution-du-c-vers-la-poo",
    "title": "Naissance de la POO",
    "section": "",
    "text": "C++, développé par Bjarne Stroustrup dans les années 1980, a été conçu comme une extension du langage C intégrant les concepts de la POO.\n\n\n\nCompatibilité avec C : Permet une transition en douceur pour les programmeurs C\nSupport de la POO : Classes, héritage, polymorphisme\nGénéricité : Templates pour une programmation générique\nGestion manuelle de la mémoire : Offre un contrôle précis mais exige plus de responsabilité du programmeur\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Vehicule {\nprotected:\n    std::string marque;\n    std::string modele;\n\npublic:\n    Vehicule(std::string m, std::string mod) : marque(m), modele(mod) {}\n    \n    virtual void afficher() const {\n        std::cout &lt;&lt; \"Vehicule: \" &lt;&lt; marque &lt;&lt; \" \" &lt;&lt; modele &lt;&lt; std::endl;\n    }\n};\n\nclass Voiture : public Vehicule {\nprivate:\n    int nombrePortes;\n\npublic:\n    Voiture(std::string m, std::string mod, int portes) \n        : Vehicule(m, mod), nombrePortes(portes) {}\n    \n    void afficher() const override {\n        std::cout &lt;&lt; \"Voiture: \" &lt;&lt; marque &lt;&lt; \" \" &lt;&lt; modele \n                  &lt;&lt; \" (\" &lt;&lt; nombrePortes &lt;&lt; \" portes)\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Vehicule* v1 = new Vehicule(\"Générique\", \"Modèle X\");\n    Vehicule* v2 = new Voiture(\"Renault\", \"Clio\", 5);\n    \n    v1-&gt;afficher();  // Affiche: Vehicule: Générique Modèle X\n    v2-&gt;afficher();  // Affiche: Voiture: Renault Clio (5 portes)\n    \n    delete v1;\n    delete v2;\n    return 0;\n}\n\n\n\n\nHéritage multiple : Permet à une classe d’hériter de plusieurs classes\nPolymorphisme par pointeurs et références : Utilisation de pointeurs pour le polymorphisme\nSurcharge d’opérateurs : Permet de définir le comportement des opérateurs pour les classes personnalisées",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#python-la-poo-simplifiée-et-dynamique",
    "href": "content/Cours_1/3-NaissancePOO.html#python-la-poo-simplifiée-et-dynamique",
    "title": "Naissance de la POO",
    "section": "",
    "text": "Python, créé par Guido van Rossum à la fin des années 1980, a adopté la POO d’une manière plus souple et accessible.\n\n\n\nSyntaxe simple et lisible : Facilite l’apprentissage et la lecture du code\nTypage dynamique : Les types sont déterminés à l’exécution\n“Tout est objet” : Même les fonctions sont des objets de première classe\nGestion automatique de la mémoire : Garbage collection intégré\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDuck Typing : “Si ça marche comme un canard et ça caquète comme un canard, alors c’est un canard”\nMéthodes spéciales : Permettent de définir le comportement des objets (ex: __str__, __len__)\nPropriétés : Permettent de contrôler l’accès aux attributs de manière élégante\nHéritage multiple : Supporté, mais avec une résolution de méthode (MRO) spécifique",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#comparaison-c-vs-python-en-poo",
    "href": "content/Cours_1/3-NaissancePOO.html#comparaison-c-vs-python-en-poo",
    "title": "Naissance de la POO",
    "section": "",
    "text": "C++ : Syntaxe plus verbeuse, types explicites\nPython : Syntaxe concise, types inférés\n\n\n\n\n\nC++ : Généralement plus rapide, contrôle précis de la mémoire\nPython : Plus lent, mais développement plus rapide\n\n\n\n\n\nC++ : Manuelle (new/delete), risque de fuites mémoire\nPython : Automatique (garbage collection)\n\n\n\n\n\nC++ : Statiquement typé, compilation nécessaire\nPython : Dynamiquement typé, interprété",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#impact-sur-le-développement-logiciel",
    "href": "content/Cours_1/3-NaissancePOO.html#impact-sur-le-développement-logiciel",
    "title": "Naissance de la POO",
    "section": "",
    "text": "L’adoption de la POO dans ces langages modernes a eu plusieurs effets :\n\nStandardisation des pratiques : Concepts POO communs entre les langages\nAmélioration de la réutilisabilité : Bibliothèques et frameworks basés sur la POO\nFacilitation du développement à grande échelle : Meilleure organisation du code pour les grands projets\nAdaptation à différents domaines : Du développement système (C++) au scripting et à l’analyse de données (Python)",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#conclusion",
    "href": "content/Cours_1/3-NaissancePOO.html#conclusion",
    "title": "Naissance de la POO",
    "section": "",
    "text": "L’intégration de la POO dans des langages comme C++ et Python a démocratisé son utilisation et a fourni aux développeurs des outils puissants pour créer des logiciels complexes et maintenables. Chaque langage a adapté les principes de la POO à sa philosophie, offrant ainsi une diversité d’approches pour résoudre les problèmes de programmation.",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "Une classe en Python est un plan ou un modèle pour créer des objets. Elle définit les caractéristiques (attributs) et les comportements (méthodes) que les objets de cette classe auront.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nUne instance est un objet spécifique créé à partir d’une classe.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLa classe est le modèle général (comme un plan d’architecte).\nL’instance est un objet spécifique créé à partir de ce modèle (comme une maison construite selon le plan).\n\nExemple :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, Voiture est la classe, tandis que voiture1 et voiture2 sont des instances de cette classe.\n\n\n\nself est une convention en Python pour référencer l’instance actuelle de la classe. C’est le premier paramètre de toutes les méthodes d’instance.\n\n\n\nself permet à la méthode de savoir sur quelle instance spécifique elle travaille.\nIl est automatiquement passé par Python lors de l’appel d’une méthode sur une instance.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple : - self.marque = marque stocke la marque pour cette instance spécifique. - Dans description(), self.marque fait référence à la marque de l’instance sur laquelle la méthode est appelée.\n\n\n\n\n__init__ est une méthode spéciale en Python, appelée constructeur. Elle est automatiquement appelée lors de la création d’une nouvelle instance.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nIls sont partagés par toutes les instances de la classe, mais peuvent être modifiés au niveau de l’instance.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, ma_voiture.accident() modifie l’attribut nombre_de_roues pour cette instance spécifique, sans affecter la classe ou les autres instances.\n\n\n\n[Cette section reste inchangée]\n\n\n\n\nself est une référence à l’instance courante de la classe. C’est le premier paramètre de toute méthode d’instance en Python.\n\n\nLorsqu’une méthode est appelée sur une instance, Python passe automatiquement cette instance comme premier argument à la méthode.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nBien que ‘self’ soit une convention, on peut techniquement utiliser n’importe quel nom :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCependant, utiliser ‘self’ est fortement recommandé pour la lisibilité et le respect des conventions.\n\n\n\n\nPEP 8 est le guide de style pour le code Python. Il fournit des conventions pour écrire du code Python lisible et cohérent.\n\n\n\nNoms de classe : Utilisez la convention CapWords (aussi appelée PascalCase).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNoms de méthodes et d’attributs : Utilisez des minuscules avec des underscores pour séparer les mots.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nConstantes : Utilisez des majuscules avec des underscores.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nEspaces : Pas d’espaces autour des parenthèses ou des crochets, mais un espace après les virgules.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIndentation : Utilisez 4 espaces par niveau d’indentation.\n\n\n\n\nSuivre PEP 8 rend votre code : - Plus lisible pour les autres développeurs - Plus cohérent avec la majorité du code Python - Plus facile à maintenir sur le long terme\n\n\n\n\nComprendre les concepts fondamentaux des classes en Python, comme les attributs de classe vs d’instance, le rôle de ‘self’, et les conventions de codage, est crucial pour écrire du code orienté objet efficace et lisible. Ces bases permettent de construire des programmes bien structurés et faciles à maintenir.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#quest-ce-quune-classe",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#quest-ce-quune-classe",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "Une classe en Python est un plan ou un modèle pour créer des objets. Elle définit les caractéristiques (attributs) et les comportements (méthodes) que les objets de cette classe auront.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#création-dune-instance",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#création-dune-instance",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "Une instance est un objet spécifique créé à partir d’une classe.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-la-différence-entre-classe-et-instance",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-la-différence-entre-classe-et-instance",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "La classe est le modèle général (comme un plan d’architecte).\nL’instance est un objet spécifique créé à partir de ce modèle (comme une maison construite selon le plan).\n\nExemple :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, Voiture est la classe, tandis que voiture1 et voiture2 sont des instances de cette classe.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-self",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-self",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "self est une convention en Python pour référencer l’instance actuelle de la classe. C’est le premier paramètre de toutes les méthodes d’instance.\n\n\n\nself permet à la méthode de savoir sur quelle instance spécifique elle travaille.\nIl est automatiquement passé par Python lors de l’appel d’une méthode sur une instance.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple : - self.marque = marque stocke la marque pour cette instance spécifique. - Dans description(), self.marque fait référence à la marque de l’instance sur laquelle la méthode est appelée.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#méthode-init",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#méthode-init",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "__init__ est une méthode spéciale en Python, appelée constructeur. Elle est automatiquement appelée lors de la création d’une nouvelle instance.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#attributs-de-classe-vs-attributs-dinstance-version-étendue",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#attributs-de-classe-vs-attributs-dinstance-version-étendue",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "Ils sont partagés par toutes les instances de la classe, mais peuvent être modifiés au niveau de l’instance.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, ma_voiture.accident() modifie l’attribut nombre_de_roues pour cette instance spécifique, sans affecter la classe ou les autres instances.\n\n\n\n[Cette section reste inchangée]",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-self-en-profondeur",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-self-en-profondeur",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "self est une référence à l’instance courante de la classe. C’est le premier paramètre de toute méthode d’instance en Python.\n\n\nLorsqu’une méthode est appelée sur une instance, Python passe automatiquement cette instance comme premier argument à la méthode.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nBien que ‘self’ soit une convention, on peut techniquement utiliser n’importe quel nom :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCependant, utiliser ‘self’ est fortement recommandé pour la lisibilité et le respect des conventions.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#introduction-aux-conventions-de-codage-pep-8",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#introduction-aux-conventions-de-codage-pep-8",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "PEP 8 est le guide de style pour le code Python. Il fournit des conventions pour écrire du code Python lisible et cohérent.\n\n\n\nNoms de classe : Utilisez la convention CapWords (aussi appelée PascalCase).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNoms de méthodes et d’attributs : Utilisez des minuscules avec des underscores pour séparer les mots.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nConstantes : Utilisez des majuscules avec des underscores.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nEspaces : Pas d’espaces autour des parenthèses ou des crochets, mais un espace après les virgules.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIndentation : Utilisez 4 espaces par niveau d’indentation.\n\n\n\n\nSuivre PEP 8 rend votre code : - Plus lisible pour les autres développeurs - Plus cohérent avec la majorité du code Python - Plus facile à maintenir sur le long terme",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#conclusion",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#conclusion",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "Comprendre les concepts fondamentaux des classes en Python, comme les attributs de classe vs d’instance, le rôle de ‘self’, et les conventions de codage, est crucial pour écrire du code orienté objet efficace et lisible. Ces bases permettent de construire des programmes bien structurés et faciles à maintenir.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/TP.html",
    "href": "content/Cours_1/TP.html",
    "title": "Construire son propre DataFrame",
    "section": "",
    "text": "Instructions\nVotre tâche est de créer une classe DataFrameSimple qui simule les fonctionnalités de base d’un dataframe. Suivez ces instructions :\n\nCréez un fichier nommé dataframe_simple.py.\nDans ce fichier, implémentez la classe DataFrameSimple avec les méthodes suivantes :\n\n__init__(self, data) : Le constructeur qui accepte un dictionnaire de données.\nafficher(self) : Retourne une chaîne représentant les premières lignes du dataframe.\nmoyenne(self, nom_colonne) : Calcule la moyenne d’une colonne.\nsomme(self, nom_colonne) : Calcule la somme d’une colonne.\nmin(self, nom_colonne) : Trouve le minimum d’une colonne.\nmax(self, nom_colonne) : Trouve le maximum d’une colonne.\nselect_colonne(self, nom_colonne) : Retourne les valeurs d’une colonne.\n\nVotre classe doit avoir les attributs suivants :\n\ndonnees : Un numpy array contenant les données.\ncolonnes : Une liste des noms de colonnes.\n\nUtilisez numpy pour les calculs statistiques (np.mean(), np.sum(), etc.).\nUne fois votre implémentation terminée, exécutez les tests unitaires en lançant python test_dataframe_simple.py.\nAssurez-vous que tous les tests passent. Si ce n’est pas le cas, revoyez votre implémentation.\n\nConseils : - Commencez par implémenter le constructeur et la méthode afficher(). - Utilisez les fonctions numpy pour les calculs statistiques. - N’oubliez pas d’importer numpy dans votre fichier dataframe_simple.py.\n\n\nTests Unitaires pour verifier votre implémentation\nVoici un ensemble de tests unitaires simplifiés pour votre classe DataFrameSimple. Copier votre classe avec ce code pour la tester :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html",
    "href": "content/Cours_1/2-Structuration_des_donnees.html",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Au début de la programmation, les données étaient stockées de manière simple, souvent sous forme de variables individuelles. Avec la complexification des problèmes, le besoin de regrouper et d’organiser les données est devenu évident.\nExemple simple en C++ :\nstring nom = \"Dubois\";\nstring prenom = \"Marie\";\nint age = 20;\nfloat moyenne = 15.5;\nCette approche devient vite difficile à gérer pour de nombreux étudiants ou plus d’informations.\n\n\n\n\n\nUn tableau est une collection d’éléments de même type, accessibles par un index.\n\n\n\nint notes[5] = {12, 15, 18, 10, 14};\ncout &lt;&lt; \"La troisième note est : \" &lt;&lt; notes[2] &lt;&lt; endl;  // Affiche 18\n\n\n\n\nStockage efficace de multiples éléments de même type\nAccès rapide aux éléments par leur position\nTous les éléments doivent être du même type\nTaille souvent fixe à la compilation en C++\n\n\n\n\n\nLes structures permettent de regrouper des données de types différents qui sont logiquement liées.\n\n\nstruct Etudiant {\n    string nom;\n    string prenom;\n    int age;\n    float moyenne;\n};\n\nEtudiant marie = {\"Dubois\", \"Marie\", 20, 15.5};\ncout &lt;&lt; marie.prenom &lt;&lt; \" \" &lt;&lt; marie.nom &lt;&lt; \" a \" &lt;&lt; marie.age &lt;&lt; \" ans\" &lt;&lt; endl;\n\n\n\n\nReprésentation d’entités complexes de manière plus naturelle\nRegroupement logique des données liées\nAmélioration de la lisibilité et de l’organisation du code\n\n\n\n\n\nPascal a introduit le concept de “record”, similaire aux structures en C++, mais avec quelques différences syntaxiques et conceptuelles.\n\n\ntype\n  Etudiant = record\n    nom: string[50];\n    prenom: string[50];\n    age: integer;\n    moyenne: real;\n  end;\n\nvar\n  marie: Etudiant;\n\nbegin\n  marie.nom := 'Dubois';\n  marie.prenom := 'Marie';\n  marie.age := 20;\n  marie.moyenne := 15.5;\n  \n  writeln(marie.prenom, ' ', marie.nom, ' a ', marie.age, ' ans');\nend.\n\n\n\n\nTypage fort : Pascal est connu pour son système de typage strict\nDéclaration explicite des types : Améliore la clarté et la sécurité du code\nUtilisé dans un langage conçu pour l’enseignement : Syntax claire et lisible\n\n\n\n\n\nModula-2, successeur de Pascal, a introduit le concept de modules, une étape importante vers l’encapsulation.\n\n\nUn module en Modula-2 est une unité de programme qui regroupe des définitions de types, des variables et des procédures liées.\n\n\n\nMODULE GestionEtudiants;\n\nEXPORT Etudiant, CreerEtudiant, AfficherEtudiant;\n\nTYPE\n  Etudiant = RECORD\n    nom: ARRAY[0..49] OF CHAR;\n    prenom: ARRAY[0..49] OF CHAR;\n    age: INTEGER;\n    moyenne: REAL;\n  END;\n\nPROCEDURE CreerEtudiant(VAR e: Etudiant; n, p: ARRAY OF CHAR; a: INTEGER; m: REAL);\nBEGIN\n  (* Code pour initialiser un étudiant *)\nEND CreerEtudiant;\n\nPROCEDURE AfficherEtudiant(e: Etudiant);\nBEGIN\n  (* Code pour afficher les informations d'un étudiant *)\nEND AfficherEtudiant;\n\nEND GestionEtudiants.\n\n\n\n\nEncapsulation : Regroupement des données et des opérations liées\nSéparation interface/implémentation : Distinction entre ce qui est public et privé\nRéutilisabilité : Facilite la réutilisation du code dans différents programmes\n\n\n\n\n\nCes évolutions dans la structuration des données ont eu plusieurs effets positifs :\n\nModélisation plus fidèle du monde réel\nAmélioration de la lisibilité et de la maintenabilité du code\nIntroduction de l’abstraction des données\nPrémices de l’encapsulation (particulièrement avec les modules)\n\n\n\n\nMalgré ces avancées, certaines limitations persistaient : - Manque de mécanismes pour l’extension et la spécialisation des structures - Absence de polymorphisme\nCes limitations ont ouvert la voie à la programmation orientée objet, qui intégrera ces concepts de manière plus complète et flexible.\n\n\n\nLa structuration des données, à travers les tableaux, les structures, les records et les modules, a posé les bases conceptuelles nécessaires à l’émergence de la programmation orientée objet. Cette évolution a permis de mieux organiser et représenter l’information, préparant le terrain pour des paradigmes plus avancés.",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#le-besoin-de-structurer-les-données",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#le-besoin-de-structurer-les-données",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Au début de la programmation, les données étaient stockées de manière simple, souvent sous forme de variables individuelles. Avec la complexification des problèmes, le besoin de regrouper et d’organiser les données est devenu évident.\nExemple simple en C++ :\nstring nom = \"Dubois\";\nstring prenom = \"Marie\";\nint age = 20;\nfloat moyenne = 15.5;\nCette approche devient vite difficile à gérer pour de nombreux étudiants ou plus d’informations.",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#les-tableaux-première-forme-de-structuration",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#les-tableaux-première-forme-de-structuration",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Un tableau est une collection d’éléments de même type, accessibles par un index.\n\n\n\nint notes[5] = {12, 15, 18, 10, 14};\ncout &lt;&lt; \"La troisième note est : \" &lt;&lt; notes[2] &lt;&lt; endl;  // Affiche 18\n\n\n\n\nStockage efficace de multiples éléments de même type\nAccès rapide aux éléments par leur position\nTous les éléments doivent être du même type\nTaille souvent fixe à la compilation en C++",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#les-structures-en-c",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#les-structures-en-c",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Les structures permettent de regrouper des données de types différents qui sont logiquement liées.\n\n\nstruct Etudiant {\n    string nom;\n    string prenom;\n    int age;\n    float moyenne;\n};\n\nEtudiant marie = {\"Dubois\", \"Marie\", 20, 15.5};\ncout &lt;&lt; marie.prenom &lt;&lt; \" \" &lt;&lt; marie.nom &lt;&lt; \" a \" &lt;&lt; marie.age &lt;&lt; \" ans\" &lt;&lt; endl;\n\n\n\n\nReprésentation d’entités complexes de manière plus naturelle\nRegroupement logique des données liées\nAmélioration de la lisibilité et de l’organisation du code",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#les-records-en-pascal",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#les-records-en-pascal",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Pascal a introduit le concept de “record”, similaire aux structures en C++, mais avec quelques différences syntaxiques et conceptuelles.\n\n\ntype\n  Etudiant = record\n    nom: string[50];\n    prenom: string[50];\n    age: integer;\n    moyenne: real;\n  end;\n\nvar\n  marie: Etudiant;\n\nbegin\n  marie.nom := 'Dubois';\n  marie.prenom := 'Marie';\n  marie.age := 20;\n  marie.moyenne := 15.5;\n  \n  writeln(marie.prenom, ' ', marie.nom, ' a ', marie.age, ' ans');\nend.\n\n\n\n\nTypage fort : Pascal est connu pour son système de typage strict\nDéclaration explicite des types : Améliore la clarté et la sécurité du code\nUtilisé dans un langage conçu pour l’enseignement : Syntax claire et lisible",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#les-modules-en-modula-2",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#les-modules-en-modula-2",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Modula-2, successeur de Pascal, a introduit le concept de modules, une étape importante vers l’encapsulation.\n\n\nUn module en Modula-2 est une unité de programme qui regroupe des définitions de types, des variables et des procédures liées.\n\n\n\nMODULE GestionEtudiants;\n\nEXPORT Etudiant, CreerEtudiant, AfficherEtudiant;\n\nTYPE\n  Etudiant = RECORD\n    nom: ARRAY[0..49] OF CHAR;\n    prenom: ARRAY[0..49] OF CHAR;\n    age: INTEGER;\n    moyenne: REAL;\n  END;\n\nPROCEDURE CreerEtudiant(VAR e: Etudiant; n, p: ARRAY OF CHAR; a: INTEGER; m: REAL);\nBEGIN\n  (* Code pour initialiser un étudiant *)\nEND CreerEtudiant;\n\nPROCEDURE AfficherEtudiant(e: Etudiant);\nBEGIN\n  (* Code pour afficher les informations d'un étudiant *)\nEND AfficherEtudiant;\n\nEND GestionEtudiants.\n\n\n\n\nEncapsulation : Regroupement des données et des opérations liées\nSéparation interface/implémentation : Distinction entre ce qui est public et privé\nRéutilisabilité : Facilite la réutilisation du code dans différents programmes",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#impact-sur-la-programmation",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#impact-sur-la-programmation",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Ces évolutions dans la structuration des données ont eu plusieurs effets positifs :\n\nModélisation plus fidèle du monde réel\nAmélioration de la lisibilité et de la maintenabilité du code\nIntroduction de l’abstraction des données\nPrémices de l’encapsulation (particulièrement avec les modules)",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#vers-la-programmation-orientée-objet",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#vers-la-programmation-orientée-objet",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Malgré ces avancées, certaines limitations persistaient : - Manque de mécanismes pour l’extension et la spécialisation des structures - Absence de polymorphisme\nCes limitations ont ouvert la voie à la programmation orientée objet, qui intégrera ces concepts de manière plus complète et flexible.",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#conclusion",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#conclusion",
    "title": "Première Structuration des données",
    "section": "",
    "text": "La structuration des données, à travers les tableaux, les structures, les records et les modules, a posé les bases conceptuelles nécessaires à l’émergence de la programmation orientée objet. Cette évolution a permis de mieux organiser et représenter l’information, préparant le terrain pour des paradigmes plus avancés.",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmation Orientée Objet en Python: ",
    "section": "",
    "text": "Star this website on Github"
  },
  {
    "objectID": "index.html#rémi-genet",
    "href": "index.html#rémi-genet",
    "title": "Programmation Orientée Objet en Python: ",
    "section": "",
    "text": "Star this website on Github"
  },
  {
    "objectID": "content/Cours_1/5-Simplicity_and_performance.html",
    "href": "content/Cours_1/5-Simplicity_and_performance.html",
    "title": "Python : Simplicité des objets et performance sous-jacente",
    "section": "",
    "text": "Python est réputé pour sa courbe d’apprentissage douce, en grande partie grâce à son approche orientée objet intuitive.\n\n\nImaginons que vous vouliez lire un fichier CSV et analyser ses données :\nimport pandas as pd\n\n# Lecture d'un fichier CSV\ndf = pd.read_csv(\"donnees.csv\")\n\n# Affichage des premières lignes\nprint(df.head())\n\n# Calcul de la moyenne d'une colonne\nmoyenne = df['colonne_numerique'].mean()\n\n# Filtrage des données\nresultats = df[df['categorie'] == 'A']\nDans cet exemple : - Vous n’avez pas besoin de comprendre comment Pandas lit le fichier ou stocke les données. - Les méthodes comme head(), mean(), et le filtrage sont intuitives et faciles à utiliser. - Vous manipulez des objets complexes (DataFrame) avec une syntaxe simple.\n\n\n\n\nLes objets en Python cachent la complexité sous-jacente.\nVous utilisez des méthodes sans vous soucier de leur implémentation interne.\nCette approche permet aux débutants de se concentrer sur la logique de leur programme plutôt que sur les détails techniques.\n\n\n\n\n\nBien que Python soit généralement considéré comme plus lent que les langages de bas niveau, il offre des solutions pour obtenir des performances élevées.\n\n\n\nPython lui-même est implémenté en C (CPython, l’implémentation de référence).\nDe nombreuses bibliothèques Python populaires sont écrites en C ou ont des composants en C.\n\n\n\n\nNumPy est un excellent exemple de cette approche :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nNumPy utilise des tableaux optimisés en C.\nLes opérations sont effectuées en C, offrant des performances proches du matériel.\nL’interface Python reste simple et intuitive.\n\n\n\n\nRécemment, Python a étendu cette approche à d’autres langages performants comme Rust :\n\nDes bibliothèques comme PyO3 permettent d’écrire des extensions Python en Rust.\nCela combine la sécurité mémoire de Rust avec la facilité d’utilisation de Python.\n\n\n\n\n\nLes objets Python agissent comme une couche d’abstraction conviviale au-dessus de code performant :\n\nFacilité d’utilisation : L’interface orientée objet en Python est intuitive.\nAbstraction : Les détails complexes sont cachés à l’utilisateur.\nPerformance sous-jacente : Le code critique en termes de performance est écrit dans des langages compilés.\nFlexibilité : Les développeurs peuvent choisir entre la simplicité de Python pur ou l’optimisation avec C/Rust selon leurs besoins.\n\n\n\n\nPython réussit à offrir le meilleur des deux mondes : - Une interface orientée objet simple et intuitive, idéale pour l’apprentissage et le développement rapide. - La possibilité d’obtenir des performances élevées grâce à l’intégration de code C ou Rust.\nCette approche fait de Python un langage polyvalent, capable de s’adapter à une grande variété de besoins, du script simple à l’application haute performance, tout en maintenant une syntaxe accessible et une philosophie centrée sur la lisibilité du code.",
    "crumbs": [
      "Python : Simplicité des objets et performance sous-jacente"
    ]
  },
  {
    "objectID": "content/Cours_1/5-Simplicity_and_performance.html#la-simplicité-des-objets-en-python-pour-les-débutants",
    "href": "content/Cours_1/5-Simplicity_and_performance.html#la-simplicité-des-objets-en-python-pour-les-débutants",
    "title": "Python : Simplicité des objets et performance sous-jacente",
    "section": "",
    "text": "Python est réputé pour sa courbe d’apprentissage douce, en grande partie grâce à son approche orientée objet intuitive.\n\n\nImaginons que vous vouliez lire un fichier CSV et analyser ses données :\nimport pandas as pd\n\n# Lecture d'un fichier CSV\ndf = pd.read_csv(\"donnees.csv\")\n\n# Affichage des premières lignes\nprint(df.head())\n\n# Calcul de la moyenne d'une colonne\nmoyenne = df['colonne_numerique'].mean()\n\n# Filtrage des données\nresultats = df[df['categorie'] == 'A']\nDans cet exemple : - Vous n’avez pas besoin de comprendre comment Pandas lit le fichier ou stocke les données. - Les méthodes comme head(), mean(), et le filtrage sont intuitives et faciles à utiliser. - Vous manipulez des objets complexes (DataFrame) avec une syntaxe simple.\n\n\n\n\nLes objets en Python cachent la complexité sous-jacente.\nVous utilisez des méthodes sans vous soucier de leur implémentation interne.\nCette approche permet aux débutants de se concentrer sur la logique de leur programme plutôt que sur les détails techniques.",
    "crumbs": [
      "Python : Simplicité des objets et performance sous-jacente"
    ]
  },
  {
    "objectID": "content/Cours_1/5-Simplicity_and_performance.html#performance-le-meilleur-des-deux-mondes",
    "href": "content/Cours_1/5-Simplicity_and_performance.html#performance-le-meilleur-des-deux-mondes",
    "title": "Python : Simplicité des objets et performance sous-jacente",
    "section": "",
    "text": "Bien que Python soit généralement considéré comme plus lent que les langages de bas niveau, il offre des solutions pour obtenir des performances élevées.\n\n\n\nPython lui-même est implémenté en C (CPython, l’implémentation de référence).\nDe nombreuses bibliothèques Python populaires sont écrites en C ou ont des composants en C.\n\n\n\n\nNumPy est un excellent exemple de cette approche :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nNumPy utilise des tableaux optimisés en C.\nLes opérations sont effectuées en C, offrant des performances proches du matériel.\nL’interface Python reste simple et intuitive.\n\n\n\n\nRécemment, Python a étendu cette approche à d’autres langages performants comme Rust :\n\nDes bibliothèques comme PyO3 permettent d’écrire des extensions Python en Rust.\nCela combine la sécurité mémoire de Rust avec la facilité d’utilisation de Python.",
    "crumbs": [
      "Python : Simplicité des objets et performance sous-jacente"
    ]
  },
  {
    "objectID": "content/Cours_1/5-Simplicity_and_performance.html#lobjet-python-comme-interface-conviviale",
    "href": "content/Cours_1/5-Simplicity_and_performance.html#lobjet-python-comme-interface-conviviale",
    "title": "Python : Simplicité des objets et performance sous-jacente",
    "section": "",
    "text": "Les objets Python agissent comme une couche d’abstraction conviviale au-dessus de code performant :\n\nFacilité d’utilisation : L’interface orientée objet en Python est intuitive.\nAbstraction : Les détails complexes sont cachés à l’utilisateur.\nPerformance sous-jacente : Le code critique en termes de performance est écrit dans des langages compilés.\nFlexibilité : Les développeurs peuvent choisir entre la simplicité de Python pur ou l’optimisation avec C/Rust selon leurs besoins.",
    "crumbs": [
      "Python : Simplicité des objets et performance sous-jacente"
    ]
  },
  {
    "objectID": "content/Cours_1/5-Simplicity_and_performance.html#conclusion",
    "href": "content/Cours_1/5-Simplicity_and_performance.html#conclusion",
    "title": "Python : Simplicité des objets et performance sous-jacente",
    "section": "",
    "text": "Python réussit à offrir le meilleur des deux mondes : - Une interface orientée objet simple et intuitive, idéale pour l’apprentissage et le développement rapide. - La possibilité d’obtenir des performances élevées grâce à l’intégration de code C ou Rust.\nCette approche fait de Python un langage polyvalent, capable de s’adapter à une grande variété de besoins, du script simple à l’application haute performance, tout en maintenant une syntaxe accessible et une philosophie centrée sur la lisibilité du code.",
    "crumbs": [
      "Python : Simplicité des objets et performance sous-jacente"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html",
    "href": "content/Cours_1/4-all_is_object.html",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "En Python, absolument tout est un objet. Cette philosophie est fondamentale et distingue Python de nombreux autres langages de programmation.\n\n\n\nMême les types de base (int, float, str) sont des objets\nLes fonctions sont des objets\nLes classes sont des objets\nLes modules sont des objets\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\nEn C++, un int ou un float a une taille fixe et prédéfinie\nEn Python, même un simple entier est un objet complet avec des métadonnées\n\n\n\n\n\nOpérations plus coûteuses en Python (plus d’indirections)\nPas de risque d’overflow/underflow pour les entiers en Python (entiers de taille arbitraire)\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\nLes variables n’ont pas de type fixe\nLe type est lié à l’objet, pas à la variable\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nComme tout est objet, Python offre de puissantes capacités d’introspection.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\nSyntaxe cohérente pour manipuler différents types d’objets\nFacilite l’apprentissage et l’utilisation du langage\n\n\n\n\n\nPossibilité de créer des types personnalisés qui se comportent comme des types intégrés\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nLa nature “tout objet” de Python simplifie de nombreux concepts\nCependant, cela a un coût en termes de performance et d’utilisation mémoire\nPython privilégie la lisibilité et la facilité de développement sur la performance brute\n\n\n\n\nL’approche “tout est objet” de Python offre une grande cohérence et flexibilité, mais avec un compromis sur les performances. Cette philosophie permet aux développeurs de se concentrer sur la logique de leur programme plutôt que sur les détails de bas niveau, rendant Python particulièrement adapté au prototypage rapide et au développement d’applications où la vitesse de développement prime sur l’efficacité d’exécution.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#le-concept-tout-est-objet-en-python",
    "href": "content/Cours_1/4-all_is_object.html#le-concept-tout-est-objet-en-python",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "En Python, absolument tout est un objet. Cette philosophie est fondamentale et distingue Python de nombreux autres langages de programmation.\n\n\n\nMême les types de base (int, float, str) sont des objets\nLes fonctions sont des objets\nLes classes sont des objets\nLes modules sont des objets\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#objets-de-base-vs-objets-en-c",
    "href": "content/Cours_1/4-all_is_object.html#objets-de-base-vs-objets-en-c",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "En C++, un int ou un float a une taille fixe et prédéfinie\nEn Python, même un simple entier est un objet complet avec des métadonnées\n\n\n\n\n\nOpérations plus coûteuses en Python (plus d’indirections)\nPas de risque d’overflow/underflow pour les entiers en Python (entiers de taille arbitraire)\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#flexibilité-et-dynamisme",
    "href": "content/Cours_1/4-all_is_object.html#flexibilité-et-dynamisme",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "Les variables n’ont pas de type fixe\nLe type est lié à l’objet, pas à la variable\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#introspection-et-réflexion",
    "href": "content/Cours_1/4-all_is_object.html#introspection-et-réflexion",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "Comme tout est objet, Python offre de puissantes capacités d’introspection.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#implications-sur-la-programmation",
    "href": "content/Cours_1/4-all_is_object.html#implications-sur-la-programmation",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "Syntaxe cohérente pour manipuler différents types d’objets\nFacilite l’apprentissage et l’utilisation du langage\n\n\n\n\n\nPossibilité de créer des types personnalisés qui se comportent comme des types intégrés\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#compromis-simplicité-vs-performance",
    "href": "content/Cours_1/4-all_is_object.html#compromis-simplicité-vs-performance",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "La nature “tout objet” de Python simplifie de nombreux concepts\nCependant, cela a un coût en termes de performance et d’utilisation mémoire\nPython privilégie la lisibilité et la facilité de développement sur la performance brute",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#conclusion",
    "href": "content/Cours_1/4-all_is_object.html#conclusion",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "L’approche “tout est objet” de Python offre une grande cohérence et flexibilité, mais avec un compromis sur les performances. Cette philosophie permet aux développeurs de se concentrer sur la logique de leur programme plutôt que sur les détails de bas niveau, rendant Python particulièrement adapté au prototypage rapide et au développement d’applications où la vitesse de développement prime sur l’efficacité d’exécution.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html",
    "href": "content/Cours_1/1-Histoire.html",
    "title": "Histoire de la programmation",
    "section": "",
    "text": "Les premiers ordinateurs étaient programmés directement en langage machine, c’est-à-dire en code binaire. Cette méthode présentait plusieurs caractéristiques :\n\nComplexité extrême : Les programmeurs devaient écrire des séquences de 0 et de 1 pour chaque instruction.\nSpécificité au matériel : Chaque type de processeur avait son propre jeu d’instructions en langage machine.\nDifficulté de maintenance : Le code était pratiquement illisible pour les humains, rendant les corrections et les mises à jour très difficiles.\n\nExemple simplifié d’addition en langage machine (fictif) :\n10110000 01100011 00000001  // Charger la valeur du registre 1 dans l'accumulateur\n10110001 01100011 00000010  // Ajouter la valeur du registre 2 à l'accumulateur\n10110010 01100011 00000011  // Stocker le résultat dans le registre 3\n\n\n\nPour faciliter la programmation, le langage assembleur a été développé. Il présentait plusieurs avantages :\n\nLisibilité améliorée : Utilisation de mnémoniques (ADD, MOV, JMP) au lieu de codes binaires.\nCorrespondance directe : Chaque instruction assembleur correspondait généralement à une instruction en langage machine.\nIntroduction des étiquettes : Permettait de nommer des points dans le programme, facilitant les sauts et les boucles.\n\nExemple du même calcul en assembleur (syntaxe simplifiée) :\nLOAD R1    ; Charger la valeur du registre 1 dans l'accumulateur\nADD R2     ; Ajouter la valeur du registre 2 à l'accumulateur\nSTORE R3   ; Stocker le résultat dans le registre 3\n\n\n\n\n\n\nDéveloppé par IBM en 1957, FORTRAN a révolutionné la programmation :\n\nPremier langage de haut niveau largement adopté\nConçu pour les calculs scientifiques et l’ingénierie\nIntroduction de concepts comme les boucles et les fonctions\n\nExemple de calcul d’intérêt composé en FORTRAN :\nPROGRAM INTERET_COMPOSE\n    REAL PRINCIPAL, TAUX, MONTANT\n    INTEGER ANNEES, I\n\n    PRINT *, 'Entrez le principal, le taux (en decimal) et les annees:'\n    READ *, PRINCIPAL, TAUX, ANNEES\n\n    MONTANT = PRINCIPAL\n    DO I = 1, ANNEES\n        MONTANT = MONTANT * (1 + TAUX)\n    END DO\n\n    PRINT *, 'Montant final:', MONTANT\nEND PROGRAM INTERET_COMPOSE\n\n\n\nCréé en 1959, COBOL visait les applications commerciales :\n\nSyntaxe proche de l’anglais pour faciliter la compréhension\nGestion efficace des fichiers et des données structurées\nLargement utilisé dans les systèmes bancaires et financiers\n\nExemple simplifié de calcul de salaire en COBOL :\nIDENTIFICATION DIVISION.\nPROGRAM-ID. CALCUL-SALAIRE.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT EMPLOYE-FICHIER ASSIGN TO \"employes.dat\"\n        ORGANIZATION IS LINE SEQUENTIAL.\n\nDATA DIVISION.\nFILE SECTION.\nFD EMPLOYE-FICHIER.\n01 EMPLOYE-ENREG.\n    05 EMP-NOM PIC X(20).\n    05 EMP-HEURES PIC 9(3).\n    05 EMP-TAUX PIC 9(3)V99.\n\nWORKING-STORAGE SECTION.\n01 WS-SALAIRE PIC 9(5)V99.\n01 WS-EOF PIC A(1).\n\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\n    OPEN INPUT EMPLOYE-FICHIER\n    PERFORM UNTIL WS-EOF = 'Y'\n        READ EMPLOYE-FICHIER\n            AT END\n                MOVE 'Y' TO WS-EOF\n            NOT AT END\n                PERFORM CALCUL-AFFICHAGE\n        END-READ\n    END-PERFORM\n    CLOSE EMPLOYE-FICHIER\n    STOP RUN.\n\nCALCUL-AFFICHAGE.\n    COMPUTE WS-SALAIRE = EMP-HEURES * EMP-TAUX\n    DISPLAY EMP-NOM \" Salaire: $\" WS-SALAIRE.\n\n\n\n\nLa programmation procédurale, illustrée par ces langages, se caractérise par :\n\nSéquence d’instructions : Le programme est une suite d’étapes à exécuter.\nProcédures et fonctions : Le code est organisé en blocs réutilisables.\nVariables globales et locales : Gestion de l’état du programme.\nFlux de contrôle linéaire : Utilisation de structures comme les boucles et les conditions.\n\n\n\n\nSimplicité relative par rapport au langage machine\nPossibilité de créer des programmes complexes\nFacilité d’apprentissage pour les débutants\n\n\n\n\n\nDifficulté à gérer des projets très larges\nRisque élevé d’effets de bord avec les variables globales\nManque de représentation naturelle pour certains problèmes du monde réel\n\nCette approche a dominé la programmation pendant plusieurs décennies, posant les bases pour l’évolution future vers des paradigmes plus avancés, notamment la programmation orientée objet.",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#lère-du-langage-machine-et-de-lassembleur",
    "href": "content/Cours_1/1-Histoire.html#lère-du-langage-machine-et-de-lassembleur",
    "title": "Histoire de la programmation",
    "section": "",
    "text": "Les premiers ordinateurs étaient programmés directement en langage machine, c’est-à-dire en code binaire. Cette méthode présentait plusieurs caractéristiques :\n\nComplexité extrême : Les programmeurs devaient écrire des séquences de 0 et de 1 pour chaque instruction.\nSpécificité au matériel : Chaque type de processeur avait son propre jeu d’instructions en langage machine.\nDifficulté de maintenance : Le code était pratiquement illisible pour les humains, rendant les corrections et les mises à jour très difficiles.\n\nExemple simplifié d’addition en langage machine (fictif) :\n10110000 01100011 00000001  // Charger la valeur du registre 1 dans l'accumulateur\n10110001 01100011 00000010  // Ajouter la valeur du registre 2 à l'accumulateur\n10110010 01100011 00000011  // Stocker le résultat dans le registre 3\n\n\n\nPour faciliter la programmation, le langage assembleur a été développé. Il présentait plusieurs avantages :\n\nLisibilité améliorée : Utilisation de mnémoniques (ADD, MOV, JMP) au lieu de codes binaires.\nCorrespondance directe : Chaque instruction assembleur correspondait généralement à une instruction en langage machine.\nIntroduction des étiquettes : Permettait de nommer des points dans le programme, facilitant les sauts et les boucles.\n\nExemple du même calcul en assembleur (syntaxe simplifiée) :\nLOAD R1    ; Charger la valeur du registre 1 dans l'accumulateur\nADD R2     ; Ajouter la valeur du registre 2 à l'accumulateur\nSTORE R3   ; Stocker le résultat dans le registre 3",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#lémergence-des-langages-de-haut-niveau",
    "href": "content/Cours_1/1-Histoire.html#lémergence-des-langages-de-haut-niveau",
    "title": "Histoire de la programmation",
    "section": "",
    "text": "Développé par IBM en 1957, FORTRAN a révolutionné la programmation :\n\nPremier langage de haut niveau largement adopté\nConçu pour les calculs scientifiques et l’ingénierie\nIntroduction de concepts comme les boucles et les fonctions\n\nExemple de calcul d’intérêt composé en FORTRAN :\nPROGRAM INTERET_COMPOSE\n    REAL PRINCIPAL, TAUX, MONTANT\n    INTEGER ANNEES, I\n\n    PRINT *, 'Entrez le principal, le taux (en decimal) et les annees:'\n    READ *, PRINCIPAL, TAUX, ANNEES\n\n    MONTANT = PRINCIPAL\n    DO I = 1, ANNEES\n        MONTANT = MONTANT * (1 + TAUX)\n    END DO\n\n    PRINT *, 'Montant final:', MONTANT\nEND PROGRAM INTERET_COMPOSE\n\n\n\nCréé en 1959, COBOL visait les applications commerciales :\n\nSyntaxe proche de l’anglais pour faciliter la compréhension\nGestion efficace des fichiers et des données structurées\nLargement utilisé dans les systèmes bancaires et financiers\n\nExemple simplifié de calcul de salaire en COBOL :\nIDENTIFICATION DIVISION.\nPROGRAM-ID. CALCUL-SALAIRE.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT EMPLOYE-FICHIER ASSIGN TO \"employes.dat\"\n        ORGANIZATION IS LINE SEQUENTIAL.\n\nDATA DIVISION.\nFILE SECTION.\nFD EMPLOYE-FICHIER.\n01 EMPLOYE-ENREG.\n    05 EMP-NOM PIC X(20).\n    05 EMP-HEURES PIC 9(3).\n    05 EMP-TAUX PIC 9(3)V99.\n\nWORKING-STORAGE SECTION.\n01 WS-SALAIRE PIC 9(5)V99.\n01 WS-EOF PIC A(1).\n\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\n    OPEN INPUT EMPLOYE-FICHIER\n    PERFORM UNTIL WS-EOF = 'Y'\n        READ EMPLOYE-FICHIER\n            AT END\n                MOVE 'Y' TO WS-EOF\n            NOT AT END\n                PERFORM CALCUL-AFFICHAGE\n        END-READ\n    END-PERFORM\n    CLOSE EMPLOYE-FICHIER\n    STOP RUN.\n\nCALCUL-AFFICHAGE.\n    COMPUTE WS-SALAIRE = EMP-HEURES * EMP-TAUX\n    DISPLAY EMP-NOM \" Salaire: $\" WS-SALAIRE.",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#caractéristiques-de-la-programmation-procédurale",
    "href": "content/Cours_1/1-Histoire.html#caractéristiques-de-la-programmation-procédurale",
    "title": "Histoire de la programmation",
    "section": "",
    "text": "La programmation procédurale, illustrée par ces langages, se caractérise par :\n\nSéquence d’instructions : Le programme est une suite d’étapes à exécuter.\nProcédures et fonctions : Le code est organisé en blocs réutilisables.\nVariables globales et locales : Gestion de l’état du programme.\nFlux de contrôle linéaire : Utilisation de structures comme les boucles et les conditions.\n\n\n\n\nSimplicité relative par rapport au langage machine\nPossibilité de créer des programmes complexes\nFacilité d’apprentissage pour les débutants\n\n\n\n\n\nDifficulté à gérer des projets très larges\nRisque élevé d’effets de bord avec les variables globales\nManque de représentation naturelle pour certains problèmes du monde réel\n\nCette approche a dominé la programmation pendant plusieurs décennies, posant les bases pour l’évolution future vers des paradigmes plus avancés, notamment la programmation orientée objet.",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "content/Cours_1/index.html",
    "href": "content/Cours_1/index.html",
    "title": "Introduction: Histoire et Concepts",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClasses en Python : Concepts fondamentaux\n\n\nDécouvrez les concepts fondamentaux des classes en Python, y compris les attributs de classe vs d’instance, le rôle de ‘self’, et les conventions de codage.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConstruire son propre DataFrame\n\n\n\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHistoire de la programmation\n\n\nDu binaire à la POO\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNaissance de la POO\n\n\nL’adoption de la POO dans les langages modernes comme C++ et Python a révolutionné la programmation. Découvrez comment ces langages ont intégré les concepts de la POO et…\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPremière Structuration des données\n\n\nDécouvrez comment les tableaux, les structures et les records ont permis de structurer les données dans les premiers langages de programmation.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython : Simplicité des objets et performance sous-jacente\n\n\nDécouvrez comment Python peut combiner la simplicité des objets avec des performances élevées grâce à l’intégration de code C et Rust.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython: tout n’est qu’objet\n\n\nExplorer la notion de PATH, un élément essentiel dans la configuration des environnements de développement.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Introduction: Histoire et Concepts"
    ]
  },
  {
    "objectID": "content/Cours_3/TP.html",
    "href": "content/Cours_3/TP.html",
    "title": "TP",
    "section": "",
    "text": "TODO\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/Cours_3/1-Polymorphism.html",
    "href": "content/Cours_3/1-Polymorphism.html",
    "title": "Polymorphism in Object-Oriented Programming",
    "section": "",
    "text": "Polymorphism is a fundamental principle in object-oriented programming (OOP) that allows objects of different types to be treated as objects of a common base type. The word “polymorphism” comes from Greek, meaning “many forms.” In OOP, it refers to the ability of a single interface to represent different underlying forms (data types or classes).\n\n\n\nSame Interface, Different Implementations: Polymorphism allows different classes to have methods with the same name, but with different implementations.\nFlexibility: It provides a way to use a class exactly like its parent, but with its own specific implementation.\nSimplification: It simplifies programming interfaces, making code more modular and extensible.\nRuntime Decision: The specific method that gets called is often determined at runtime, based on the actual type of the object.\n\n\n\n\n\nCompile-time Polymorphism (Static):\n\nAchieved through method overloading\nResolved at compile time\n\nRuntime Polymorphism (Dynamic):\n\nAchieved through method overriding\nResolved at runtime\n\n\n\n\n\nConsider a base class Animal with a method make_sound(). Different animals can implement this method differently:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, each animal class implements the make_sound() method differently, but they can all be treated as Animal objects.\n\n\n\n\nMethod overriding is a fundamental aspect of runtime polymorphism. It occurs when a derived class (child class) has a method with the same name and signature as a method in its base class (parent class).\n\n\n\nSame Name and Signature: The overriding method must have the same name and parameter list as the method in the parent class.\nRuntime Decision: The method to be invoked is determined at runtime based on the object’s type.\nExtends or Modifies Behavior: Overriding allows a child class to provide a specific implementation of a method that is already defined in its parent class.\nPolymorphic Behavior: It’s a key mechanism for achieving polymorphic behavior in OOP.\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - The Shape class provides a default implementation of area(). - Rectangle and Circle override this method with their specific implementations. - We can treat all objects as Shape instances, but each will use its own area() method.\n\n\n\n\nCustomization: Allows subclasses to provide specific implementations of methods.\nCode Reusability: Reuses the method name from the parent class, maintaining a logical hierarchy.\nRuntime Flexibility: Enables objects to behave differently based on their actual class, while still using a common interface.\n\nMethod overriding is a powerful feature that, when used correctly, can lead to more flexible and maintainable code structures in object-oriented programming.",
    "crumbs": [
      "Polymorphism in Object-Oriented Programming"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Polymorphism.html#general-concept",
    "href": "content/Cours_3/1-Polymorphism.html#general-concept",
    "title": "Polymorphism in Object-Oriented Programming",
    "section": "",
    "text": "Polymorphism is a fundamental principle in object-oriented programming (OOP) that allows objects of different types to be treated as objects of a common base type. The word “polymorphism” comes from Greek, meaning “many forms.” In OOP, it refers to the ability of a single interface to represent different underlying forms (data types or classes).\n\n\n\nSame Interface, Different Implementations: Polymorphism allows different classes to have methods with the same name, but with different implementations.\nFlexibility: It provides a way to use a class exactly like its parent, but with its own specific implementation.\nSimplification: It simplifies programming interfaces, making code more modular and extensible.\nRuntime Decision: The specific method that gets called is often determined at runtime, based on the actual type of the object.\n\n\n\n\n\nCompile-time Polymorphism (Static):\n\nAchieved through method overloading\nResolved at compile time\n\nRuntime Polymorphism (Dynamic):\n\nAchieved through method overriding\nResolved at runtime\n\n\n\n\n\nConsider a base class Animal with a method make_sound(). Different animals can implement this method differently:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, each animal class implements the make_sound() method differently, but they can all be treated as Animal objects.",
    "crumbs": [
      "Polymorphism in Object-Oriented Programming"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Polymorphism.html#method-overriding",
    "href": "content/Cours_3/1-Polymorphism.html#method-overriding",
    "title": "Polymorphism in Object-Oriented Programming",
    "section": "",
    "text": "Method overriding is a fundamental aspect of runtime polymorphism. It occurs when a derived class (child class) has a method with the same name and signature as a method in its base class (parent class).\n\n\n\nSame Name and Signature: The overriding method must have the same name and parameter list as the method in the parent class.\nRuntime Decision: The method to be invoked is determined at runtime based on the object’s type.\nExtends or Modifies Behavior: Overriding allows a child class to provide a specific implementation of a method that is already defined in its parent class.\nPolymorphic Behavior: It’s a key mechanism for achieving polymorphic behavior in OOP.\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - The Shape class provides a default implementation of area(). - Rectangle and Circle override this method with their specific implementations. - We can treat all objects as Shape instances, but each will use its own area() method.\n\n\n\n\nCustomization: Allows subclasses to provide specific implementations of methods.\nCode Reusability: Reuses the method name from the parent class, maintaining a logical hierarchy.\nRuntime Flexibility: Enables objects to behave differently based on their actual class, while still using a common interface.\n\nMethod overriding is a powerful feature that, when used correctly, can lead to more flexible and maintainable code structures in object-oriented programming.",
    "crumbs": [
      "Polymorphism in Object-Oriented Programming"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Overloading.html",
    "href": "content/Cours_3/2-Overloading.html",
    "title": "Polymorphism in Python: Function Overloading and Type Checking",
    "section": "",
    "text": "In Python, function overloading (having multiple functions with the same name but different parameters) is not directly supported like in C++. However, Python offers alternative ways to achieve similar functionality. Let’s explore this concept and how it relates to polymorphism.\n\n\n\n\nIn C++, you might write:\nclass Calculator {\npublic:\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    double add(double a, double b) {\n        return a + b;\n    }\n};\nThis is not possible in Python. If you define two functions with the same name, the latter will override the former.\n\n\n\nIn Python, we need to use different strategies to handle different types of inputs:\n\nDifferent Function Names:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSingle Function with Type Checking:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUsing a Class to Encapsulate Different Implementations:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nThe class-based approach above demonstrates a form of polymorphism. The add method behaves differently based on the types of its inputs, effectively providing different implementations for different data types.\n\n\n\nSingle Interface: Users of the Calculator class only need to call add, regardless of the input types.\nEncapsulation: The type-specific implementations (_add_integers and _add_floats) are hidden from the user.\nExtensibility: It’s easy to add support for new types by adding new private methods and extending the type checking in add.\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nWhile the above approach uses explicit type checking, Python often relies on duck typing for polymorphism. “If it walks like a duck and quacks like a duck, it’s a duck.”\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this case, calculate_area works with any object that has an area method, regardless of its actual type.\n\n\n\nWhile Python doesn’t support function overloading in the same way as C++, it offers flexible alternatives through type checking and duck typing. These approaches allow for polymorphic behavior, enabling functions and methods to work with different types in a way that’s both pythonic and maintainable.\nThe class-based approach with encapsulated type-specific methods provides a clean way to handle different input types while maintaining a simple interface for the user. This demonstrates how Python can achieve polymorphic behavior similar to function overloading in other languages, but with its own unique style.",
    "crumbs": [
      "Polymorphism in Python: Function Overloading and Type Checking"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Overloading.html#function-overloading-in-python",
    "href": "content/Cours_3/2-Overloading.html#function-overloading-in-python",
    "title": "Polymorphism in Python: Function Overloading and Type Checking",
    "section": "",
    "text": "In C++, you might write:\nclass Calculator {\npublic:\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    double add(double a, double b) {\n        return a + b;\n    }\n};\nThis is not possible in Python. If you define two functions with the same name, the latter will override the former.\n\n\n\nIn Python, we need to use different strategies to handle different types of inputs:\n\nDifferent Function Names:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSingle Function with Type Checking:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUsing a Class to Encapsulate Different Implementations:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Polymorphism in Python: Function Overloading and Type Checking"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Overloading.html#polymorphism-through-type-checking",
    "href": "content/Cours_3/2-Overloading.html#polymorphism-through-type-checking",
    "title": "Polymorphism in Python: Function Overloading and Type Checking",
    "section": "",
    "text": "The class-based approach above demonstrates a form of polymorphism. The add method behaves differently based on the types of its inputs, effectively providing different implementations for different data types.\n\n\n\nSingle Interface: Users of the Calculator class only need to call add, regardless of the input types.\nEncapsulation: The type-specific implementations (_add_integers and _add_floats) are hidden from the user.\nExtensibility: It’s easy to add support for new types by adding new private methods and extending the type checking in add.\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Polymorphism in Python: Function Overloading and Type Checking"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Overloading.html#duck-typing-and-polymorphism-in-python",
    "href": "content/Cours_3/2-Overloading.html#duck-typing-and-polymorphism-in-python",
    "title": "Polymorphism in Python: Function Overloading and Type Checking",
    "section": "",
    "text": "While the above approach uses explicit type checking, Python often relies on duck typing for polymorphism. “If it walks like a duck and quacks like a duck, it’s a duck.”\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this case, calculate_area works with any object that has an area method, regardless of its actual type.",
    "crumbs": [
      "Polymorphism in Python: Function Overloading and Type Checking"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Overloading.html#conclusion",
    "href": "content/Cours_3/2-Overloading.html#conclusion",
    "title": "Polymorphism in Python: Function Overloading and Type Checking",
    "section": "",
    "text": "While Python doesn’t support function overloading in the same way as C++, it offers flexible alternatives through type checking and duck typing. These approaches allow for polymorphic behavior, enabling functions and methods to work with different types in a way that’s both pythonic and maintainable.\nThe class-based approach with encapsulated type-specific methods provides a clean way to handle different input types while maintaining a simple interface for the user. This demonstrates how Python can achieve polymorphic behavior similar to function overloading in other languages, but with its own unique style.",
    "crumbs": [
      "Polymorphism in Python: Function Overloading and Type Checking"
    ]
  },
  {
    "objectID": "content/Cours_3/index.html",
    "href": "content/Cours_3/index.html",
    "title": "Polymorphisme et Surcharge",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbstract Classes\n\n\nLearn about abstract classes in Python, how to define and use them, and the benefits of using abstract classes for creating a common interface and enforcing method…\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClass Creation: Standard vs type()\n\n\nCompare standard class creation with dynamic creation using type() in Python, understanding their equivalence and potential issues.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPolymorphism in Object-Oriented Programming\n\n\nLearn about polymorphism in object-oriented programming (OOP), including method overriding, runtime polymorphism, and how it enables flexible and extensible code structures.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPolymorphism in Python: Function Overloading and Type Checking\n\n\nLearn how to achieve polymorphism in Python through function overloading, type checking, and class-based polymorphism\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProtocol Classes\n\n\nLearn about Protocol classes in Python, how to define and use them, and the advantages of using Protocols for defining interfaces and structural subtyping.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP\n\n\n\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP\n\n\n\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType Hinting, Typing Module, and Linters in Python\n\n\nLearn about type hinting in Python, the typing module, and how to use linters for static type checking to improve code quality and maintainability.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Polymorphisme et Surcharge"
    ]
  },
  {
    "objectID": "content/Cours_2/2-Heritage.html",
    "href": "content/Cours_2/2-Heritage.html",
    "title": "Héritage en Python : Concept et intérêt",
    "section": "",
    "text": "L’héritage est un mécanisme fondamental de la programmation orientée objet qui permet à une classe de baser sa définition sur celle d’une autre classe. Cela favorise la réutilisation du code et permet de créer des hiérarchies de classes.\n\n\n\nRéutilisation du code : L’héritage permet d’éviter la duplication de code en définissant des comportements communs dans une classe parente.\nOrganisation logique : Il permet de créer des hiérarchies de classes qui reflètent des relations logiques entre concepts.\nExtensibilité : Les classes dérivées peuvent étendre ou modifier le comportement des classes parentes, rendant le code plus flexible.\nPolymorphisme : L’héritage est à la base du polymorphisme, permettant de traiter des objets de classes différentes de manière uniforme.\n\n\n\n\nEn Python, toutes les classes héritent implicitement de la classe object, même si ce n’est pas spécifié explicitement.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nL’héritage de object fournit des méthodes de base comme __init__, __str__, __repr__, etc. C’est pourquoi toutes les classes en Python ont certaines méthodes en commun.\n\n\n\nPython supporte l’héritage multiple, ce qui signifie qu’une classe peut hériter de plusieurs classes parentes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nCombinaison de fonctionnalités : Permet de combiner des fonctionnalités de différentes classes en une seule.\nRéutilisation de code provenant de sources multiples : Utile lorsqu’une classe doit hériter de comportements de plusieurs classes non liées.\nImplémentation de designs complexes : Permet de créer des structures de classes plus flexibles et adaptables.\n\nExemple concret :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, Canard hérite des capacités de Nageur et Volant, combinant ainsi ces deux comportements.\n\n\n\n\nLa MRO est cruciale pour comprendre comment Python gère l’héritage, en particulier l’héritage multiple.\n\n\nLa MRO définit l’ordre dans lequel Python recherche les méthodes et les attributs dans une hiérarchie de classes. Elle est particulièrement importante en cas d’héritage multiple, où plusieurs classes parentes peuvent définir la même méthode.\n\n\n\nPython utilise l’algorithme C3 pour déterminer la MRO. Cet algorithme garantit que :\n\nLes sous-classes apparaissent avant les classes parentes.\nL’ordre de déclaration des classes parentes est respecté.\nLa MRO est monotone (une classe apparaît toujours avant ses parents).\n\n\n\n\nOn peut visualiser la MRO d’une classe avec la méthode mro() ou l’attribut __mro__ :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nConsidérons cet exemple pour illustrer comment la MRO fonctionne :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, D hérite de B et C. Lorsque d.methode() est appelé, Python suit la MRO : D -&gt; B -&gt; C -&gt; A -&gt; object. Il trouve d’abord la méthode dans B, donc c’est celle-ci qui est exécutée.\n\n\n\nLa compréhension de la MRO est cruciale pour : - Éviter les conflits de noms dans l’héritage multiple. - Comprendre l’ordre d’exécution des méthodes. - Concevoir des hiérarchies de classes cohérentes et prévisibles.",
    "crumbs": [
      "Héritage en Python : Concept et intérêt"
    ]
  },
  {
    "objectID": "content/Cours_2/2-Heritage.html#héritage-multiple-en-python",
    "href": "content/Cours_2/2-Heritage.html#héritage-multiple-en-python",
    "title": "Héritage en Python : Concept et intérêt",
    "section": "",
    "text": "Python supporte l’héritage multiple, ce qui signifie qu’une classe peut hériter de plusieurs classes parentes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nCombinaison de fonctionnalités : Permet de combiner des fonctionnalités de différentes classes en une seule.\nRéutilisation de code provenant de sources multiples : Utile lorsqu’une classe doit hériter de comportements de plusieurs classes non liées.\nImplémentation de designs complexes : Permet de créer des structures de classes plus flexibles et adaptables.\n\nExemple concret :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, Canard hérite des capacités de Nageur et Volant, combinant ainsi ces deux comportements.",
    "crumbs": [
      "Héritage en Python : Concept et intérêt"
    ]
  },
  {
    "objectID": "content/Cours_2/2-Heritage.html#method-resolution-order-mro-en-détail",
    "href": "content/Cours_2/2-Heritage.html#method-resolution-order-mro-en-détail",
    "title": "Héritage en Python : Concept et intérêt",
    "section": "",
    "text": "La MRO est cruciale pour comprendre comment Python gère l’héritage, en particulier l’héritage multiple.\n\n\nLa MRO définit l’ordre dans lequel Python recherche les méthodes et les attributs dans une hiérarchie de classes. Elle est particulièrement importante en cas d’héritage multiple, où plusieurs classes parentes peuvent définir la même méthode.\n\n\n\nPython utilise l’algorithme C3 pour déterminer la MRO. Cet algorithme garantit que :\n\nLes sous-classes apparaissent avant les classes parentes.\nL’ordre de déclaration des classes parentes est respecté.\nLa MRO est monotone (une classe apparaît toujours avant ses parents).\n\n\n\n\nOn peut visualiser la MRO d’une classe avec la méthode mro() ou l’attribut __mro__ :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nConsidérons cet exemple pour illustrer comment la MRO fonctionne :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, D hérite de B et C. Lorsque d.methode() est appelé, Python suit la MRO : D -&gt; B -&gt; C -&gt; A -&gt; object. Il trouve d’abord la méthode dans B, donc c’est celle-ci qui est exécutée.\n\n\n\nLa compréhension de la MRO est cruciale pour : - Éviter les conflits de noms dans l’héritage multiple. - Comprendre l’ordre d’exécution des méthodes. - Concevoir des hiérarchies de classes cohérentes et prévisibles.",
    "crumbs": [
      "Héritage en Python : Concept et intérêt"
    ]
  },
  {
    "objectID": "content/Cours_2/4-Dunder.html",
    "href": "content/Cours_2/4-Dunder.html",
    "title": "Méthodes Dunder en Python",
    "section": "",
    "text": "Les méthodes dunder en Python\n\nLes méthodes dunder sont encadrées par des doubles tirets bas (__) et sont appelées automatiquement par Python dans certaines circonstances.\n\n1. Initialisation et destruction\n\ninit(self, …)\n\nAppelée lors de la création d’une instance.\nInitialise les attributs de l’objet.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\ndel(self)\n\nAppelée lorsque l’objet est sur le point d’être détruit.\nUtile pour le nettoyage de ressources.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n2. Représentation des objets\n\nstr(self)\n\nRetourne une représentation lisible de l’objet.\nUtilisée par str() et print().\n\n\n\nrepr(self)\n\nRetourne une représentation “officielle” de l’objet.\nUtilisée par repr() et dans l’interpréteur interactif.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n3. Opérations mathématiques\n\nadd(self, other), sub(self, other), mul(self, other), truediv(self, other)\n\nDéfinissent les opérations +, -, *, / respectivement.\n\n\n\nfloordiv(self, other), mod(self, other), pow(self, other)\n\nDéfinissent les opérations //, %, ** respectivement.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n4. Comparaisons\n\neq(self, other), ne(self, other)\n\nDéfinissent == et != respectivement.\n\n\n\nlt(self, other), le(self, other), gt(self, other), ge(self, other)\n\nDéfinissent &lt;, &lt;=, &gt;, &gt;= respectivement.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n5. Conteneurs et séquences\n\nlen(self)\n\nRetourne la longueur de l’objet.\nUtilisée par la fonction len().\n\n\n\ngetitem(self, key)\n\nPermet l’accès par index ou clé.\nUtilisée pour l’indexation obj[key].\n\n\n\nsetitem(self, key, value)\n\nPermet l’assignation par index ou clé.\n\n\n\niter(self)\n\nRetourne un itérateur pour l’objet.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n6. Gestion des attributs\n\ngetattr(self, name)\n\nAppelée lorsqu’un attribut non trouvé est accédé.\n\n\n\nsetattr(self, name, value)\n\nAppelée lors de l’assignation d’un attribut.\n\n\n\ndelattr(self, name)\n\nAppelée lors de la suppression d’un attribut.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n7. Appel de l’objet comme une fonction\n\ncall(self, …)\n\nPermet d’appeler l’objet comme une fonction.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n8. Gestion du contexte\n\nenter(self), exit(self, exc_type, exc_value, traceback)\n\nUtilisées pour le gestionnaire de contexte (with statement).\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n9. Autres méthodes dunder utiles\n\nbool(self): Définit le comportement pour bool().\nhash(self): Permet à l’objet d’être utilisé comme clé de dictionnaire.\nformat(self, format_spec): Personnalise le formatage de chaînes.\n\nCette liste, bien que non exhaustive, couvre la plupart des méthodes dunder couramment utilisées en Python. Chacune de ces méthodes permet de personnaliser le comportement des objets dans différents contextes, rendant le langage extrêmement flexible et puissant.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Méthodes Dunder en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/5-call_a_dog.html",
    "href": "content/Cours_2/5-call_a_dog.html",
    "title": "Python call Method: A Fun Exploration",
    "section": "",
    "text": "After diving into the world of dunder methods, let’s take a fun break and explore some quirky behavior of the __call__ method in Python. This example showcases how we can create objects that can be “called” multiple times, and gives us some interesting insights into Python’s memory allocation.\n\n\nLet’s start with a simple goal: we want to create a Dog class that allows us to add any number of parentheses after it. Something like this:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nLet’s start with a simple implementation:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this implementation, we’re alternating between returning a Dog instance and the Dog class itself. This allows us to chain as many calls as we want!\n\n\n\nNow, let’s look at how Python handles memory allocation in this case:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nInteresting! When we create new instances and save them to a variable, Python allocates new memory. But when we chain calls without saving the intermediate results, Python often reuses the same memory address for new instances.\n\n\n\nWhat if we always want to return an instance, regardless of how many times we call it?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow we always get the same instance, no matter how many times we call it!\n\n\n\nWhat if we want a new instance every time?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nInterestingly, the address changes after the first call, then remains the same. This is due to Python’s memory management optimizations.\n\n\n\nFinally, if we really want to ensure a unique instance every time:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow we’re forcing Python to create and track unique instances, resulting in different memory addresses for each new instance.\n\n\n\n\nThis fun exploration of the __call__ method and Python’s memory allocation shows us a few things:\n\nThe __call__ method allows us to make our objects callable, leading to some interesting and flexible designs.\nPython’s memory management is quite clever, often reusing memory addresses when it can.\nWe can control instance creation and memory allocation by customizing __new__ and __call__.\n\nRemember, while these examples are fun to explore and can teach us a lot about Python’s inner workings, they’re not typically something you’d use in production code. They’re great for understanding Python better and maybe for solving some tricky coding puzzles!",
    "crumbs": [
      "Python __call__ Method: A Fun Exploration"
    ]
  },
  {
    "objectID": "content/Cours_2/5-call_a_dog.html#the-infinitely-callable-dog",
    "href": "content/Cours_2/5-call_a_dog.html#the-infinitely-callable-dog",
    "title": "Python call Method: A Fun Exploration",
    "section": "",
    "text": "Let’s start with a simple goal: we want to create a Dog class that allows us to add any number of parentheses after it. Something like this:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nLet’s start with a simple implementation:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this implementation, we’re alternating between returning a Dog instance and the Dog class itself. This allows us to chain as many calls as we want!\n\n\n\nNow, let’s look at how Python handles memory allocation in this case:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nInteresting! When we create new instances and save them to a variable, Python allocates new memory. But when we chain calls without saving the intermediate results, Python often reuses the same memory address for new instances.\n\n\n\nWhat if we always want to return an instance, regardless of how many times we call it?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow we always get the same instance, no matter how many times we call it!\n\n\n\nWhat if we want a new instance every time?\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nInterestingly, the address changes after the first call, then remains the same. This is due to Python’s memory management optimizations.\n\n\n\nFinally, if we really want to ensure a unique instance every time:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow we’re forcing Python to create and track unique instances, resulting in different memory addresses for each new instance.",
    "crumbs": [
      "Python __call__ Method: A Fun Exploration"
    ]
  },
  {
    "objectID": "content/Cours_2/5-call_a_dog.html#conclusion",
    "href": "content/Cours_2/5-call_a_dog.html#conclusion",
    "title": "Python call Method: A Fun Exploration",
    "section": "",
    "text": "This fun exploration of the __call__ method and Python’s memory allocation shows us a few things:\n\nThe __call__ method allows us to make our objects callable, leading to some interesting and flexible designs.\nPython’s memory management is quite clever, often reusing memory addresses when it can.\nWe can control instance creation and memory allocation by customizing __new__ and __call__.\n\nRemember, while these examples are fun to explore and can teach us a lot about Python’s inner workings, they’re not typically something you’d use in production code. They’re great for understanding Python better and maybe for solving some tricky coding puzzles!",
    "crumbs": [
      "Python __call__ Method: A Fun Exploration"
    ]
  },
  {
    "objectID": "content/Cours_2/index.html",
    "href": "content/Cours_2/index.html",
    "title": "Encapsulation, Heritage, Composition et Dunder",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEncapsulation en Python\n\n\nComprendre l’encapsulation en Python et les conventions pour définir des attributs et méthodes publics et privés.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHéritage en Python : Concept et intérêt\n\n\nDécouvrez le concept d’héritage en Python, son intérêt et son application dans la création de hiérarchies de classes. Apprenez comment Python gère l’héritage implicite de la…\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHéritage vs Composition\n\n\nDécouvrez les différences entre l’héritage et la composition en programmation orientée objet, leurs avantages et inconvénients, et comment choisir la meilleure approche pour…\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodes Dunder en Python\n\n\nDécouvrez les méthodes dunder en Python, des méthodes spéciales encadrées par des doubles tirets bas (__), qui permettent de personnaliser le comportement des objets dans…\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython call Method: A Fun Exploration\n\n\nExplore the quirky side of Python’s call method with fun examples and insights into memory allocation. A lighthearted break in our Python deep dive.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP: Dunder Method with Tensor for Automatic Differentiation\n\n\n\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP: Heritage avec le pricing d’option\n\n\n\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Encapsulation, Heritage, Composition et Dunder"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_option.html",
    "href": "content/Cours_4/TP_option.html",
    "title": "TP: Monte Carlo Option Pricing with Decorators",
    "section": "",
    "text": "In this practical exercise, we’ll create a Monte Carlo simulator for option pricing and use decorators to inject different payoff functions into the simulator. This approach will allow us to easily create and price various types of options using the same underlying simulation framework.\n\n\nWe want to build a system that can price different types of options using Monte Carlo simulation. The system should be flexible enough to handle various payoff structures without modifying the core simulation logic.\n\n\n\nFirst, let’s implement our base MonteCarloSimulator class:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nNow, implement a decorator called option_pricer. This decorator should:\n\nTake a payoff function as input\nCreate a new class that inherits from MonteCarloSimulator\nInject the input function as the payoff method of the new class\nReturn the new class\n\nHere’s the skeleton for the decorator:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nOnce you’ve implemented the decorator, you should be able to use it like this:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nImplement the option_pricer decorator to make the above code work.\nEnsure that the new classes created by the decorator inherit from MonteCarloSimulator.\nMake sure that the payoff method in the new classes calls the decorated function.\n\n\n\n\n\nYou can use type() to create a new class dynamically.\nThe payoff function will become a method, so it needs to take self as its first parameter.\nYou can use __name__ attribute of the function to name your new class.\nYou can use functools wraps to keep tracking of the base function\n\n\n\n\n\nModify the decorator to allow for additional parameters in the payoff function, such as strike price or barrier levels.\nImplement a more complex option type, such as an Asian option, where the payoff depends on the average stock price over the simulation period.\nAdd a method to calculate the standard error of the Monte Carlo estimate and use it to compute confidence intervals for the option prices.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Monte Carlo Option Pricing with Decorators"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_option.html#scenario-flexible-option-pricing-system",
    "href": "content/Cours_4/TP_option.html#scenario-flexible-option-pricing-system",
    "title": "TP: Monte Carlo Option Pricing with Decorators",
    "section": "",
    "text": "We want to build a system that can price different types of options using Monte Carlo simulation. The system should be flexible enough to handle various payoff structures without modifying the core simulation logic.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Monte Carlo Option Pricing with Decorators"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_option.html#step-1-implement-the-base-monte-carlo-simulator",
    "href": "content/Cours_4/TP_option.html#step-1-implement-the-base-monte-carlo-simulator",
    "title": "TP: Monte Carlo Option Pricing with Decorators",
    "section": "",
    "text": "First, let’s implement our base MonteCarloSimulator class:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Monte Carlo Option Pricing with Decorators"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_option.html#step-2-implement-the-decorator",
    "href": "content/Cours_4/TP_option.html#step-2-implement-the-decorator",
    "title": "TP: Monte Carlo Option Pricing with Decorators",
    "section": "",
    "text": "Now, implement a decorator called option_pricer. This decorator should:\n\nTake a payoff function as input\nCreate a new class that inherits from MonteCarloSimulator\nInject the input function as the payoff method of the new class\nReturn the new class\n\nHere’s the skeleton for the decorator:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Monte Carlo Option Pricing with Decorators"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_option.html#step-3-use-the-decorator",
    "href": "content/Cours_4/TP_option.html#step-3-use-the-decorator",
    "title": "TP: Monte Carlo Option Pricing with Decorators",
    "section": "",
    "text": "Once you’ve implemented the decorator, you should be able to use it like this:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Monte Carlo Option Pricing with Decorators"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_option.html#your-task",
    "href": "content/Cours_4/TP_option.html#your-task",
    "title": "TP: Monte Carlo Option Pricing with Decorators",
    "section": "",
    "text": "Implement the option_pricer decorator to make the above code work.\nEnsure that the new classes created by the decorator inherit from MonteCarloSimulator.\nMake sure that the payoff method in the new classes calls the decorated function.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Monte Carlo Option Pricing with Decorators"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_option.html#hints",
    "href": "content/Cours_4/TP_option.html#hints",
    "title": "TP: Monte Carlo Option Pricing with Decorators",
    "section": "",
    "text": "You can use type() to create a new class dynamically.\nThe payoff function will become a method, so it needs to take self as its first parameter.\nYou can use __name__ attribute of the function to name your new class.\nYou can use functools wraps to keep tracking of the base function",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Monte Carlo Option Pricing with Decorators"
    ]
  },
  {
    "objectID": "content/Cours_4/TP_option.html#bonus-challenges",
    "href": "content/Cours_4/TP_option.html#bonus-challenges",
    "title": "TP: Monte Carlo Option Pricing with Decorators",
    "section": "",
    "text": "Modify the decorator to allow for additional parameters in the payoff function, such as strike price or barrier levels.\nImplement a more complex option type, such as an Asian option, where the payoff depends on the average stock price over the simulation period.\nAdd a method to calculate the standard error of the Monte Carlo estimate and use it to compute confidence intervals for the option prices.",
    "crumbs": [
      "Travaux Pratiques",
      "TP: Monte Carlo Option Pricing with Decorators"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html",
    "href": "content/Cours_4/1-Design_Pattern.html",
    "title": "Design Patterns",
    "section": "",
    "text": "Design patterns are reusable solutions to common problems in software design. They represent best practices evolved over time by experienced software developers. Design patterns are not complete solutions or finished designs that can be transformed directly into code. Instead, they provide templates for how to solve a problem in various situations.\n\n\n\nThe concept of design patterns gained popularity in software engineering after the publication of the book “Design Patterns: Elements of Reusable Object-Oriented Software” by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (known as the “Gang of Four”) in 1994. However, the idea of patterns in design was introduced earlier by Christopher Alexander in the field of architecture.\n\n\n\n\nProvide tested, proven development paradigms\nSpeed up the development process by providing well-tested mechanisms\nPrevent subtle issues that can cause major problems\nImprove code readability for coders and architects familiar with the patterns\n\n\n\n\nGenerally, design patterns are categorized into three main types:\n\nCreational Patterns: These deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.\nStructural Patterns: These deal with object composition or the structure of classes. They help ensure that if one part of a system changes, the entire structure doesn’t need to change.\nBehavioral Patterns: These are concerned with communication between objects, how objects interact and distribute responsibility.\n\n\n\n\n\nReusability: Patterns provide proven solutions to common problems.\nCommon vocabulary: They provide a common language for developers to efficiently communicate.\nReduce complexity: By providing tested, optimized solutions, they can reduce the complexity of code.\nBest practices: They capture best practices developed through trial and error over a significant period.\n\n\n\n\n\nPatterns should not be forced: Use them only when they are the best fit for the problem at hand.\nUnderstanding the problem is crucial: Misapplying patterns can lead to unnecessary complexity.\nPatterns evolve: As programming paradigms change, so do design patterns.\n\n\n\n\n\nSingleton: Ensures a class has only one instance and provides a global point of access to it.\nFactory Method: Defines an interface for creating an object, but lets subclasses decide which class to instantiate.\nObserver: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\nDecorator: Attaches additional responsibilities to an object dynamically.\n\n\n\n\nDesign patterns are essential tools in a developer’s toolkit. They provide standardized solutions to common software design problems, promote code reuse, and establish a common language among developers. While they are powerful, it’s important to use them judiciously and appropriately based on the specific requirements of each project.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#what-are-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#what-are-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Design patterns are reusable solutions to common problems in software design. They represent best practices evolved over time by experienced software developers. Design patterns are not complete solutions or finished designs that can be transformed directly into code. Instead, they provide templates for how to solve a problem in various situations.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#origins-of-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#origins-of-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "The concept of design patterns gained popularity in software engineering after the publication of the book “Design Patterns: Elements of Reusable Object-Oriented Software” by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (known as the “Gang of Four”) in 1994. However, the idea of patterns in design was introduced earlier by Christopher Alexander in the field of architecture.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#purpose-of-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#purpose-of-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Provide tested, proven development paradigms\nSpeed up the development process by providing well-tested mechanisms\nPrevent subtle issues that can cause major problems\nImprove code readability for coders and architects familiar with the patterns",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#categories-of-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#categories-of-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Generally, design patterns are categorized into three main types:\n\nCreational Patterns: These deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.\nStructural Patterns: These deal with object composition or the structure of classes. They help ensure that if one part of a system changes, the entire structure doesn’t need to change.\nBehavioral Patterns: These are concerned with communication between objects, how objects interact and distribute responsibility.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#benefits-of-using-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#benefits-of-using-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Reusability: Patterns provide proven solutions to common problems.\nCommon vocabulary: They provide a common language for developers to efficiently communicate.\nReduce complexity: By providing tested, optimized solutions, they can reduce the complexity of code.\nBest practices: They capture best practices developed through trial and error over a significant period.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#considerations-when-using-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#considerations-when-using-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Patterns should not be forced: Use them only when they are the best fit for the problem at hand.\nUnderstanding the problem is crucial: Misapplying patterns can lead to unnecessary complexity.\nPatterns evolve: As programming paradigms change, so do design patterns.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#examples-of-common-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#examples-of-common-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Singleton: Ensures a class has only one instance and provides a global point of access to it.\nFactory Method: Defines an interface for creating an object, but lets subclasses decide which class to instantiate.\nObserver: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\nDecorator: Attaches additional responsibilities to an object dynamically.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#conclusion",
    "href": "content/Cours_4/1-Design_Pattern.html#conclusion",
    "title": "Design Patterns",
    "section": "",
    "text": "Design patterns are essential tools in a developer’s toolkit. They provide standardized solutions to common software design problems, promote code reuse, and establish a common language among developers. While they are powerful, it’s important to use them judiciously and appropriately based on the specific requirements of each project.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/5-library_decorators.html",
    "href": "content/Cours_4/5-library_decorators.html",
    "title": "Practical Decorators in Python Libraries",
    "section": "",
    "text": "This course builds upon your understanding of basic decorators and explores their practical usage in popular Python libraries. We’ll focus on FastAPI, Numba, and Pytest, explaining how to use their decorators effectively in your projects.\n\n\nFastAPI is a modern, fast web framework for building APIs with Python. It makes extensive use of decorators for routing, request handling, and more.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this expanded FastAPI example:\n\n@app.get(\"/\") defines a route for GET requests to the root URL. It returns a simple JSON response.\n@app.get(\"/items/{item_id}\") sets up a route with a path parameter item_id. The Path function is used to add validation and metadata to the path parameter. The Query function is used to define an optional query parameter q.\n@app.post(\"/items/\") defines a route for POST requests to create new items. It uses a Pydantic model Item for request body validation.\n\nFastAPI’s decorators handle several tasks automatically: - Route registration - Request parsing and validation - Dependency injection - Response serialization - Automatic API documentation generation\nThese decorators allow you to focus on your business logic while FastAPI handles the complexities of building a robust API.\n\n\n\n\nNumba is a Just-In-Time (JIT) compiler for Python that can significantly speed up numerical Python code by compiling it to native machine instructions.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe @jit(nopython=True) decorator tells Numba to compile the function to machine code without using the Python interpreter. This can lead to significant performance improvements, especially for numerical computations.\nImportant notes about Numba: - Numba compiles Python functions to optimized machine code at runtime. - It works best with numerical algorithms and NumPy arrays. - The nopython=True mode provides the best performance but has limitations on the Python features it supports. - Numba doesn’t support all Python types or features. It works best with simple numeric types, NumPy arrays, and a subset of Python and NumPy functions. - External libraries (except for NumPy and a few others) are generally not supported in Numba-compiled functions.\n\n\n\n\nPytest is a powerful testing framework for Python that uses decorators to enhance and customize test behavior.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this Pytest example:\n\n@pytest.fixture defines a fixture named example_fixture. Fixtures in Pytest are used to provide data or objects to tests.\n@pytest.mark.parametrize allows you to run the same test function multiple times with different inputs. It’s great for testing multiple scenarios without duplicating code.\n@pytest.mark.slow is a custom marker. You can use markers to categorize tests and selectively run them.\n\nPytest’s decorators allow you to: - Define and manage test fixtures - Parameterize tests for multiple inputs - Mark tests for organization and selective execution - Modify test behavior or skip tests based on conditions\nThese decorators make it easier to write comprehensive, maintainable test suites.\n\n\n\n\nDecorators in libraries like FastAPI, Numba, and Pytest showcase the power and flexibility of Python’s decorator system. They allow these libraries to provide clean, intuitive APIs that enhance productivity:\n\nFastAPI’s decorators simplify the process of building robust, well-documented APIs.\nNumba’s JIT decorator can dramatically speed up numerical computations, though with some limitations on supported Python features.\nPytest’s decorators make it easier to write, organize, and customize tests.\n\nBy understanding and leveraging these library-specific decorators, you can write more efficient, maintainable, and expressive Python code. Remember to consult each library’s documentation for the most up-to-date and detailed information on their decorator usage and capabilities.",
    "crumbs": [
      "Practical Decorators in Python Libraries"
    ]
  },
  {
    "objectID": "content/Cours_4/5-library_decorators.html#fastapi-decorators",
    "href": "content/Cours_4/5-library_decorators.html#fastapi-decorators",
    "title": "Practical Decorators in Python Libraries",
    "section": "",
    "text": "FastAPI is a modern, fast web framework for building APIs with Python. It makes extensive use of decorators for routing, request handling, and more.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this expanded FastAPI example:\n\n@app.get(\"/\") defines a route for GET requests to the root URL. It returns a simple JSON response.\n@app.get(\"/items/{item_id}\") sets up a route with a path parameter item_id. The Path function is used to add validation and metadata to the path parameter. The Query function is used to define an optional query parameter q.\n@app.post(\"/items/\") defines a route for POST requests to create new items. It uses a Pydantic model Item for request body validation.\n\nFastAPI’s decorators handle several tasks automatically: - Route registration - Request parsing and validation - Dependency injection - Response serialization - Automatic API documentation generation\nThese decorators allow you to focus on your business logic while FastAPI handles the complexities of building a robust API.",
    "crumbs": [
      "Practical Decorators in Python Libraries"
    ]
  },
  {
    "objectID": "content/Cours_4/5-library_decorators.html#numba-decorators",
    "href": "content/Cours_4/5-library_decorators.html#numba-decorators",
    "title": "Practical Decorators in Python Libraries",
    "section": "",
    "text": "Numba is a Just-In-Time (JIT) compiler for Python that can significantly speed up numerical Python code by compiling it to native machine instructions.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe @jit(nopython=True) decorator tells Numba to compile the function to machine code without using the Python interpreter. This can lead to significant performance improvements, especially for numerical computations.\nImportant notes about Numba: - Numba compiles Python functions to optimized machine code at runtime. - It works best with numerical algorithms and NumPy arrays. - The nopython=True mode provides the best performance but has limitations on the Python features it supports. - Numba doesn’t support all Python types or features. It works best with simple numeric types, NumPy arrays, and a subset of Python and NumPy functions. - External libraries (except for NumPy and a few others) are generally not supported in Numba-compiled functions.",
    "crumbs": [
      "Practical Decorators in Python Libraries"
    ]
  },
  {
    "objectID": "content/Cours_4/5-library_decorators.html#pytest-decorators",
    "href": "content/Cours_4/5-library_decorators.html#pytest-decorators",
    "title": "Practical Decorators in Python Libraries",
    "section": "",
    "text": "Pytest is a powerful testing framework for Python that uses decorators to enhance and customize test behavior.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this Pytest example:\n\n@pytest.fixture defines a fixture named example_fixture. Fixtures in Pytest are used to provide data or objects to tests.\n@pytest.mark.parametrize allows you to run the same test function multiple times with different inputs. It’s great for testing multiple scenarios without duplicating code.\n@pytest.mark.slow is a custom marker. You can use markers to categorize tests and selectively run them.\n\nPytest’s decorators allow you to: - Define and manage test fixtures - Parameterize tests for multiple inputs - Mark tests for organization and selective execution - Modify test behavior or skip tests based on conditions\nThese decorators make it easier to write comprehensive, maintainable test suites.",
    "crumbs": [
      "Practical Decorators in Python Libraries"
    ]
  },
  {
    "objectID": "content/Cours_4/5-library_decorators.html#conclusion",
    "href": "content/Cours_4/5-library_decorators.html#conclusion",
    "title": "Practical Decorators in Python Libraries",
    "section": "",
    "text": "Decorators in libraries like FastAPI, Numba, and Pytest showcase the power and flexibility of Python’s decorator system. They allow these libraries to provide clean, intuitive APIs that enhance productivity:\n\nFastAPI’s decorators simplify the process of building robust, well-documented APIs.\nNumba’s JIT decorator can dramatically speed up numerical computations, though with some limitations on supported Python features.\nPytest’s decorators make it easier to write, organize, and customize tests.\n\nBy understanding and leveraging these library-specific decorators, you can write more efficient, maintainable, and expressive Python code. Remember to consult each library’s documentation for the most up-to-date and detailed information on their decorator usage and capabilities.",
    "crumbs": [
      "Practical Decorators in Python Libraries"
    ]
  },
  {
    "objectID": "content/Cours_4/index.html",
    "href": "content/Cours_4/index.html",
    "title": "Decorators",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBuilt-in Decorators and Standard Library Decorators in Python\n\n\nLearn about built-in decorators and standard library decorators in Python, including @property, @classmethod, @staticmethod, @dataclass, and decorators from the functools…\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDecorator Practically\n\n\nLearn about decorators in Python with concrete examples, including basic function decorators, decorators with arguments, class decorators, decorators with parameters, and…\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDesign Patterns\n\n\nLearn about design patterns in software development, their purpose, benefits, and common categories, and understand how they provide reusable solutions to common problems in…\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPractical Decorators in Python Libraries\n\n\nExplore practical usage of decorators in popular Python libraries including FastAPI, Numba, and Pytest. Learn how to leverage these powerful tools in your Python projects.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP: Monte Carlo Option Pricing with Decorators\n\n\nA hands-on practical exercise on creating a decorator that injects payoff functions into a Monte Carlo option pricing simulator, exploring advanced concepts in Python and…\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP: Optimizing Heston Model Monte Carlo Simulation\n\n\nA hands-on practical exercise on optimizing Heston model Monte Carlo simulations using Numba and caching in Python.\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe decorator pattern\n\n\nLearn about the origins and evolution of the decorator pattern in programming, its key concepts, advantages over traditional inheritance, and its impact on modern…\n\n\n\nRemi Genet\n\n\n2024-09-01\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "content/Projets/m2_EIF_2024.html",
    "href": "content/Projets/m2_EIF_2024.html",
    "title": "Projets POO - Millésime 2024-2025",
    "section": "",
    "text": "TODO\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Projets POO - Millésime 2024-2025"
    ]
  },
  {
    "objectID": "content/Cours_5/2-Import.html",
    "href": "content/Cours_5/2-Import.html",
    "title": "Understanding imports",
    "section": "",
    "text": "When you use an import statement, Python searches for the module or package in several locations:\n\nThe directory containing the script\nPYTHONPATH (if set)\nStandard library directories\nSite-packages directory (for installed third-party packages)\n\nYou can view the current module search path using:\nimport sys\nprint(sys.path)\n\n\n\n\nPATH: An environment variable that tells the operating system where to look for executables.\nPYTHONPATH: An environment variable that adds additional directories to Python’s module search path.\n\n\n\n\nTo import modules from the current directory:\n\nRun Python from the directory containing your modules:\npython my_script.py\nAdd the current directory to PYTHONPATH:\nexport PYTHONPATH=$PYTHONPATH:.\nNB: $PYTHONPATH is the current value of PYTHONPATH, doing like this will append the current directory (which is defined by . in bash) to the existing PYTHONPATH.\nModify sys.path in your script:\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.realpath(__file__)))\n\n\n\n\n\nAbsolute imports use the full path from the project’s root:\nfrom mypackage.submodule import myfunction\nRelative imports use dots to refer to the current and parent packages:\nfrom . import sibling_module\nfrom .. import parent_package_module\n\nAbsolute imports are generally preferred for clarity.\nCertainly! I’ll enhance the section on importing modules vs specific items to include this important detail. Here’s an improved version of that section:\n\n\n\nWhen importing in Python, it’s important to understand the difference between importing entire modules and importing specific items from modules. This distinction affects not only how you use the imported elements but also how Python executes the import process.\n\nImporting a module:\nimport mymodule\nmymodule.my_function()\nImporting specific items:\nfrom mymodule import my_function\nmy_function()\n\nKey points to understand:\n\nModule Execution: When you import a module (either the entire module or specific items), Python first executes the entire module from top to bottom. This happens regardless of whether you’re importing the whole module or just specific functions or classes.\nNamespace Differences:\n\nWhen importing the entire module, you need to use the module name as a prefix to access its contents (e.g., mymodule.my_function()).\nWhen importing specific items, they are brought directly into the current namespace, allowing you to use them without the module prefix (e.g., my_function()).\n\nImport Process:\n\nFor import mymodule:\n\nPython executes all code in mymodule.\nIt creates a namespace for mymodule in the current scope.\nYou access items through this namespace (e.g., mymodule.my_function()).\n\nFor from mymodule import my_function:\n\nPython executes all code in mymodule.\nIt locates my_function within mymodule.\nIt creates a reference to my_function in the current namespace.\n\n\nPerformance and Memory:\n\nImporting specific items doesn’t save on initial execution time or memory, as the entire module is still executed.\nHowever, it can make your code slightly faster when accessing the imported items, as there’s no need to go through the module namespace.\n\nPotential Pitfalls:\n\nImporting specific items can lead to naming conflicts if you import items with the same name from different modules.\nIt can also make it less clear where a function or class is coming from when reading the code.\n\n\n\n\n\nThe __init__.py file marks a directory as a Python package. It can be empty or contain initialization code. When you import a package, the __init__.py file is executed.\n\n\n\nSimplifying imports for package users:\n\n# mypackage/__init__.py\n\nfrom .database import Database\nfrom .models import User, Product\nfrom .utils import format_currency\n\n__all__ = ['Database', 'User', 'Product', 'format_currency']\nThis allows users to do:\nfrom mypackage import Database, User, Product\nInstead of:\nfrom mypackage.database import Database\nfrom mypackage.models import User, Product\n\nInitializing package-level resources:\n\n# mypackage/__init__.py\n\nimport logging\n\n# Set up package-level logger\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\n# Initialize package-wide configurations\nCONFIG = {\n    'API_VERSION': 'v1',\n    'BASE_URL': 'https://api.example.com'\n}\n\n# Perform any necessary package initialization\ndef initialize():\n    logger.info(\"Initializing mypackage...\")\n    # Perform any startup tasks here\n\ninitialize()\n\nVersion information and metadata:\n\n# mypackage/__init__.py\n\n__version__ = \"1.0.0\"\n__author__ = \"Your Name\"\n__license__ = \"MIT\"\n\n# You can even load version from a separate file\nfrom .version import __version__\n\n\n\n\n\nPython first looks for built-in modules.\nIf not found, it searches in the directories listed in sys.path.\nFor a package, Python executes the __init__.py file.\nFor a module, Python executes the entire file.\n\n\n\n\n\nImporting a module:\nimport mymodule\nmymodule.my_function()\nImporting specific items:\nfrom mymodule import my_function\nmy_function()\n\nImporting the entire module executes it but requires using the module name as a prefix. Importing specific items brings them directly into the current namespace.\n\n\n\nCircular imports occur when two modules import each other, directly or indirectly. Here’s a realistic example and how to resolve it:\nProject structure:\nmyproject/\n├── __init__.py\n├── models.py\n├── services.py\n└── utils.py\n# models.py\nfrom .services import DataService\n\nclass User:\n    def __init__(self, username):\n        self.username = username\n    \n    def get_data(self):\n        return DataService.fetch_user_data(self.username)\n\n# services.py\nfrom .models import User\nfrom .utils import format_data\n\nclass DataService:\n    @staticmethod\n    def fetch_user_data(username):\n        # Simulate fetching data\n        data = {username: \"some data\"}\n        return format_data(data)\n\n    @staticmethod\n    def create_user(username):\n        return User(username)\n\n# utils.py\ndef format_data(data):\n    return str(data).upper()\nThis creates a circular import between models.py and services.py. Resolve it using __init__.py:\n# __init__.py\n\n# First, import modules that don't have dependencies\nfrom . import utils\n\n# Then import modules with dependencies, but don't use them yet\nfrom . import models\nfrom . import services\n\n# Now set up the references\nmodels.DataService = services.DataService\nservices.User = models.User\n\n# Optionally, clean up the namespace\ndel models, services\n\n# Expose what you want at the package level\nfrom .models import User\nfrom .services import DataService\nfrom .utils import format_data\n\n__all__ = ['User', 'DataService', 'format_data']\nNow, users can simply do:\nfrom myproject import User, DataService\n\nuser = User(\"alice\")\ndata = user.get_data()\nnew_user = DataService.create_user(\"bob\")\nThis approach: 1. Breaks the circular dependency by importing modules in a specific order. 2. Sets up the necessary references after all modules are loaded. 3. Provides a clean, easy-to-use interface for the package users.\n\n\n\nUnderstanding Python’s import system is crucial for structuring projects effectively. Proper use of __init__.py files, careful management of imports, and awareness of potential circular dependencies will help you create well-organized, maintainable Python packages.",
    "crumbs": [
      "Understanding imports"
    ]
  },
  {
    "objectID": "content/Cours_5/2-Import.html#understanding-python-imports-and-package-structure",
    "href": "content/Cours_5/2-Import.html#understanding-python-imports-and-package-structure",
    "title": "Understanding imports",
    "section": "",
    "text": "When you use an import statement, Python searches for the module or package in several locations:\n\nThe directory containing the script\nPYTHONPATH (if set)\nStandard library directories\nSite-packages directory (for installed third-party packages)\n\nYou can view the current module search path using:\nimport sys\nprint(sys.path)\n\n\n\n\nPATH: An environment variable that tells the operating system where to look for executables.\nPYTHONPATH: An environment variable that adds additional directories to Python’s module search path.\n\n\n\n\nTo import modules from the current directory:\n\nRun Python from the directory containing your modules:\npython my_script.py\nAdd the current directory to PYTHONPATH:\nexport PYTHONPATH=$PYTHONPATH:.\nNB: $PYTHONPATH is the current value of PYTHONPATH, doing like this will append the current directory (which is defined by . in bash) to the existing PYTHONPATH.\nModify sys.path in your script:\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.realpath(__file__)))\n\n\n\n\n\nAbsolute imports use the full path from the project’s root:\nfrom mypackage.submodule import myfunction\nRelative imports use dots to refer to the current and parent packages:\nfrom . import sibling_module\nfrom .. import parent_package_module\n\nAbsolute imports are generally preferred for clarity.\nCertainly! I’ll enhance the section on importing modules vs specific items to include this important detail. Here’s an improved version of that section:\n\n\n\nWhen importing in Python, it’s important to understand the difference between importing entire modules and importing specific items from modules. This distinction affects not only how you use the imported elements but also how Python executes the import process.\n\nImporting a module:\nimport mymodule\nmymodule.my_function()\nImporting specific items:\nfrom mymodule import my_function\nmy_function()\n\nKey points to understand:\n\nModule Execution: When you import a module (either the entire module or specific items), Python first executes the entire module from top to bottom. This happens regardless of whether you’re importing the whole module or just specific functions or classes.\nNamespace Differences:\n\nWhen importing the entire module, you need to use the module name as a prefix to access its contents (e.g., mymodule.my_function()).\nWhen importing specific items, they are brought directly into the current namespace, allowing you to use them without the module prefix (e.g., my_function()).\n\nImport Process:\n\nFor import mymodule:\n\nPython executes all code in mymodule.\nIt creates a namespace for mymodule in the current scope.\nYou access items through this namespace (e.g., mymodule.my_function()).\n\nFor from mymodule import my_function:\n\nPython executes all code in mymodule.\nIt locates my_function within mymodule.\nIt creates a reference to my_function in the current namespace.\n\n\nPerformance and Memory:\n\nImporting specific items doesn’t save on initial execution time or memory, as the entire module is still executed.\nHowever, it can make your code slightly faster when accessing the imported items, as there’s no need to go through the module namespace.\n\nPotential Pitfalls:\n\nImporting specific items can lead to naming conflicts if you import items with the same name from different modules.\nIt can also make it less clear where a function or class is coming from when reading the code.\n\n\n\n\n\nThe __init__.py file marks a directory as a Python package. It can be empty or contain initialization code. When you import a package, the __init__.py file is executed.\n\n\n\nSimplifying imports for package users:\n\n# mypackage/__init__.py\n\nfrom .database import Database\nfrom .models import User, Product\nfrom .utils import format_currency\n\n__all__ = ['Database', 'User', 'Product', 'format_currency']\nThis allows users to do:\nfrom mypackage import Database, User, Product\nInstead of:\nfrom mypackage.database import Database\nfrom mypackage.models import User, Product\n\nInitializing package-level resources:\n\n# mypackage/__init__.py\n\nimport logging\n\n# Set up package-level logger\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\n# Initialize package-wide configurations\nCONFIG = {\n    'API_VERSION': 'v1',\n    'BASE_URL': 'https://api.example.com'\n}\n\n# Perform any necessary package initialization\ndef initialize():\n    logger.info(\"Initializing mypackage...\")\n    # Perform any startup tasks here\n\ninitialize()\n\nVersion information and metadata:\n\n# mypackage/__init__.py\n\n__version__ = \"1.0.0\"\n__author__ = \"Your Name\"\n__license__ = \"MIT\"\n\n# You can even load version from a separate file\nfrom .version import __version__\n\n\n\n\n\nPython first looks for built-in modules.\nIf not found, it searches in the directories listed in sys.path.\nFor a package, Python executes the __init__.py file.\nFor a module, Python executes the entire file.\n\n\n\n\n\nImporting a module:\nimport mymodule\nmymodule.my_function()\nImporting specific items:\nfrom mymodule import my_function\nmy_function()\n\nImporting the entire module executes it but requires using the module name as a prefix. Importing specific items brings them directly into the current namespace.\n\n\n\nCircular imports occur when two modules import each other, directly or indirectly. Here’s a realistic example and how to resolve it:\nProject structure:\nmyproject/\n├── __init__.py\n├── models.py\n├── services.py\n└── utils.py\n# models.py\nfrom .services import DataService\n\nclass User:\n    def __init__(self, username):\n        self.username = username\n    \n    def get_data(self):\n        return DataService.fetch_user_data(self.username)\n\n# services.py\nfrom .models import User\nfrom .utils import format_data\n\nclass DataService:\n    @staticmethod\n    def fetch_user_data(username):\n        # Simulate fetching data\n        data = {username: \"some data\"}\n        return format_data(data)\n\n    @staticmethod\n    def create_user(username):\n        return User(username)\n\n# utils.py\ndef format_data(data):\n    return str(data).upper()\nThis creates a circular import between models.py and services.py. Resolve it using __init__.py:\n# __init__.py\n\n# First, import modules that don't have dependencies\nfrom . import utils\n\n# Then import modules with dependencies, but don't use them yet\nfrom . import models\nfrom . import services\n\n# Now set up the references\nmodels.DataService = services.DataService\nservices.User = models.User\n\n# Optionally, clean up the namespace\ndel models, services\n\n# Expose what you want at the package level\nfrom .models import User\nfrom .services import DataService\nfrom .utils import format_data\n\n__all__ = ['User', 'DataService', 'format_data']\nNow, users can simply do:\nfrom myproject import User, DataService\n\nuser = User(\"alice\")\ndata = user.get_data()\nnew_user = DataService.create_user(\"bob\")\nThis approach: 1. Breaks the circular dependency by importing modules in a specific order. 2. Sets up the necessary references after all modules are loaded. 3. Provides a clean, easy-to-use interface for the package users.\n\n\n\nUnderstanding Python’s import system is crucial for structuring projects effectively. Proper use of __init__.py files, careful management of imports, and awareness of potential circular dependencies will help you create well-organized, maintainable Python packages.",
    "crumbs": [
      "Understanding imports"
    ]
  },
  {
    "objectID": "content/Cours_5/1-Project_layout.html",
    "href": "content/Cours_5/1-Project_layout.html",
    "title": "Organizing Python Projects",
    "section": "",
    "text": "Python’s import system is fundamental to how we organize and use code across multiple files and directories. Understanding it is crucial for structuring projects effectively.\n\nWhen you use an import statement, Python searches for the module in several locations:\n\nThe directory containing the script\nPYTHONPATH (if set)\nStandard library directories\nSite-packages directory (for installed third-party packages)\n\n\n\n\n\n\nPATH: An environment variable that tells the operating system where to look for executables. It’s not directly related to Python imports but is important for running Python from the command line.\nPYTHONPATH: An environment variable that you can set to add additional directories where Python will look for modules and packages.\n\n\n\n\nTo import modules from the current directory, you have several options:\n\nRun Python from the directory containing your modules:\npython my_script.py\nAdd the current directory to PYTHONPATH:\nexport PYTHONPATH=$PYTHONPATH:.\nModify sys.path in your script:\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.realpath(__file__)))\n\n\n\n\nYou can view the current module search path using:\nimport sys\nprint(sys.path)\n\n\n\n\nAbsolute imports use the full path from the project’s root:\n\nfrom mypackage.submodule import myfunction\n\nRelative imports use dots to refer to the current and parent packages:\n\nfrom . import sibling_module\nfrom .. import parent_package_module\n\nGenerally, absolute imports are preferred for clarity and to avoid confusion.\n\n\n\n\n\nA well-organized project structure enhances readability and maintainability. Here’s a common layout:\nmy_project/\n│\n├── my_package/\n│   ├── __init__.py\n│   ├── module1.py\n│   └── module2.py\n│\n├── tests/\n│   ├── test_module1.py\n│   └── test_module2.py\n│\n├── docs/\n│   └── index.md\n│\n├── pyproject.toml\n└── README.md\nNote: Some projects use a src/ directory (e.g., src/my_package/) to separate package code. While this can be beneficial for larger projects or when building distributions, it’s not mandatory and can add complexity for smaller projects.\n\n\n\n\nSource Code (my_package/): Contains the actual package code\nTests (tests/): Keeps tests separate from source code\nDocumentation (docs/): Separates documentation from code\nProject Files: pyproject.toml for project configuration, README.md for project overview\n\n\n\n\nLet’s create a simple project structure:\n# Create project directory\nmkdir my_project\ncd my_project\n\n# Create package directory\nmkdir my_package\ntouch my_package/__init__.py\ntouch my_package/module1.py\n\n# Create tests directory\nmkdir tests\ntouch tests/test_module1.py\n\n# Create docs directory\nmkdir docs\ntouch docs/index.md\n\n# Create project files\ntouch pyproject.toml README.md\nThis structure sets the foundation for a well-organized Python project, making it easier to develop, test, and maintain your code.",
    "crumbs": [
      "Organizing Python Projects"
    ]
  },
  {
    "objectID": "content/Cours_5/1-Project_layout.html#understanding-python-imports-and-project-structure-45-minutes",
    "href": "content/Cours_5/1-Project_layout.html#understanding-python-imports-and-project-structure-45-minutes",
    "title": "Organizing Python Projects",
    "section": "",
    "text": "Python’s import system is fundamental to how we organize and use code across multiple files and directories. Understanding it is crucial for structuring projects effectively.\n\nWhen you use an import statement, Python searches for the module in several locations:\n\nThe directory containing the script\nPYTHONPATH (if set)\nStandard library directories\nSite-packages directory (for installed third-party packages)\n\n\n\n\n\n\nPATH: An environment variable that tells the operating system where to look for executables. It’s not directly related to Python imports but is important for running Python from the command line.\nPYTHONPATH: An environment variable that you can set to add additional directories where Python will look for modules and packages.\n\n\n\n\nTo import modules from the current directory, you have several options:\n\nRun Python from the directory containing your modules:\npython my_script.py\nAdd the current directory to PYTHONPATH:\nexport PYTHONPATH=$PYTHONPATH:.\nModify sys.path in your script:\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.realpath(__file__)))\n\n\n\n\nYou can view the current module search path using:\nimport sys\nprint(sys.path)\n\n\n\n\nAbsolute imports use the full path from the project’s root:\n\nfrom mypackage.submodule import myfunction\n\nRelative imports use dots to refer to the current and parent packages:\n\nfrom . import sibling_module\nfrom .. import parent_package_module\n\nGenerally, absolute imports are preferred for clarity and to avoid confusion.\n\n\n\n\n\nA well-organized project structure enhances readability and maintainability. Here’s a common layout:\nmy_project/\n│\n├── my_package/\n│   ├── __init__.py\n│   ├── module1.py\n│   └── module2.py\n│\n├── tests/\n│   ├── test_module1.py\n│   └── test_module2.py\n│\n├── docs/\n│   └── index.md\n│\n├── pyproject.toml\n└── README.md\nNote: Some projects use a src/ directory (e.g., src/my_package/) to separate package code. While this can be beneficial for larger projects or when building distributions, it’s not mandatory and can add complexity for smaller projects.\n\n\n\n\nSource Code (my_package/): Contains the actual package code\nTests (tests/): Keeps tests separate from source code\nDocumentation (docs/): Separates documentation from code\nProject Files: pyproject.toml for project configuration, README.md for project overview\n\n\n\n\nLet’s create a simple project structure:\n# Create project directory\nmkdir my_project\ncd my_project\n\n# Create package directory\nmkdir my_package\ntouch my_package/__init__.py\ntouch my_package/module1.py\n\n# Create tests directory\nmkdir tests\ntouch tests/test_module1.py\n\n# Create docs directory\nmkdir docs\ntouch docs/index.md\n\n# Create project files\ntouch pyproject.toml README.md\nThis structure sets the foundation for a well-organized Python project, making it easier to develop, test, and maintain your code.",
    "crumbs": [
      "Organizing Python Projects"
    ]
  },
  {
    "objectID": "content/Cours_5/3-Packaging_and_environment.html",
    "href": "content/Cours_5/3-Packaging_and_environment.html",
    "title": "Python Package Management and Virtual Environments",
    "section": "",
    "text": "When developing Python projects, managing dependencies and isolating environments are crucial. There are several tools available for these tasks:\n\n\n\npip: The standard package installer for Python.\nPoetry: A modern dependency management and packaging tool.\nConda: A package, dependency, and environment management system (popular in data science).\n\n\n\n\n\nvenv: Built-in Python module for creating virtual environments.\npyenv: Allows you to easily switch between multiple versions of Python.\nvirtualenv: A tool to create isolated Python environments (precursor to venv).\n\nLet’s focus on pip, venv, and an introduction to Poetry.\n\n\n\n\nCreate a virtual environment:\npython -m venv myenv\nActivate the environment:\n\nWindows: myenv\\Scripts\\activate\nmacOS/Linux: source myenv/bin/activate\n\nInstall packages:\npip install package_name\nCreate a requirements.txt file:\npip freeze &gt; requirements.txt\nInstall from requirements.txt:\npip install -r requirements.txt\n\n\n\n\nPoetry is a more modern tool that combines dependency management, package building, and publishing.\n\nInstall Poetry:\npip install poetry\nCreate a new project or initialize an existing one:\npoetry new myproject\n# or\npoetry init\nAdd dependencies:\npoetry add package_name\nInstall dependencies:\npoetry install\n\n\n\n\nPoetry uses pyproject.toml for project configuration. Here’s a simple example:\n[tool.poetry]\nname = \"myproject\"\nversion = \"0.1.0\"\ndescription = \"A sample Python project\"\nauthors = [\"Your Name &lt;you@example.com&gt;\"]\n\n[tool.poetry.dependencies]\npython = \"^3.9\"\nrequests = \"^2.26.0\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^6.2.5\"\nThis file defines your project’s metadata and dependencies.\n\n\n\nBuilding a package means creating a distribution that can be installed by pip. Publishing means uploading this distribution to a package index like PyPI.\n\nBuild your package:\npoetry build\nThis creates distribution files in the dist/ directory.\nPublish to PyPI:\npoetry publish\nThis uploads your built package to PyPI, making it available for others to install.\n\nPoetry simplifies these processes, handling the complexities of building and publishing for you.",
    "crumbs": [
      "Python Package Management and Virtual Environments"
    ]
  },
  {
    "objectID": "content/Cours_5/3-Packaging_and_environment.html#python-package-management-and-virtual-environments",
    "href": "content/Cours_5/3-Packaging_and_environment.html#python-package-management-and-virtual-environments",
    "title": "Python Package Management and Virtual Environments",
    "section": "",
    "text": "When developing Python projects, managing dependencies and isolating environments are crucial. There are several tools available for these tasks:\n\n\n\npip: The standard package installer for Python.\nPoetry: A modern dependency management and packaging tool.\nConda: A package, dependency, and environment management system (popular in data science).\n\n\n\n\n\nvenv: Built-in Python module for creating virtual environments.\npyenv: Allows you to easily switch between multiple versions of Python.\nvirtualenv: A tool to create isolated Python environments (precursor to venv).\n\nLet’s focus on pip, venv, and an introduction to Poetry.\n\n\n\n\nCreate a virtual environment:\npython -m venv myenv\nActivate the environment:\n\nWindows: myenv\\Scripts\\activate\nmacOS/Linux: source myenv/bin/activate\n\nInstall packages:\npip install package_name\nCreate a requirements.txt file:\npip freeze &gt; requirements.txt\nInstall from requirements.txt:\npip install -r requirements.txt\n\n\n\n\nPoetry is a more modern tool that combines dependency management, package building, and publishing.\n\nInstall Poetry:\npip install poetry\nCreate a new project or initialize an existing one:\npoetry new myproject\n# or\npoetry init\nAdd dependencies:\npoetry add package_name\nInstall dependencies:\npoetry install\n\n\n\n\nPoetry uses pyproject.toml for project configuration. Here’s a simple example:\n[tool.poetry]\nname = \"myproject\"\nversion = \"0.1.0\"\ndescription = \"A sample Python project\"\nauthors = [\"Your Name &lt;you@example.com&gt;\"]\n\n[tool.poetry.dependencies]\npython = \"^3.9\"\nrequests = \"^2.26.0\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^6.2.5\"\nThis file defines your project’s metadata and dependencies.\n\n\n\nBuilding a package means creating a distribution that can be installed by pip. Publishing means uploading this distribution to a package index like PyPI.\n\nBuild your package:\npoetry build\nThis creates distribution files in the dist/ directory.\nPublish to PyPI:\npoetry publish\nThis uploads your built package to PyPI, making it available for others to install.\n\nPoetry simplifies these processes, handling the complexities of building and publishing for you.",
    "crumbs": [
      "Python Package Management and Virtual Environments"
    ]
  },
  {
    "objectID": "content/Cours_6/TP.html",
    "href": "content/Cours_6/TP.html",
    "title": "TP",
    "section": "",
    "text": "TODO\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html",
    "href": "content/Cours_6/2-Creational_patterns.html",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "Creational design patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.\n\n\nThe Singleton pattern ensures a class has only one instance and provides a global point of access to it.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPros:\n\nEnsures a single instance\nGlobal access point\nLazy initialization\n\nCons:\n\nViolates Single Responsibility Principle\nCan make unit testing difficult\nCan hide bad design\n\n\n\n\n\n\nThe Factory Method pattern provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nProvides flexibility in object creation\nPromotes loose coupling\nAdheres to the Open/Closed Principle\nSimplifies adding new types of objects\n\n\n\n\n\nThe Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nEnsures compatibility between created objects\nIsolates concrete classes\nSimplifies exchanging product families\nPromotes consistency among products\n\n\n\n\n\nThe Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAllows step-by-step creation of complex objects\nCan use the same construction code for different representations\nIsolates complex construction code from business logic\n\n\n\n\n\nCreational design patterns solve problems related to object creation in software design. They provide flexibility, improve code reusability, and help manage complexity in object-oriented systems. Each pattern has its specific use cases, and understanding them allows developers to choose the right tool for the job when designing software systems.",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html#singleton-pattern",
    "href": "content/Cours_6/2-Creational_patterns.html#singleton-pattern",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "The Singleton pattern ensures a class has only one instance and provides a global point of access to it.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPros:\n\nEnsures a single instance\nGlobal access point\nLazy initialization\n\nCons:\n\nViolates Single Responsibility Principle\nCan make unit testing difficult\nCan hide bad design",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html#factory-method-pattern",
    "href": "content/Cours_6/2-Creational_patterns.html#factory-method-pattern",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "The Factory Method pattern provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nProvides flexibility in object creation\nPromotes loose coupling\nAdheres to the Open/Closed Principle\nSimplifies adding new types of objects",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html#abstract-factory-pattern",
    "href": "content/Cours_6/2-Creational_patterns.html#abstract-factory-pattern",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "The Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nEnsures compatibility between created objects\nIsolates concrete classes\nSimplifies exchanging product families\nPromotes consistency among products",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html#builder-pattern",
    "href": "content/Cours_6/2-Creational_patterns.html#builder-pattern",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAllows step-by-step creation of complex objects\nCan use the same construction code for different representations\nIsolates complex construction code from business logic",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html#conclusion",
    "href": "content/Cours_6/2-Creational_patterns.html#conclusion",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "Creational design patterns solve problems related to object creation in software design. They provide flexibility, improve code reusability, and help manage complexity in object-oriented systems. Each pattern has its specific use cases, and understanding them allows developers to choose the right tool for the job when designing software systems.",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html",
    "href": "content/Cours_6/4-behavioral_patterns.html",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects. They characterize complex control flow that’s difficult to follow at run-time.\n\n\nThe Observer pattern lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSupports the principle of loose coupling between objects\nAllows sending data to many objects efficiently\nDynamic relationships can be established between objects at runtime\n\n\n\n\n\nThe Strategy pattern lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAllows switching algorithms used inside an object at runtime\nIsolates the implementation details of an algorithm from the code that uses it\nReplaces inheritance with composition\n\n\n\n\n\nThe Command pattern turns a request into a stand-alone object that contains all information about the request.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDecouples classes that invoke operations from classes that perform these operations\nAllows creating sequences of commands with a macro command\nSupports undo operations\n\n\n\n\n\nThe State pattern lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nOrganizes code related to particular states into separate classes\nMakes state transitions explicit\nSimplifies the code by eliminating bulky state machine conditional statements\n\n\n\n\n\nThe Chain of Responsibility pattern lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nReduces coupling between components\nIncreases flexibility in assigning responsibilities to objects\nAllows adding or removing responsibilities dynamically\n\n\n\n\n\nThe Template Method pattern defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLets subclasses implement varying behavior\nAvoids code duplication\nAllows fine-grained control over the steps of an algorithm\n\n\n\n\n\nBehavioral design patterns are crucial for managing algorithms, relationships, and responsibilities between objects. They improve communication between objects, make complex control flows more manageable, and help distribute responsibilities efficiently. By applying these patterns, developers can create more flexible and maintainable code structures that are easier to understand and modify.",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#observer-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#observer-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The Observer pattern lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSupports the principle of loose coupling between objects\nAllows sending data to many objects efficiently\nDynamic relationships can be established between objects at runtime",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#strategy-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#strategy-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The Strategy pattern lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAllows switching algorithms used inside an object at runtime\nIsolates the implementation details of an algorithm from the code that uses it\nReplaces inheritance with composition",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#command-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#command-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The Command pattern turns a request into a stand-alone object that contains all information about the request.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDecouples classes that invoke operations from classes that perform these operations\nAllows creating sequences of commands with a macro command\nSupports undo operations",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#state-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#state-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The State pattern lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nOrganizes code related to particular states into separate classes\nMakes state transitions explicit\nSimplifies the code by eliminating bulky state machine conditional statements",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#chain-of-responsibility-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#chain-of-responsibility-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The Chain of Responsibility pattern lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nReduces coupling between components\nIncreases flexibility in assigning responsibilities to objects\nAllows adding or removing responsibilities dynamically",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#template-method-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#template-method-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The Template Method pattern defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLets subclasses implement varying behavior\nAvoids code duplication\nAllows fine-grained control over the steps of an algorithm",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#conclusion",
    "href": "content/Cours_6/4-behavioral_patterns.html#conclusion",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "Behavioral design patterns are crucial for managing algorithms, relationships, and responsibilities between objects. They improve communication between objects, make complex control flows more manageable, and help distribute responsibilities efficiently. By applying these patterns, developers can create more flexible and maintainable code structures that are easier to understand and modify.",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  }
]