[
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "Programmation Orientée Objet en Python: ",
    "section": "",
    "text": "Star this website on Github"
  },
  {
    "objectID": "index.html#rémi-genet",
    "href": "index.html#rémi-genet",
    "title": "Programmation Orientée Objet en Python: ",
    "section": "",
    "text": "Star this website on Github"
  },
  {
    "objectID": "content/Cours_6/TP.html",
    "href": "content/Cours_6/TP.html",
    "title": "TP",
    "section": "",
    "text": "TODO\n\n\n\n\n\n Back to top"
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html",
    "href": "content/Cours_6/2-Creational_patterns.html",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "Creational design patterns provide various object creation mechanisms, which increase flexibility and reuse of existing code.\n\n\nThe Singleton pattern ensures a class has only one instance and provides a global point of access to it.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPros:\n\nEnsures a single instance\nGlobal access point\nLazy initialization\n\nCons:\n\nViolates Single Responsibility Principle\nCan make unit testing difficult\nCan hide bad design\n\n\n\n\n\n\nThe Factory Method pattern provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nProvides flexibility in object creation\nPromotes loose coupling\nAdheres to the Open/Closed Principle\nSimplifies adding new types of objects\n\n\n\n\n\nThe Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nEnsures compatibility between created objects\nIsolates concrete classes\nSimplifies exchanging product families\nPromotes consistency among products\n\n\n\n\n\nThe Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAllows step-by-step creation of complex objects\nCan use the same construction code for different representations\nIsolates complex construction code from business logic\n\n\n\n\n\nCreational design patterns solve problems related to object creation in software design. They provide flexibility, improve code reusability, and help manage complexity in object-oriented systems. Each pattern has its specific use cases, and understanding them allows developers to choose the right tool for the job when designing software systems.",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html#singleton-pattern",
    "href": "content/Cours_6/2-Creational_patterns.html#singleton-pattern",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "The Singleton pattern ensures a class has only one instance and provides a global point of access to it.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPros:\n\nEnsures a single instance\nGlobal access point\nLazy initialization\n\nCons:\n\nViolates Single Responsibility Principle\nCan make unit testing difficult\nCan hide bad design",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html#factory-method-pattern",
    "href": "content/Cours_6/2-Creational_patterns.html#factory-method-pattern",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "The Factory Method pattern provides an interface for creating objects in a superclass, but allows subclasses to alter the type of objects that will be created.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nProvides flexibility in object creation\nPromotes loose coupling\nAdheres to the Open/Closed Principle\nSimplifies adding new types of objects",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html#abstract-factory-pattern",
    "href": "content/Cours_6/2-Creational_patterns.html#abstract-factory-pattern",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "The Abstract Factory pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nEnsures compatibility between created objects\nIsolates concrete classes\nSimplifies exchanging product families\nPromotes consistency among products",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html#builder-pattern",
    "href": "content/Cours_6/2-Creational_patterns.html#builder-pattern",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "The Builder pattern separates the construction of a complex object from its representation, allowing the same construction process to create different representations.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAllows step-by-step creation of complex objects\nCan use the same construction code for different representations\nIsolates complex construction code from business logic",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/2-Creational_patterns.html#conclusion",
    "href": "content/Cours_6/2-Creational_patterns.html#conclusion",
    "title": "Creation Design Patterns",
    "section": "",
    "text": "Creational design patterns solve problems related to object creation in software design. They provide flexibility, improve code reusability, and help manage complexity in object-oriented systems. Each pattern has its specific use cases, and understanding them allows developers to choose the right tool for the job when designing software systems.",
    "crumbs": [
      "Creation Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/1-Python_Design_Pattern.html",
    "href": "content/Cours_6/1-Python_Design_Pattern.html",
    "title": "Python-Specific Design Patterns",
    "section": "",
    "text": "Context managers in Python provide a clean way to manage resources, ensuring proper acquisition and release.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation of __exit__ parameters: - exc_type: The type of the exception that occurred, or None if no exception occurred. - exc_value: The exception instance, or None if no exception occurred. - traceback: A traceback object, or None if no exception occurred.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDescriptors provide a way to customize attribute access in Python classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation of __get__ parameters: - obj: The instance that the attribute was accessed through, or None when the attribute is accessed through the class. - objtype: The class that was used to access the attribute. This is set even when called on an instance.\nThe difference between __get__ and getattr: - __get__ is a method of the descriptor object itself. It’s called when accessing an attribute that is a descriptor. - getattr is a built-in function that retrieves an attribute from an object. Inside __get__, we often use getattr to access the actual stored value.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, let’s break down how this works step by step:\n\nWhen @LazyProperty is applied to the data method in DataProcessor:\n\nAn instance of LazyProperty is created, with the data method as its function attribute.\nThis LazyProperty instance replaces the data method in the class dictionary.\n\nWhen we create a DataProcessor instance:\n\nNo data is loaded yet. The filename is stored, but data is not accessed.\n\nThe first time processor.data is accessed:\n\nPython sees that data is a descriptor (it has a __get__ method) and calls LazyProperty.__get__(processor, DataProcessor).\nInside __get__:\n\nIt checks if obj (processor) is None. It’s not, so it continues.\nIt calls self.function(obj), which is equivalent to calling the original data method.\nThis prints “Loading data…” and reads the file.\nThe result is stored back into the processor instance using setattr(obj, self.name, value).\nThe value is returned.\n\n\nThe second time processor.data is accessed:\n\nPython first looks for an instance attribute named data.\nIt finds one (because we set it in step 3d), so it returns that value directly.\nThe LazyProperty.__get__ method is not called this time.\n\n\nThe key point is that after the first access, the LazyProperty descriptor is effectively replaced by the computed value. This is why the “Loading data…” message only appears once.\nThese examples demonstrate how context managers and descriptors can be used to create more robust, efficient, and Pythonic code. Context managers excel at resource management, while descriptors offer powerful ways to customize attribute behavior.",
    "crumbs": [
      "Python-Specific Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/1-Python_Design_Pattern.html#context-managers",
    "href": "content/Cours_6/1-Python_Design_Pattern.html#context-managers",
    "title": "Python-Specific Design Patterns",
    "section": "",
    "text": "Context managers in Python provide a clean way to manage resources, ensuring proper acquisition and release.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation of __exit__ parameters: - exc_type: The type of the exception that occurred, or None if no exception occurred. - exc_value: The exception instance, or None if no exception occurred. - traceback: A traceback object, or None if no exception occurred.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python-Specific Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/1-Python_Design_Pattern.html#descriptors",
    "href": "content/Cours_6/1-Python_Design_Pattern.html#descriptors",
    "title": "Python-Specific Design Patterns",
    "section": "",
    "text": "Descriptors provide a way to customize attribute access in Python classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nExplanation of __get__ parameters: - obj: The instance that the attribute was accessed through, or None when the attribute is accessed through the class. - objtype: The class that was used to access the attribute. This is set even when called on an instance.\nThe difference between __get__ and getattr: - __get__ is a method of the descriptor object itself. It’s called when accessing an attribute that is a descriptor. - getattr is a built-in function that retrieves an attribute from an object. Inside __get__, we often use getattr to access the actual stored value.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNow, let’s break down how this works step by step:\n\nWhen @LazyProperty is applied to the data method in DataProcessor:\n\nAn instance of LazyProperty is created, with the data method as its function attribute.\nThis LazyProperty instance replaces the data method in the class dictionary.\n\nWhen we create a DataProcessor instance:\n\nNo data is loaded yet. The filename is stored, but data is not accessed.\n\nThe first time processor.data is accessed:\n\nPython sees that data is a descriptor (it has a __get__ method) and calls LazyProperty.__get__(processor, DataProcessor).\nInside __get__:\n\nIt checks if obj (processor) is None. It’s not, so it continues.\nIt calls self.function(obj), which is equivalent to calling the original data method.\nThis prints “Loading data…” and reads the file.\nThe result is stored back into the processor instance using setattr(obj, self.name, value).\nThe value is returned.\n\n\nThe second time processor.data is accessed:\n\nPython first looks for an instance attribute named data.\nIt finds one (because we set it in step 3d), so it returns that value directly.\nThe LazyProperty.__get__ method is not called this time.\n\n\nThe key point is that after the first access, the LazyProperty descriptor is effectively replaced by the computed value. This is why the “Loading data…” message only appears once.\nThese examples demonstrate how context managers and descriptors can be used to create more robust, efficient, and Pythonic code. Context managers excel at resource management, while descriptors offer powerful ways to customize attribute behavior.",
    "crumbs": [
      "Python-Specific Design Patterns"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html",
    "href": "content/Projets/L3_EIF_2024.html",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "",
    "text": "Dans le cadre de votre formation en L3 Économie et Ingénierie Financière, une série de sujets de projets vous sont proposés. Ces projets visent à consolider vos connaissances théoriques et à développer vos compétences pratiques. Ces projets sont conçus pour renforcer vos connaissances théoriques tout en développant vos compétences pratiques. Ils représentent une occasion précieuse de vous préparer aux défis réels que vous rencontrerez dans votre future carrière professionnelle.\nVous êtes encouragés à choisir un sujet qui correspond à vos intérêts personnels et à vos aspirations professionnelles. Les thèmes proposés couvrent une variété de domaines, reflétant ainsi les diverses opportunités qui pourraient se présenter à vous dans le futur. Ils ont été soigneusement sélectionnés pour leur pertinence pratique et leur valeur pédagogique.\nNéanmoins, cette liste de sujets n’est pas exhaustive. Vous êtes libres et même encouragés à proposer vos propres idées de projets. Vos suggestions peuvent être envoyées par mail pour validation, afin de s’assurer de leur faisabilité et de leur adéquation avec les objectifs du cours. Bien que ce soit principalement un cours de programmation, les projets qui s’éloignent du domaine financier tout en intégrant les concepts abordés en cours sont également bienvenus.\nLa date limite de soumission des projets est fixée au 28 avril. Veuillez noter qu’un malus pour retard de soumission sera appliqué selon la formule suivante : (((x/25) - 1) %), où (x) représente le nombre de jours de retard.\nLes projets doivent être soumis par mail à remi.gnt@gmail.com. Il est préférable d’envoyer votre travail sous forme de fichier zip, mais un lien vers un Google Drive est également acceptable. Veuillez éviter les plateformes d’envoi telles que WeTransfer, qui ont une durée de téléchargement limitée.\nDe plus, il est vivement conseillé de soumettre votre projet via GitHub. Envoyer un simple mail avec un lien vers votre projet GitHub ou m’inviter à rejoindre votre dépôt (username GitHub : remigenet) peut vous faire bénéficier de points bonus. Un point bonus sera attribué à chaque groupe soumettant sur GitHub, et deux points supplémentaires si l’utilisation de GitHub montre un travail d’équipe effectif tout au long du projet. Pour faciliter l’organisation, j’ai créé un espace sur GitHub pour regrouper les projets : https://github.com/L3-EIF-2023. Vous pouvez demander à être ajouté à cette organisation et y déposer votre projet.\nCe projet est également une excellente opportunité d’enrichir votre CV. Un travail de qualité, rendu public sur votre compte GitHub, démontre non seulement vos compétences en programmation, mais aussi votre capacité à travailler en équipe. Pour ceux qui cherchent bientôt une alternance, c’est un avantage considérable.\nEnfin, le poids du projets dans la note finale sera de 75% à 100%, en effet le QCM de cours ne sera pris en compte que si la note est supérieure à la note du projet.\n\n\n\n\n\nDans le domaine des contrats dérivés, il est essentiel de comprendre que chaque contrat, qu’il s’agisse d’un future, d’un perpétuel, d’une option ou de toute autre structure plus exotique, représente un engagement entre deux parties. La valeur et, par conséquent, le prix d’échange de ces contrats sont déterminés par les termes et conditions spécifiques qu’ils contiennent.\n\nContrat Perpétuel vs Spot :\n\nContrat Perpétuel : Ce type de contrat à terme, couramment utilisé dans les marchés de dérivés et en particulier dans les crypto-monnaies, se distingue des contrats à terme traditionnels par l’absence de date d’expiration. Son objectif principal est de suivre le prix du marché au comptant (spot). Pour ce faire, il utilise des taux de financement qui ajustent régulièrement son prix afin de le maintenir aligné avec le marché spot.\nTaux de Financement : Ces taux jouent un rôle crucial dans la garantie que le prix du contrat perpétuel reste en adéquation avec le marché au comptant. Leur valeur peut varier, devenant positive ou négative en fonction de la dynamique du marché, notamment en situations de contango ou de backwardation.\nMarché Spot : Il s’agit du marché où les actifs, comme le Bitcoin, sont échangés pour une livraison immédiate. La fongibilité de ce marché entre les différentes plateformes d’échange permet une grande flexibilité dans l’achat et la vente d’actifs.\n\nPosition Longue sur Contrat Dérivé : Prendre une position longue dans un contrat dérivé signifie s’engager à acheter un actif, basé sur la spéculation que la valeur de l’actif sous-jacent augmentera. Cette position est différente de l’achat direct d’actifs sur le marché spot.\nCollatéral et Haircut :\n\nLe collatéral est un élément clé dans la sécurisation des positions prises dans les contrats dérivés. Sa proportion requise peut varier selon la taille et le risque de la position.\nLe terme “haircut” appliqué au collatéral non-USD fait référence à la réduction de la valeur du collatéral pour compenser le risque de change associé.\n\n\nEn résumé, la valeur intrinsèque d’un contrat dérivé découle des conditions spécifiques qu’il impose, avec le contrat perpétuel servant d’exemple principal où les taux de financement sont les clauses permettant de synchroniser son prix avec celui du marché spot.\n\n\n\nL’objectif principal est de comparer les coûts d’une position longue sur un contrat perpétuel avec ceux de l’achat direct de l’actif sur le marché spot. Les aspects suivants seront pris en compte :\n\nPour 2 Personnes :\n\nCalcul sous l’hypothèse d’un besoin en liquidité équivalent à 25% en tant que collatéral (marge initiale). La comparaison inclura les éventuelles différences de prix entre le contrat perpétuel et le marché spot lors de l’ouverture et de la fermeture de la position, en tenant compte des taux de financement historiques.\n\nPour 3 Personnes :\n\nIntégration des contraintes de couverture (en se basant sur celles d’une plateforme d’échange spécifique), avec une analyse des variations des exigences en collatéral en fonction de la taille de la position. Il sera également pris en compte le fait que la position sur le marché spot ne peut pas couvrir la position future, ainsi que les coûts de financement pour les USD engagés.\n\nPour 4 Personnes :\n\nLa récupération des données doit être intégrée dans les classes développées, avec la mise en œuvre d’un système de cache pour optimiser l’efficacité du traitement des données. L’objectif est de rendre l’utilisation de la classe aussi simple que possible pour l’utilisateur.\n\nPour 5 Personnes :\n\nAnalyse de la stratégie de cash and carry en utilisant un contrat perpétuel.\nStratégie de Cash and Carry avec Contrat Perpétuel : Cette approche implique la comparaison entre l’achat d’un actif sur le marché spot et sa vente simultanée via un contrat perpétuel, en comprenant les risques potentiels associés à cette stratégie.\n\nPour 6-7 Personnes :\n\nEn tenant compte de tous les éléments mentionnés précédemment, y compris les contraintes de collatéral imposées par l’exchange et un montant initial en dollars qui ne peut être augmenté, réaliser un backtest de la stratégie de cash and carry. Ce test prendra en compte la taille initiale de la position, qui dépendra du levier choisi initialement. En cas de rapprochement de la position courte sur le contrat perpétuel de sa marge de maintenance, simuler une réduction des positions par vente partielle sur le marché spot (réalisation des plus-values) et un rachat partiel sur le contrat dérivé (réalisation des moins-values), en utilisant un prix de clôture pour les deux positions basé sur le VWAP (Volume Weighted Average Price) sur une période où la participation au volume ne dépasse pas 10% du volume total.\n\n\n\n\n\n\n\n\nUn backtest est une méthode utilisée dans le domaine de la finance pour évaluer la viabilité et la performance d’une stratégie d’investissement. Cette technique implique de simuler la manière dont une stratégie aurait performé en utilisant des données historiques. Le but est de fournir un aperçu de la façon dont une stratégie aurait réagi dans différentes conditions de marché passées.\n\n\n\nÉvaluation des Stratégies : Le backtest permet aux traders et aux investisseurs de tester leurs stratégies sur des données passées avant de les appliquer dans des conditions réelles de marché. C’est un outil essentiel pour identifier les forces et les faiblesses d’une stratégie avant son déploiement.\nRéduction des Risques : En testant une stratégie sur des données historiques, les investisseurs peuvent mieux comprendre et gérer les risques potentiels.\nOptimisation des Stratégies : Les résultats d’un backtest peuvent être utilisés pour affiner et améliorer une stratégie, en ajustant ses paramètres pour maximiser les rendements potentiels.\n\n\n\n\nBien que le backtest soit un outil puissant, il est important de reconnaître ses limites. Les résultats d’un backtest sont toujours basés sur des hypothèses et des simulations, et ne peuvent garantir des performances futures. Les limitations clés incluent :\n\nHypothèses de Simulation : Un backtest repose sur des hypothèses qui peuvent ne pas être entièrement représentatives des conditions réelles du marché.\nBiais de Survie : Les données historiques peuvent exclure les actifs ou stratégies qui ont échoué dans le passé, conduisant à une perception faussée de la performance.\nChangements du Marché : Les conditions de marché évoluent constamment, et une stratégie qui a réussi dans le passé pourrait ne pas être aussi efficace dans le futur en raison de changements dans les dynamiques du marché.\n\n\n\n\nDévelopper un backtester sous forme de classe, qui utilise une fonction prenant en entrée un historique de barres OHLCV (Open, High, Low, Close, Volume) et renvoyant la position d’une stratégie d’investissement.\n\n\n\n\n\nPour 2 Personnes :\n\nStockage Local des Données : Les données seront stockées localement et incluses dans le projet pour faciliter les tests.\nAnalyse d’Un Actif : Le backtester se concentrera sur un seul actif avec des positions variant entre -100% et 100%.\nRésultats : Génération d’un graphique représentant la performance de la stratégie sur la période choisie, accompagné de statistiques de base telles que le rendement moyen, la variance, et le bêta.\n\nPour 3 Personnes (Option A) :\n\nStratégie sur Plusieurs Actifs : Extension du backtester pour accepter une fonction de stratégie applicable à plusieurs actifs.\nStatistiques Avancées : Calcul de statistiques plus élaborées comme le bêta en hausse et en baisse, le drawdown maximal, s’inspirant de sources telles que Quantalys ou Morningstar.\n\nOU\nPour 3 Personnes (Option B) :\n\nTéléchargement et Cache Asynchrone : Mise en place d’un système pour le téléchargement et le stockage en cache des données de manière asynchrone.\n\nPour 4 Personnes :\n\nCombinaison des points mentionnés dans les options pour 3 personnes (Option A et B).\n\nPour 5 Personnes :\n\nIntégration des Crypto-monnaies : Ajout de la capacité à analyser les stratégies impliquant des contrats dérivés perpétuels ou futurs.\nSpécificités des Dérivés :\n\nPour les contrats perpétuels, le calcul inclura le coût du taux de financement.\nPour les contrats futurs, le calcul se basera sur le rollover, en utilisant le VWAP (Volume Weighted Average Price) sur une journée comme prix de rollover.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#introduction",
    "href": "content/Projets/L3_EIF_2024.html#introduction",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "",
    "text": "Dans le cadre de votre formation en L3 Économie et Ingénierie Financière, une série de sujets de projets vous sont proposés. Ces projets visent à consolider vos connaissances théoriques et à développer vos compétences pratiques. Ces projets sont conçus pour renforcer vos connaissances théoriques tout en développant vos compétences pratiques. Ils représentent une occasion précieuse de vous préparer aux défis réels que vous rencontrerez dans votre future carrière professionnelle.\nVous êtes encouragés à choisir un sujet qui correspond à vos intérêts personnels et à vos aspirations professionnelles. Les thèmes proposés couvrent une variété de domaines, reflétant ainsi les diverses opportunités qui pourraient se présenter à vous dans le futur. Ils ont été soigneusement sélectionnés pour leur pertinence pratique et leur valeur pédagogique.\nNéanmoins, cette liste de sujets n’est pas exhaustive. Vous êtes libres et même encouragés à proposer vos propres idées de projets. Vos suggestions peuvent être envoyées par mail pour validation, afin de s’assurer de leur faisabilité et de leur adéquation avec les objectifs du cours. Bien que ce soit principalement un cours de programmation, les projets qui s’éloignent du domaine financier tout en intégrant les concepts abordés en cours sont également bienvenus.\nLa date limite de soumission des projets est fixée au 28 avril. Veuillez noter qu’un malus pour retard de soumission sera appliqué selon la formule suivante : (((x/25) - 1) %), où (x) représente le nombre de jours de retard.\nLes projets doivent être soumis par mail à remi.gnt@gmail.com. Il est préférable d’envoyer votre travail sous forme de fichier zip, mais un lien vers un Google Drive est également acceptable. Veuillez éviter les plateformes d’envoi telles que WeTransfer, qui ont une durée de téléchargement limitée.\nDe plus, il est vivement conseillé de soumettre votre projet via GitHub. Envoyer un simple mail avec un lien vers votre projet GitHub ou m’inviter à rejoindre votre dépôt (username GitHub : remigenet) peut vous faire bénéficier de points bonus. Un point bonus sera attribué à chaque groupe soumettant sur GitHub, et deux points supplémentaires si l’utilisation de GitHub montre un travail d’équipe effectif tout au long du projet. Pour faciliter l’organisation, j’ai créé un espace sur GitHub pour regrouper les projets : https://github.com/L3-EIF-2023. Vous pouvez demander à être ajouté à cette organisation et y déposer votre projet.\nCe projet est également une excellente opportunité d’enrichir votre CV. Un travail de qualité, rendu public sur votre compte GitHub, démontre non seulement vos compétences en programmation, mais aussi votre capacité à travailler en équipe. Pour ceux qui cherchent bientôt une alternance, c’est un avantage considérable.\nEnfin, le poids du projets dans la note finale sera de 75% à 100%, en effet le QCM de cours ne sera pris en compte que si la note est supérieure à la note du projet.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#sujet-a-analyse-de-contrat-perpétuel-vs-spot-pour-position-longue",
    "href": "content/Projets/L3_EIF_2024.html#sujet-a-analyse-de-contrat-perpétuel-vs-spot-pour-position-longue",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "",
    "text": "Dans le domaine des contrats dérivés, il est essentiel de comprendre que chaque contrat, qu’il s’agisse d’un future, d’un perpétuel, d’une option ou de toute autre structure plus exotique, représente un engagement entre deux parties. La valeur et, par conséquent, le prix d’échange de ces contrats sont déterminés par les termes et conditions spécifiques qu’ils contiennent.\n\nContrat Perpétuel vs Spot :\n\nContrat Perpétuel : Ce type de contrat à terme, couramment utilisé dans les marchés de dérivés et en particulier dans les crypto-monnaies, se distingue des contrats à terme traditionnels par l’absence de date d’expiration. Son objectif principal est de suivre le prix du marché au comptant (spot). Pour ce faire, il utilise des taux de financement qui ajustent régulièrement son prix afin de le maintenir aligné avec le marché spot.\nTaux de Financement : Ces taux jouent un rôle crucial dans la garantie que le prix du contrat perpétuel reste en adéquation avec le marché au comptant. Leur valeur peut varier, devenant positive ou négative en fonction de la dynamique du marché, notamment en situations de contango ou de backwardation.\nMarché Spot : Il s’agit du marché où les actifs, comme le Bitcoin, sont échangés pour une livraison immédiate. La fongibilité de ce marché entre les différentes plateformes d’échange permet une grande flexibilité dans l’achat et la vente d’actifs.\n\nPosition Longue sur Contrat Dérivé : Prendre une position longue dans un contrat dérivé signifie s’engager à acheter un actif, basé sur la spéculation que la valeur de l’actif sous-jacent augmentera. Cette position est différente de l’achat direct d’actifs sur le marché spot.\nCollatéral et Haircut :\n\nLe collatéral est un élément clé dans la sécurisation des positions prises dans les contrats dérivés. Sa proportion requise peut varier selon la taille et le risque de la position.\nLe terme “haircut” appliqué au collatéral non-USD fait référence à la réduction de la valeur du collatéral pour compenser le risque de change associé.\n\n\nEn résumé, la valeur intrinsèque d’un contrat dérivé découle des conditions spécifiques qu’il impose, avec le contrat perpétuel servant d’exemple principal où les taux de financement sont les clauses permettant de synchroniser son prix avec celui du marché spot.\n\n\n\nL’objectif principal est de comparer les coûts d’une position longue sur un contrat perpétuel avec ceux de l’achat direct de l’actif sur le marché spot. Les aspects suivants seront pris en compte :\n\nPour 2 Personnes :\n\nCalcul sous l’hypothèse d’un besoin en liquidité équivalent à 25% en tant que collatéral (marge initiale). La comparaison inclura les éventuelles différences de prix entre le contrat perpétuel et le marché spot lors de l’ouverture et de la fermeture de la position, en tenant compte des taux de financement historiques.\n\nPour 3 Personnes :\n\nIntégration des contraintes de couverture (en se basant sur celles d’une plateforme d’échange spécifique), avec une analyse des variations des exigences en collatéral en fonction de la taille de la position. Il sera également pris en compte le fait que la position sur le marché spot ne peut pas couvrir la position future, ainsi que les coûts de financement pour les USD engagés.\n\nPour 4 Personnes :\n\nLa récupération des données doit être intégrée dans les classes développées, avec la mise en œuvre d’un système de cache pour optimiser l’efficacité du traitement des données. L’objectif est de rendre l’utilisation de la classe aussi simple que possible pour l’utilisateur.\n\nPour 5 Personnes :\n\nAnalyse de la stratégie de cash and carry en utilisant un contrat perpétuel.\nStratégie de Cash and Carry avec Contrat Perpétuel : Cette approche implique la comparaison entre l’achat d’un actif sur le marché spot et sa vente simultanée via un contrat perpétuel, en comprenant les risques potentiels associés à cette stratégie.\n\nPour 6-7 Personnes :\n\nEn tenant compte de tous les éléments mentionnés précédemment, y compris les contraintes de collatéral imposées par l’exchange et un montant initial en dollars qui ne peut être augmenté, réaliser un backtest de la stratégie de cash and carry. Ce test prendra en compte la taille initiale de la position, qui dépendra du levier choisi initialement. En cas de rapprochement de la position courte sur le contrat perpétuel de sa marge de maintenance, simuler une réduction des positions par vente partielle sur le marché spot (réalisation des plus-values) et un rachat partiel sur le contrat dérivé (réalisation des moins-values), en utilisant un prix de clôture pour les deux positions basé sur le VWAP (Volume Weighted Average Price) sur une période où la participation au volume ne dépasse pas 10% du volume total.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#sujet-b-introduction-aux-concepts-clés-du-projet-de-backtester-pour-stratégies-dinvestissement",
    "href": "content/Projets/L3_EIF_2024.html#sujet-b-introduction-aux-concepts-clés-du-projet-de-backtester-pour-stratégies-dinvestissement",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "",
    "text": "Un backtest est une méthode utilisée dans le domaine de la finance pour évaluer la viabilité et la performance d’une stratégie d’investissement. Cette technique implique de simuler la manière dont une stratégie aurait performé en utilisant des données historiques. Le but est de fournir un aperçu de la façon dont une stratégie aurait réagi dans différentes conditions de marché passées.\n\n\n\nÉvaluation des Stratégies : Le backtest permet aux traders et aux investisseurs de tester leurs stratégies sur des données passées avant de les appliquer dans des conditions réelles de marché. C’est un outil essentiel pour identifier les forces et les faiblesses d’une stratégie avant son déploiement.\nRéduction des Risques : En testant une stratégie sur des données historiques, les investisseurs peuvent mieux comprendre et gérer les risques potentiels.\nOptimisation des Stratégies : Les résultats d’un backtest peuvent être utilisés pour affiner et améliorer une stratégie, en ajustant ses paramètres pour maximiser les rendements potentiels.\n\n\n\n\nBien que le backtest soit un outil puissant, il est important de reconnaître ses limites. Les résultats d’un backtest sont toujours basés sur des hypothèses et des simulations, et ne peuvent garantir des performances futures. Les limitations clés incluent :\n\nHypothèses de Simulation : Un backtest repose sur des hypothèses qui peuvent ne pas être entièrement représentatives des conditions réelles du marché.\nBiais de Survie : Les données historiques peuvent exclure les actifs ou stratégies qui ont échoué dans le passé, conduisant à une perception faussée de la performance.\nChangements du Marché : Les conditions de marché évoluent constamment, et une stratégie qui a réussi dans le passé pourrait ne pas être aussi efficace dans le futur en raison de changements dans les dynamiques du marché.\n\n\n\n\nDévelopper un backtester sous forme de classe, qui utilise une fonction prenant en entrée un historique de barres OHLCV (Open, High, Low, Close, Volume) et renvoyant la position d’une stratégie d’investissement.\n\n\n\n\n\nPour 2 Personnes :\n\nStockage Local des Données : Les données seront stockées localement et incluses dans le projet pour faciliter les tests.\nAnalyse d’Un Actif : Le backtester se concentrera sur un seul actif avec des positions variant entre -100% et 100%.\nRésultats : Génération d’un graphique représentant la performance de la stratégie sur la période choisie, accompagné de statistiques de base telles que le rendement moyen, la variance, et le bêta.\n\nPour 3 Personnes (Option A) :\n\nStratégie sur Plusieurs Actifs : Extension du backtester pour accepter une fonction de stratégie applicable à plusieurs actifs.\nStatistiques Avancées : Calcul de statistiques plus élaborées comme le bêta en hausse et en baisse, le drawdown maximal, s’inspirant de sources telles que Quantalys ou Morningstar.\n\nOU\nPour 3 Personnes (Option B) :\n\nTéléchargement et Cache Asynchrone : Mise en place d’un système pour le téléchargement et le stockage en cache des données de manière asynchrone.\n\nPour 4 Personnes :\n\nCombinaison des points mentionnés dans les options pour 3 personnes (Option A et B).\n\nPour 5 Personnes :\n\nIntégration des Crypto-monnaies : Ajout de la capacité à analyser les stratégies impliquant des contrats dérivés perpétuels ou futurs.\nSpécificités des Dérivés :\n\nPour les contrats perpétuels, le calcul inclura le coût du taux de financement.\nPour les contrats futurs, le calcul se basera sur le rollover, en utilisant le VWAP (Volume Weighted Average Price) sur une journée comme prix de rollover.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#quest-ce-quun-carnet-dordres",
    "href": "content/Projets/L3_EIF_2024.html#quest-ce-quun-carnet-dordres",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "Qu’est-ce qu’un Carnet d’Ordres ?",
    "text": "Qu’est-ce qu’un Carnet d’Ordres ?\nUn carnet d’ordres est un outil essentiel dans le fonctionnement des marchés financiers, particulièrement dans les marchés électroniques. Il représente une liste organisée d’ordres d’achat et de vente pour un actif spécifique, montrant la profondeur de marché et les niveaux de prix auxquels les participants sont prêts à acheter ou vendre.\n\nImportance du Carnet d’Ordres\n\nTransparence du Marché : Le carnet d’ordres offre une vue transparente sur la liquidité du marché, les intérêts d’achat et de vente, et aide à déterminer le prix de marché actuel d’un actif.\nDécisions de Trading : Les traders utilisent les informations du carnet d’ordres pour prendre des décisions éclairées, en analysant la profondeur du marché et les tendances des ordres.\n\n\n\nMarchés Électroniques\nDans les marchés électroniques modernes, les carnets d’ordres sont entièrement numérisés. Ils permettent un traitement rapide des ordres et une mise à jour en temps réel, ce qui est crucial pour la dynamique rapide des marchés financiers actuels.\n\n\nLe Fixing\nLe fixing est un processus utilisé pour déterminer les prix d’ouverture et de fermeture des actifs sur les marchés financiers. Il est particulièrement important dans les marchés où le trading n’est pas continu, comme certains marchés européens. Le fixing garantit un prix équitable basé sur l’ensemble des ordres disponibles à un moment donné.\n\n\nConcepts Clés à Explorer dans le Projet\n\nTick et Lot :\n\nTick : C’est le plus petit mouvement de prix possible pour un actif. Il joue un rôle crucial dans la détermination des variations de prix dans le carnet d’ordres.\nLot : Représente la quantité minimale ou un multiple d’un actif pouvant être échangé. Cela affecte la façon dont les ordres sont placés et exécutés dans le carnet d’ordres.\n\nRôles de Maker et Taker :\n\nMaker : Un participant du marché qui fournit de la liquidité en plaçant des ordres qui ne sont pas immédiatement exécutés (ordres limites).\nTaker : Un participant qui retire de la liquidité en exécutant immédiatement contre des ordres existants (ordres au marché).\n\n\n\n\nObjectifs et Applications du Projet\n\nPour 2 Personnes :\n\nDéveloppement d’une Classe : Création d’une classe en programmation permettant l’ajout et l’annulation d’ordres par participant, respectant les principes d’un carnet d’ordres continu.\nExemple d’Utilisation : Fournir un exemple concret d’utilisation de la classe.\n\nPour 3 Personnes :\n\nSystème de Fixing : Ajout d’un mécanisme de fixing efficace pour simuler les fixings d’ouverture et de fermeture, comme cela se fait sur les marchés européens.\n\nPour 4 Personnes :\n\nRécupération de Snapshot : Intégration d’une fonctionnalité pour récupérer automatiquement un instantané (snapshot) du carnet d’ordres de Binance et utiliser cet état comme point de départ dans la classe.\n\nPour 5 Personnes :\n\nSimulation du Carnet d’Ordres : Création de simulations basées sur des distributions de probabilité pour prédire l’évolution du carnet d’ordres dans les secondes ou minutes suivantes.\n\nPour 6 Personnes :\n\nOptimisation du Placement des Ordres : Utilisation de la classe développée pour déterminer le meilleur prix pour un ordre en tenant compte des frais de transaction pour les positions maker et taker.\n\nPour 7 Personnes :\n\nAnalyse de l’Impact du Spread et des Frais : Étude de l’effet du spread et des frais sur le placement optimal des ordres.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#sujet-d-option-et-volatilité-sur-les-crypto-monnaies",
    "href": "content/Projets/L3_EIF_2024.html#sujet-d-option-et-volatilité-sur-les-crypto-monnaies",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "Sujet D : Option et Volatilité sur les Crypto-monnaies",
    "text": "Sujet D : Option et Volatilité sur les Crypto-monnaies",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Projets/L3_EIF_2024.html#concepts-clés-à-explorer-dans-le-projet-sur-les",
    "href": "content/Projets/L3_EIF_2024.html#concepts-clés-à-explorer-dans-le-projet-sur-les",
    "title": "Projets Introduction à Python - Millésime 2024",
    "section": "Concepts Clés à Explorer dans le Projet sur les",
    "text": "Concepts Clés à Explorer dans le Projet sur les\n\n1. Volatilité Implicite\nLa volatilité implicite est un concept fondamental dans le monde des options. Elle représente les attentes du marché concernant la volatilité future de l’actif sous-jacent à l’option. Crucialement, la volatilité implicite n’est pas directement observable ; elle est plutôt déduite du prix actuel de l’option en utilisant des modèles de tarification. Cela la rend distincte de la volatilité historique, qui est basée sur les variations passées du prix de l’actif. Comprendre la volatilité implicite est vital pour évaluer correctement le prix d’une option et anticiper les mouvements potentiels du marché.\n\n\n2. Stratégie de Vente d’Options\nLa vente d’options implique une série de décisions stratégiques basées sur la volatilité et les attentes du marché. En vendant une option, le vendeur assume l’obligation de vendre (dans le cas d’un call) ou d’acheter (dans le cas d’un put) l’actif sous-jacent à un prix déterminé (strike price), si l’acheteur de l’option choisit de l’exercer. Les vendeurs d’options doivent évaluer soigneusement le niveau approprié de volatilité implicite et le prix de l’option pour gérer le risque et maximiser le profit. Ils doivent également tenir compte de la probabilité que l’option soit exercée et des conséquences potentielles sur leur portefeuille d’investissement.\n\n\n3. Modèle de Black-Scholes et Simulations de Monte Carlo\nLe modèle de Black-Scholes est une formule mathématique célèbre pour déterminer le prix théorique des options d’achat et de vente. Ce modèle prend en compte divers facteurs, notamment le prix actuel de l’actif sous-jacent, le prix d’exercice de l’option (strike price), le temps restant jusqu’à l’échéance, la volatilité de l’actif sous-jacent et le taux d’intérêt sans risque. En parallèle, les simulations de Monte Carlo sont des techniques utilisées pour modéliser et comprendre le comportement des options dans divers scénarios de marché. Ces simulations permettent de générer une gamme de résultats potentiels en variant les entrées (comme la volatilité et les taux de mouvement des prix) pour évaluer la probabilité de différents résultats et mieux comprendre les risques et opportunités associés à une option donnée.\n\n\nObjectifs et Applications du Projet\n\nPour 2 Personnes :\n\n\nCréation d’une Classe pour le Calcul du Prix d’Option :\n\nObjectif : Développer une classe capable de calculer le prix d’une option en fonction de sa volatilité implicite, du strike price, du dernier prix, et de l’échéance. Le taux sans risque sera considéré comme étant de 0%.\nMéthodes d’Implémentation : Intégrer la méthode de Black-Scholes pour la tarification des options et effectuer des simulations de Monte Carlo pour analyser divers scénarios de marché.\n\n\n\nPour 3 Personnes :\n\n\nSimulation du PnL d’un Vendeur d’Options :\n\nUtiliser des données historiques d’au moins un an pour simuler le PnL (Profit and Loss) d’un participant vendant des calls et des puts. Explorer différentes approches de volatilité, incluant la volatilité historique constante, la volatilité sur une fenêtre glissante, et la valeur absolue du rendement sur la période précédente.\nHypothèses de Backtest : Consistera à vendre ou acheter le même montant notionnel tous les jours, en fixant les strike prices à un pourcentage spécifique du prix courant de l’actif.\n\n\n\nPour 4 Personnes :\n\n\nMeilleur Prix et Performance :\n\nRépéter la simulation de PnL en ajoutant un élément de compétition pour déterminer qui offre le meilleur prix chaque jour. Analyser et comparer les performances en fonction des prix proposés.\n\n\n\nPour 5 Personnes :\n\n\nAnalyse Avancée de la Volatilité :\n\nRéaliser une analyse approfondie de la volatilité, en utilisant des méthodes statistiques, économétriques ou de machine learning. Examiner des facteurs tels que la saisonnalité hebdomadaire, l’autorégressivité, et effectuer des régressions linéaires en corrélation avec d’autres actifs financiers.\n\n\n\nPour 6 Personnes :\n\n\nPerformance dans un Environnement Concurrentiel :\n\nAppliquer et tester la stratégie développée dans un contexte de marché simulé avec d’autres participants fictifs. Analyser la performance de la stratégie en considérant soit un investissement fixe de 10 000 $, soit en utilisant une approche d’intérêts composés avec réinvestissement des gains ou des pertes.",
    "crumbs": [
      "Projets Introduction à Python - Millésime 2024"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Overloading.html",
    "href": "content/Cours_3/2-Overloading.html",
    "title": "Polymorphism in Python: Function Overloading and Type Checking",
    "section": "",
    "text": "In Python, function overloading (having multiple functions with the same name but different parameters) is not directly supported like in C++. However, Python offers alternative ways to achieve similar functionality. Let’s explore this concept and how it relates to polymorphism.\n\n\n\n\nIn C++, you might write:\nclass Calculator {\npublic:\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    double add(double a, double b) {\n        return a + b;\n    }\n};\nThis is not possible in Python. If you define two functions with the same name, the latter will override the former.\n\n\n\nIn Python, we need to use different strategies to handle different types of inputs:\n\nDifferent Function Names:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSingle Function with Type Checking:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUsing a Class to Encapsulate Different Implementations:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nThe class-based approach above demonstrates a form of polymorphism. The add method behaves differently based on the types of its inputs, effectively providing different implementations for different data types.\n\n\n\nSingle Interface: Users of the Calculator class only need to call add, regardless of the input types.\nEncapsulation: The type-specific implementations (_add_integers and _add_floats) are hidden from the user.\nExtensibility: It’s easy to add support for new types by adding new private methods and extending the type checking in add.\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nWhile the above approach uses explicit type checking, Python often relies on duck typing for polymorphism. “If it walks like a duck and quacks like a duck, it’s a duck.”\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this case, calculate_area works with any object that has an area method, regardless of its actual type.\n\n\n\nWhile Python doesn’t support function overloading in the same way as C++, it offers flexible alternatives through type checking and duck typing. These approaches allow for polymorphic behavior, enabling functions and methods to work with different types in a way that’s both pythonic and maintainable.\nThe class-based approach with encapsulated type-specific methods provides a clean way to handle different input types while maintaining a simple interface for the user. This demonstrates how Python can achieve polymorphic behavior similar to function overloading in other languages, but with its own unique style.",
    "crumbs": [
      "Polymorphism in Python: Function Overloading and Type Checking"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Overloading.html#function-overloading-in-python",
    "href": "content/Cours_3/2-Overloading.html#function-overloading-in-python",
    "title": "Polymorphism in Python: Function Overloading and Type Checking",
    "section": "",
    "text": "In C++, you might write:\nclass Calculator {\npublic:\n    int add(int a, int b) {\n        return a + b;\n    }\n    \n    double add(double a, double b) {\n        return a + b;\n    }\n};\nThis is not possible in Python. If you define two functions with the same name, the latter will override the former.\n\n\n\nIn Python, we need to use different strategies to handle different types of inputs:\n\nDifferent Function Names:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nSingle Function with Type Checking:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nUsing a Class to Encapsulate Different Implementations:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Polymorphism in Python: Function Overloading and Type Checking"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Overloading.html#polymorphism-through-type-checking",
    "href": "content/Cours_3/2-Overloading.html#polymorphism-through-type-checking",
    "title": "Polymorphism in Python: Function Overloading and Type Checking",
    "section": "",
    "text": "The class-based approach above demonstrates a form of polymorphism. The add method behaves differently based on the types of its inputs, effectively providing different implementations for different data types.\n\n\n\nSingle Interface: Users of the Calculator class only need to call add, regardless of the input types.\nEncapsulation: The type-specific implementations (_add_integers and _add_floats) are hidden from the user.\nExtensibility: It’s easy to add support for new types by adding new private methods and extending the type checking in add.\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Polymorphism in Python: Function Overloading and Type Checking"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Overloading.html#duck-typing-and-polymorphism-in-python",
    "href": "content/Cours_3/2-Overloading.html#duck-typing-and-polymorphism-in-python",
    "title": "Polymorphism in Python: Function Overloading and Type Checking",
    "section": "",
    "text": "While the above approach uses explicit type checking, Python often relies on duck typing for polymorphism. “If it walks like a duck and quacks like a duck, it’s a duck.”\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this case, calculate_area works with any object that has an area method, regardless of its actual type.",
    "crumbs": [
      "Polymorphism in Python: Function Overloading and Type Checking"
    ]
  },
  {
    "objectID": "content/Cours_3/2-Overloading.html#conclusion",
    "href": "content/Cours_3/2-Overloading.html#conclusion",
    "title": "Polymorphism in Python: Function Overloading and Type Checking",
    "section": "",
    "text": "While Python doesn’t support function overloading in the same way as C++, it offers flexible alternatives through type checking and duck typing. These approaches allow for polymorphic behavior, enabling functions and methods to work with different types in a way that’s both pythonic and maintainable.\nThe class-based approach with encapsulated type-specific methods provides a clean way to handle different input types while maintaining a simple interface for the user. This demonstrates how Python can achieve polymorphic behavior similar to function overloading in other languages, but with its own unique style.",
    "crumbs": [
      "Polymorphism in Python: Function Overloading and Type Checking"
    ]
  },
  {
    "objectID": "content/Cours_3/TP.html",
    "href": "content/Cours_3/TP.html",
    "title": "TP",
    "section": "",
    "text": "TODO\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "TP"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Polymorphism.html",
    "href": "content/Cours_3/1-Polymorphism.html",
    "title": "Polymorphism in Object-Oriented Programming",
    "section": "",
    "text": "Polymorphism is a fundamental principle in object-oriented programming (OOP) that allows objects of different types to be treated as objects of a common base type. The word “polymorphism” comes from Greek, meaning “many forms.” In OOP, it refers to the ability of a single interface to represent different underlying forms (data types or classes).\n\n\n\nSame Interface, Different Implementations: Polymorphism allows different classes to have methods with the same name, but with different implementations.\nFlexibility: It provides a way to use a class exactly like its parent, but with its own specific implementation.\nSimplification: It simplifies programming interfaces, making code more modular and extensible.\nRuntime Decision: The specific method that gets called is often determined at runtime, based on the actual type of the object.\n\n\n\n\n\nCompile-time Polymorphism (Static):\n\nAchieved through method overloading\nResolved at compile time\n\nRuntime Polymorphism (Dynamic):\n\nAchieved through method overriding\nResolved at runtime\n\n\n\n\n\nConsider a base class Animal with a method make_sound(). Different animals can implement this method differently:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, each animal class implements the make_sound() method differently, but they can all be treated as Animal objects.\n\n\n\n\nMethod overriding is a fundamental aspect of runtime polymorphism. It occurs when a derived class (child class) has a method with the same name and signature as a method in its base class (parent class).\n\n\n\nSame Name and Signature: The overriding method must have the same name and parameter list as the method in the parent class.\nRuntime Decision: The method to be invoked is determined at runtime based on the object’s type.\nExtends or Modifies Behavior: Overriding allows a child class to provide a specific implementation of a method that is already defined in its parent class.\nPolymorphic Behavior: It’s a key mechanism for achieving polymorphic behavior in OOP.\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - The Shape class provides a default implementation of area(). - Rectangle and Circle override this method with their specific implementations. - We can treat all objects as Shape instances, but each will use its own area() method.\n\n\n\n\nCustomization: Allows subclasses to provide specific implementations of methods.\nCode Reusability: Reuses the method name from the parent class, maintaining a logical hierarchy.\nRuntime Flexibility: Enables objects to behave differently based on their actual class, while still using a common interface.\n\nMethod overriding is a powerful feature that, when used correctly, can lead to more flexible and maintainable code structures in object-oriented programming.",
    "crumbs": [
      "Polymorphism in Object-Oriented Programming"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Polymorphism.html#general-concept",
    "href": "content/Cours_3/1-Polymorphism.html#general-concept",
    "title": "Polymorphism in Object-Oriented Programming",
    "section": "",
    "text": "Polymorphism is a fundamental principle in object-oriented programming (OOP) that allows objects of different types to be treated as objects of a common base type. The word “polymorphism” comes from Greek, meaning “many forms.” In OOP, it refers to the ability of a single interface to represent different underlying forms (data types or classes).\n\n\n\nSame Interface, Different Implementations: Polymorphism allows different classes to have methods with the same name, but with different implementations.\nFlexibility: It provides a way to use a class exactly like its parent, but with its own specific implementation.\nSimplification: It simplifies programming interfaces, making code more modular and extensible.\nRuntime Decision: The specific method that gets called is often determined at runtime, based on the actual type of the object.\n\n\n\n\n\nCompile-time Polymorphism (Static):\n\nAchieved through method overloading\nResolved at compile time\n\nRuntime Polymorphism (Dynamic):\n\nAchieved through method overriding\nResolved at runtime\n\n\n\n\n\nConsider a base class Animal with a method make_sound(). Different animals can implement this method differently:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, each animal class implements the make_sound() method differently, but they can all be treated as Animal objects.",
    "crumbs": [
      "Polymorphism in Object-Oriented Programming"
    ]
  },
  {
    "objectID": "content/Cours_3/1-Polymorphism.html#method-overriding",
    "href": "content/Cours_3/1-Polymorphism.html#method-overriding",
    "title": "Polymorphism in Object-Oriented Programming",
    "section": "",
    "text": "Method overriding is a fundamental aspect of runtime polymorphism. It occurs when a derived class (child class) has a method with the same name and signature as a method in its base class (parent class).\n\n\n\nSame Name and Signature: The overriding method must have the same name and parameter list as the method in the parent class.\nRuntime Decision: The method to be invoked is determined at runtime based on the object’s type.\nExtends or Modifies Behavior: Overriding allows a child class to provide a specific implementation of a method that is already defined in its parent class.\nPolymorphic Behavior: It’s a key mechanism for achieving polymorphic behavior in OOP.\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - The Shape class provides a default implementation of area(). - Rectangle and Circle override this method with their specific implementations. - We can treat all objects as Shape instances, but each will use its own area() method.\n\n\n\n\nCustomization: Allows subclasses to provide specific implementations of methods.\nCode Reusability: Reuses the method name from the parent class, maintaining a logical hierarchy.\nRuntime Flexibility: Enables objects to behave differently based on their actual class, while still using a common interface.\n\nMethod overriding is a powerful feature that, when used correctly, can lead to more flexible and maintainable code structures in object-oriented programming.",
    "crumbs": [
      "Polymorphism in Object-Oriented Programming"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html",
    "href": "content/Cours_4/1-Design_Pattern.html",
    "title": "Design Patterns",
    "section": "",
    "text": "Design patterns are reusable solutions to common problems in software design. They represent best practices evolved over time by experienced software developers. Design patterns are not complete solutions or finished designs that can be transformed directly into code. Instead, they provide templates for how to solve a problem in various situations.\n\n\n\nThe concept of design patterns gained popularity in software engineering after the publication of the book “Design Patterns: Elements of Reusable Object-Oriented Software” by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (known as the “Gang of Four”) in 1994. However, the idea of patterns in design was introduced earlier by Christopher Alexander in the field of architecture.\n\n\n\n\nProvide tested, proven development paradigms\nSpeed up the development process by providing well-tested mechanisms\nPrevent subtle issues that can cause major problems\nImprove code readability for coders and architects familiar with the patterns\n\n\n\n\nGenerally, design patterns are categorized into three main types:\n\nCreational Patterns: These deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.\nStructural Patterns: These deal with object composition or the structure of classes. They help ensure that if one part of a system changes, the entire structure doesn’t need to change.\nBehavioral Patterns: These are concerned with communication between objects, how objects interact and distribute responsibility.\n\n\n\n\n\nReusability: Patterns provide proven solutions to common problems.\nCommon vocabulary: They provide a common language for developers to efficiently communicate.\nReduce complexity: By providing tested, optimized solutions, they can reduce the complexity of code.\nBest practices: They capture best practices developed through trial and error over a significant period.\n\n\n\n\n\nPatterns should not be forced: Use them only when they are the best fit for the problem at hand.\nUnderstanding the problem is crucial: Misapplying patterns can lead to unnecessary complexity.\nPatterns evolve: As programming paradigms change, so do design patterns.\n\n\n\n\n\nSingleton: Ensures a class has only one instance and provides a global point of access to it.\nFactory Method: Defines an interface for creating an object, but lets subclasses decide which class to instantiate.\nObserver: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\nDecorator: Attaches additional responsibilities to an object dynamically.\n\n\n\n\nDesign patterns are essential tools in a developer’s toolkit. They provide standardized solutions to common software design problems, promote code reuse, and establish a common language among developers. While they are powerful, it’s important to use them judiciously and appropriately based on the specific requirements of each project.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#what-are-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#what-are-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Design patterns are reusable solutions to common problems in software design. They represent best practices evolved over time by experienced software developers. Design patterns are not complete solutions or finished designs that can be transformed directly into code. Instead, they provide templates for how to solve a problem in various situations.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#origins-of-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#origins-of-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "The concept of design patterns gained popularity in software engineering after the publication of the book “Design Patterns: Elements of Reusable Object-Oriented Software” by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (known as the “Gang of Four”) in 1994. However, the idea of patterns in design was introduced earlier by Christopher Alexander in the field of architecture.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#purpose-of-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#purpose-of-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Provide tested, proven development paradigms\nSpeed up the development process by providing well-tested mechanisms\nPrevent subtle issues that can cause major problems\nImprove code readability for coders and architects familiar with the patterns",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#categories-of-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#categories-of-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Generally, design patterns are categorized into three main types:\n\nCreational Patterns: These deal with object creation mechanisms, trying to create objects in a manner suitable to the situation.\nStructural Patterns: These deal with object composition or the structure of classes. They help ensure that if one part of a system changes, the entire structure doesn’t need to change.\nBehavioral Patterns: These are concerned with communication between objects, how objects interact and distribute responsibility.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#benefits-of-using-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#benefits-of-using-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Reusability: Patterns provide proven solutions to common problems.\nCommon vocabulary: They provide a common language for developers to efficiently communicate.\nReduce complexity: By providing tested, optimized solutions, they can reduce the complexity of code.\nBest practices: They capture best practices developed through trial and error over a significant period.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#considerations-when-using-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#considerations-when-using-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Patterns should not be forced: Use them only when they are the best fit for the problem at hand.\nUnderstanding the problem is crucial: Misapplying patterns can lead to unnecessary complexity.\nPatterns evolve: As programming paradigms change, so do design patterns.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#examples-of-common-design-patterns",
    "href": "content/Cours_4/1-Design_Pattern.html#examples-of-common-design-patterns",
    "title": "Design Patterns",
    "section": "",
    "text": "Singleton: Ensures a class has only one instance and provides a global point of access to it.\nFactory Method: Defines an interface for creating an object, but lets subclasses decide which class to instantiate.\nObserver: Defines a one-to-many dependency between objects so that when one object changes state, all its dependents are notified and updated automatically.\nDecorator: Attaches additional responsibilities to an object dynamically.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/1-Design_Pattern.html#conclusion",
    "href": "content/Cours_4/1-Design_Pattern.html#conclusion",
    "title": "Design Patterns",
    "section": "",
    "text": "Design patterns are essential tools in a developer’s toolkit. They provide standardized solutions to common software design problems, promote code reuse, and establish a common language among developers. While they are powerful, it’s important to use them judiciously and appropriately based on the specific requirements of each project.",
    "crumbs": [
      "Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html",
    "href": "content/Cours_4/2-Decorator_theory.html",
    "title": "The decorator pattern",
    "section": "",
    "text": "Decorators are a powerful and flexible design pattern in programming that allow for the dynamic modification or enhancement of object behavior without altering their structure. The concept of decorators has its roots in object-oriented programming and design patterns, evolving over time to become a fundamental feature in many modern programming languages.\n\n\n\nThe decorator pattern was first formally described in the seminal book “Design Patterns: Elements of Reusable Object-Oriented Software” by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (often referred to as the “Gang of Four” or GoF) in 1994. However, the underlying concepts had been in use for some time before that.\n\n\n\nAs object-oriented programming (OOP) gained popularity in the 1980s and early 1990s, developers faced challenges in creating flexible and maintainable code. Inheritance, while powerful, sometimes led to complex class hierarchies and the need for numerous subclasses to accommodate various combinations of behaviors.\n\n\n\nThe decorator pattern was conceived as a solution to these challenges. It provided a way to add responsibilities to objects dynamically, offering an alternative to subclassing for extending functionality. This pattern adheres to the Open/Closed Principle, one of the SOLID principles of object-oriented design, which states that software entities should be open for extension but closed for modification.\n\n\n\n\nComponent Interface: Defines the interface for objects that can have responsibilities added to them dynamically.\nConcrete Component: Defines an object to which additional responsibilities can be attached.\nDecorator: Maintains a reference to a Component object and defines an interface that conforms to Component’s interface.\nConcrete Decorator: Adds responsibilities to the component.\n\n\n\n\nThe decorator pattern offered several advantages over traditional inheritance:\n\nFlexibility: Allowed for the dynamic addition of responsibilities at runtime.\nComposition over inheritance: Promoted object composition, reducing the reliance on complex inheritance hierarchies.\nSingle Responsibility Principle: Each decorator could focus on a single concern, improving modularity.\n\n\n\n\nEarly implementations of the decorator pattern were often verbose and required significant boilerplate code. Developers had to create multiple classes to achieve the desired functionality, which, while powerful, could lead to code that was hard to read and maintain.\n\n\n\nAs the pattern gained popularity, different programming languages began to incorporate decorator-like features:\n\nJava: Introduced annotations in Java 5 (2004), which, while not identical to decorators, served similar purposes in many cases.\nC#: Added attributes, which are similar to Java’s annotations and can be used for decorator-like functionality.\nJavaScript: Proposed decorators as part of ECMAScript, though they are still in the proposal stage as of 2024.\n\n\n\n\nPython introduced decorator syntax in version 2.4 (2004), significantly simplifying the implementation of the decorator pattern. Python’s approach made decorators a first-class language feature, allowing for more readable and maintainable code.\n\n\n\nThe decorator pattern and its various implementations have had a profound impact on modern programming:\n\nAspect-Oriented Programming (AOP): Decorators are often used to implement cross-cutting concerns in AOP.\nMiddleware in Web Frameworks: Many web frameworks use decorator-like patterns for middleware implementation.\nMetaprogramming: Decorators have become a powerful tool for metaprogramming, allowing for code generation and modification at runtime.\n\n\n\n\nThe decorator pattern, from its formal description in 1994 to its various implementations in modern programming languages, has proven to be a versatile and powerful concept. It has evolved from a design pattern requiring significant implementation effort to a built-in feature in languages like Python, demonstrating its value in creating flexible, maintainable, and extensible code.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#introduction-to-decorators",
    "href": "content/Cours_4/2-Decorator_theory.html#introduction-to-decorators",
    "title": "The decorator pattern",
    "section": "",
    "text": "Decorators are a powerful and flexible design pattern in programming that allow for the dynamic modification or enhancement of object behavior without altering their structure. The concept of decorators has its roots in object-oriented programming and design patterns, evolving over time to become a fundamental feature in many modern programming languages.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#historical-context",
    "href": "content/Cours_4/2-Decorator_theory.html#historical-context",
    "title": "The decorator pattern",
    "section": "",
    "text": "The decorator pattern was first formally described in the seminal book “Design Patterns: Elements of Reusable Object-Oriented Software” by Erich Gamma, Richard Helm, Ralph Johnson, and John Vlissides (often referred to as the “Gang of Four” or GoF) in 1994. However, the underlying concepts had been in use for some time before that.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#object-oriented-programming-and-the-need-for-flexibility",
    "href": "content/Cours_4/2-Decorator_theory.html#object-oriented-programming-and-the-need-for-flexibility",
    "title": "The decorator pattern",
    "section": "",
    "text": "As object-oriented programming (OOP) gained popularity in the 1980s and early 1990s, developers faced challenges in creating flexible and maintainable code. Inheritance, while powerful, sometimes led to complex class hierarchies and the need for numerous subclasses to accommodate various combinations of behaviors.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#the-decorator-pattern-emerges",
    "href": "content/Cours_4/2-Decorator_theory.html#the-decorator-pattern-emerges",
    "title": "The decorator pattern",
    "section": "",
    "text": "The decorator pattern was conceived as a solution to these challenges. It provided a way to add responsibilities to objects dynamically, offering an alternative to subclassing for extending functionality. This pattern adheres to the Open/Closed Principle, one of the SOLID principles of object-oriented design, which states that software entities should be open for extension but closed for modification.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#key-concepts-of-the-decorator-pattern",
    "href": "content/Cours_4/2-Decorator_theory.html#key-concepts-of-the-decorator-pattern",
    "title": "The decorator pattern",
    "section": "",
    "text": "Component Interface: Defines the interface for objects that can have responsibilities added to them dynamically.\nConcrete Component: Defines an object to which additional responsibilities can be attached.\nDecorator: Maintains a reference to a Component object and defines an interface that conforms to Component’s interface.\nConcrete Decorator: Adds responsibilities to the component.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#advantages-over-traditional-inheritance",
    "href": "content/Cours_4/2-Decorator_theory.html#advantages-over-traditional-inheritance",
    "title": "The decorator pattern",
    "section": "",
    "text": "The decorator pattern offered several advantages over traditional inheritance:\n\nFlexibility: Allowed for the dynamic addition of responsibilities at runtime.\nComposition over inheritance: Promoted object composition, reducing the reliance on complex inheritance hierarchies.\nSingle Responsibility Principle: Each decorator could focus on a single concern, improving modularity.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#early-implementations",
    "href": "content/Cours_4/2-Decorator_theory.html#early-implementations",
    "title": "The decorator pattern",
    "section": "",
    "text": "Early implementations of the decorator pattern were often verbose and required significant boilerplate code. Developers had to create multiple classes to achieve the desired functionality, which, while powerful, could lead to code that was hard to read and maintain.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#evolution-in-different-programming-languages",
    "href": "content/Cours_4/2-Decorator_theory.html#evolution-in-different-programming-languages",
    "title": "The decorator pattern",
    "section": "",
    "text": "As the pattern gained popularity, different programming languages began to incorporate decorator-like features:\n\nJava: Introduced annotations in Java 5 (2004), which, while not identical to decorators, served similar purposes in many cases.\nC#: Added attributes, which are similar to Java’s annotations and can be used for decorator-like functionality.\nJavaScript: Proposed decorators as part of ECMAScript, though they are still in the proposal stage as of 2024.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#pythons-adoption-of-decorators",
    "href": "content/Cours_4/2-Decorator_theory.html#pythons-adoption-of-decorators",
    "title": "The decorator pattern",
    "section": "",
    "text": "Python introduced decorator syntax in version 2.4 (2004), significantly simplifying the implementation of the decorator pattern. Python’s approach made decorators a first-class language feature, allowing for more readable and maintainable code.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#impact-on-modern-programming",
    "href": "content/Cours_4/2-Decorator_theory.html#impact-on-modern-programming",
    "title": "The decorator pattern",
    "section": "",
    "text": "The decorator pattern and its various implementations have had a profound impact on modern programming:\n\nAspect-Oriented Programming (AOP): Decorators are often used to implement cross-cutting concerns in AOP.\nMiddleware in Web Frameworks: Many web frameworks use decorator-like patterns for middleware implementation.\nMetaprogramming: Decorators have become a powerful tool for metaprogramming, allowing for code generation and modification at runtime.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/2-Decorator_theory.html#conclusion",
    "href": "content/Cours_4/2-Decorator_theory.html#conclusion",
    "title": "The decorator pattern",
    "section": "",
    "text": "The decorator pattern, from its formal description in 1994 to its various implementations in modern programming languages, has proven to be a versatile and powerful concept. It has evolved from a design pattern requiring significant implementation effort to a built-in feature in languages like Python, demonstrating its value in creating flexible, maintainable, and extensible code.",
    "crumbs": [
      "The decorator pattern"
    ]
  },
  {
    "objectID": "content/Cours_4/4-builtin_decorator.html",
    "href": "content/Cours_4/4-builtin_decorator.html",
    "title": "Built-in Decorators and Standard Library Decorators in Python",
    "section": "",
    "text": "Python provides several built-in decorators and others in its standard library, particularly in the functools module. These decorators offer powerful functionality for common programming patterns.\n\n\n\n\nThe @property decorator is used to define methods in a class that act like attributes:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n@classmethod is used to define methods that operate on the class rather than instances:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n@staticmethod is used for methods that don’t need access to the class or instance:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThe @dataclass decorator, introduced in Python 3.7, automatically generates special methods like init(), repr(), and eq() for a class:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator simplifies the creation of classes that are primarily used to store data, reducing boilerplate code significantly.\n\n\n\n\nThe functools module in Python’s standard library provides several useful decorators:\n\n\nThis decorator implements memoization, caching the results of a function:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nIntroduced in Python 3.9, @cache is a simpler unbounded cache:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThis decorator is used when writing custom decorators to preserve the metadata of the original function:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThis decorator generates missing comparison methods for a class:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nThese built-in and standard library decorators provide powerful tools for Python developers. They offer efficient solutions for common programming patterns, from property management and method types to caching and comparison operations. Understanding and using these decorators can significantly enhance code readability and performance.",
    "crumbs": [
      "Built-in Decorators and Standard Library Decorators in Python"
    ]
  },
  {
    "objectID": "content/Cours_4/4-builtin_decorator.html#built-in-decorators",
    "href": "content/Cours_4/4-builtin_decorator.html#built-in-decorators",
    "title": "Built-in Decorators and Standard Library Decorators in Python",
    "section": "",
    "text": "The @property decorator is used to define methods in a class that act like attributes:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n@classmethod is used to define methods that operate on the class rather than instances:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n@staticmethod is used for methods that don’t need access to the class or instance:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThe @dataclass decorator, introduced in Python 3.7, automatically generates special methods like init(), repr(), and eq() for a class:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator simplifies the creation of classes that are primarily used to store data, reducing boilerplate code significantly.",
    "crumbs": [
      "Built-in Decorators and Standard Library Decorators in Python"
    ]
  },
  {
    "objectID": "content/Cours_4/4-builtin_decorator.html#decorators-from-functools",
    "href": "content/Cours_4/4-builtin_decorator.html#decorators-from-functools",
    "title": "Built-in Decorators and Standard Library Decorators in Python",
    "section": "",
    "text": "The functools module in Python’s standard library provides several useful decorators:\n\n\nThis decorator implements memoization, caching the results of a function:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nIntroduced in Python 3.9, @cache is a simpler unbounded cache:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThis decorator is used when writing custom decorators to preserve the metadata of the original function:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nThis decorator generates missing comparison methods for a class:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Built-in Decorators and Standard Library Decorators in Python"
    ]
  },
  {
    "objectID": "content/Cours_4/4-builtin_decorator.html#conclusion",
    "href": "content/Cours_4/4-builtin_decorator.html#conclusion",
    "title": "Built-in Decorators and Standard Library Decorators in Python",
    "section": "",
    "text": "These built-in and standard library decorators provide powerful tools for Python developers. They offer efficient solutions for common programming patterns, from property management and method types to caching and comparison operations. Understanding and using these decorators can significantly enhance code readability and performance.",
    "crumbs": [
      "Built-in Decorators and Standard Library Decorators in Python"
    ]
  },
  {
    "objectID": "content/Cours_1/TP.html",
    "href": "content/Cours_1/TP.html",
    "title": "Construire son propre DataFrame",
    "section": "",
    "text": "Instructions\nVotre tâche est de créer une classe DataFrameSimple qui simule les fonctionnalités de base d’un dataframe. Suivez ces instructions :\n\nCréez un fichier nommé dataframe_simple.py.\nDans ce fichier, implémentez la classe DataFrameSimple avec les méthodes suivantes :\n\n__init__(self, data) : Le constructeur qui accepte un dictionnaire de données.\nafficher(self) : Retourne une chaîne représentant les premières lignes du dataframe.\nmoyenne(self, nom_colonne) : Calcule la moyenne d’une colonne.\nsomme(self, nom_colonne) : Calcule la somme d’une colonne.\nmin(self, nom_colonne) : Trouve le minimum d’une colonne.\nmax(self, nom_colonne) : Trouve le maximum d’une colonne.\nselect_colonne(self, nom_colonne) : Retourne les valeurs d’une colonne.\n\nVotre classe doit avoir les attributs suivants :\n\ndonnees : Un numpy array contenant les données.\ncolonnes : Une liste des noms de colonnes.\n\nUtilisez numpy pour les calculs statistiques (np.mean(), np.sum(), etc.).\nUne fois votre implémentation terminée, exécutez les tests unitaires en lançant python test_dataframe_simple.py.\nAssurez-vous que tous les tests passent. Si ce n’est pas le cas, revoyez votre implémentation.\n\nConseils : - Commencez par implémenter le constructeur et la méthode afficher(). - Utilisez les fonctions numpy pour les calculs statistiques. - N’oubliez pas d’importer numpy dans votre fichier dataframe_simple.py.\n\n\nTests Unitaires pour verifier votre implémentation\nVoici un ensemble de tests unitaires simplifiés pour votre classe DataFrameSimple. Copier votre classe avec ce code pour la tester :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "Construire son propre DataFrame"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "Une classe en Python est un plan ou un modèle pour créer des objets. Elle définit les caractéristiques (attributs) et les comportements (méthodes) que les objets de cette classe auront.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nUne instance est un objet spécifique créé à partir d’une classe.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLa classe est le modèle général (comme un plan d’architecte).\nL’instance est un objet spécifique créé à partir de ce modèle (comme une maison construite selon le plan).\n\nExemple :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, Voiture est la classe, tandis que voiture1 et voiture2 sont des instances de cette classe.\n\n\n\nself est une convention en Python pour référencer l’instance actuelle de la classe. C’est le premier paramètre de toutes les méthodes d’instance.\n\n\n\nself permet à la méthode de savoir sur quelle instance spécifique elle travaille.\nIl est automatiquement passé par Python lors de l’appel d’une méthode sur une instance.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple : - self.marque = marque stocke la marque pour cette instance spécifique. - Dans description(), self.marque fait référence à la marque de l’instance sur laquelle la méthode est appelée.\n\n\n\n\n__init__ est une méthode spéciale en Python, appelée constructeur. Elle est automatiquement appelée lors de la création d’une nouvelle instance.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nIls sont partagés par toutes les instances de la classe, mais peuvent être modifiés au niveau de l’instance.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, ma_voiture.accident() modifie l’attribut nombre_de_roues pour cette instance spécifique, sans affecter la classe ou les autres instances.\n\n\n\n[Cette section reste inchangée]\n\n\n\n\nself est une référence à l’instance courante de la classe. C’est le premier paramètre de toute méthode d’instance en Python.\n\n\nLorsqu’une méthode est appelée sur une instance, Python passe automatiquement cette instance comme premier argument à la méthode.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nBien que ‘self’ soit une convention, on peut techniquement utiliser n’importe quel nom :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCependant, utiliser ‘self’ est fortement recommandé pour la lisibilité et le respect des conventions.\n\n\n\n\nPEP 8 est le guide de style pour le code Python. Il fournit des conventions pour écrire du code Python lisible et cohérent.\n\n\n\nNoms de classe : Utilisez la convention CapWords (aussi appelée PascalCase).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNoms de méthodes et d’attributs : Utilisez des minuscules avec des underscores pour séparer les mots.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nConstantes : Utilisez des majuscules avec des underscores.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nEspaces : Pas d’espaces autour des parenthèses ou des crochets, mais un espace après les virgules.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIndentation : Utilisez 4 espaces par niveau d’indentation.\n\n\n\n\nSuivre PEP 8 rend votre code : - Plus lisible pour les autres développeurs - Plus cohérent avec la majorité du code Python - Plus facile à maintenir sur le long terme\n\n\n\n\nComprendre les concepts fondamentaux des classes en Python, comme les attributs de classe vs d’instance, le rôle de ‘self’, et les conventions de codage, est crucial pour écrire du code orienté objet efficace et lisible. Ces bases permettent de construire des programmes bien structurés et faciles à maintenir.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#quest-ce-quune-classe",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#quest-ce-quune-classe",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "Une classe en Python est un plan ou un modèle pour créer des objets. Elle définit les caractéristiques (attributs) et les comportements (méthodes) que les objets de cette classe auront.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#création-dune-instance",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#création-dune-instance",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "Une instance est un objet spécifique créé à partir d’une classe.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-la-différence-entre-classe-et-instance",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-la-différence-entre-classe-et-instance",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "La classe est le modèle général (comme un plan d’architecte).\nL’instance est un objet spécifique créé à partir de ce modèle (comme une maison construite selon le plan).\n\nExemple :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, Voiture est la classe, tandis que voiture1 et voiture2 sont des instances de cette classe.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-self",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-self",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "self est une convention en Python pour référencer l’instance actuelle de la classe. C’est le premier paramètre de toutes les méthodes d’instance.\n\n\n\nself permet à la méthode de savoir sur quelle instance spécifique elle travaille.\nIl est automatiquement passé par Python lors de l’appel d’une méthode sur une instance.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple : - self.marque = marque stocke la marque pour cette instance spécifique. - Dans description(), self.marque fait référence à la marque de l’instance sur laquelle la méthode est appelée.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#méthode-init",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#méthode-init",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "__init__ est une méthode spéciale en Python, appelée constructeur. Elle est automatiquement appelée lors de la création d’une nouvelle instance.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#attributs-de-classe-vs-attributs-dinstance-version-étendue",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#attributs-de-classe-vs-attributs-dinstance-version-étendue",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "Ils sont partagés par toutes les instances de la classe, mais peuvent être modifiés au niveau de l’instance.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple, ma_voiture.accident() modifie l’attribut nombre_de_roues pour cette instance spécifique, sans affecter la classe ou les autres instances.\n\n\n\n[Cette section reste inchangée]",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-self-en-profondeur",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#comprendre-self-en-profondeur",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "self est une référence à l’instance courante de la classe. C’est le premier paramètre de toute méthode d’instance en Python.\n\n\nLorsqu’une méthode est appelée sur une instance, Python passe automatiquement cette instance comme premier argument à la méthode.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nBien que ‘self’ soit une convention, on peut techniquement utiliser n’importe quel nom :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nCependant, utiliser ‘self’ est fortement recommandé pour la lisibilité et le respect des conventions.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#introduction-aux-conventions-de-codage-pep-8",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#introduction-aux-conventions-de-codage-pep-8",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "PEP 8 est le guide de style pour le code Python. Il fournit des conventions pour écrire du code Python lisible et cohérent.\n\n\n\nNoms de classe : Utilisez la convention CapWords (aussi appelée PascalCase).\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nNoms de méthodes et d’attributs : Utilisez des minuscules avec des underscores pour séparer les mots.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nConstantes : Utilisez des majuscules avec des underscores.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nEspaces : Pas d’espaces autour des parenthèses ou des crochets, mais un espace après les virgules.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIndentation : Utilisez 4 espaces par niveau d’indentation.\n\n\n\n\nSuivre PEP 8 rend votre code : - Plus lisible pour les autres développeurs - Plus cohérent avec la majorité du code Python - Plus facile à maintenir sur le long terme",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/6-Bases_of_classes_in_python.html#conclusion",
    "href": "content/Cours_1/6-Bases_of_classes_in_python.html#conclusion",
    "title": "Classes en Python : Concepts fondamentaux",
    "section": "",
    "text": "Comprendre les concepts fondamentaux des classes en Python, comme les attributs de classe vs d’instance, le rôle de ‘self’, et les conventions de codage, est crucial pour écrire du code orienté objet efficace et lisible. Ces bases permettent de construire des programmes bien structurés et faciles à maintenir.",
    "crumbs": [
      "Classes en Python : Concepts fondamentaux"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html",
    "href": "content/Cours_1/4-all_is_object.html",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "En Python, absolument tout est un objet. Cette philosophie est fondamentale et distingue Python de nombreux autres langages de programmation.\n\n\n\nMême les types de base (int, float, str) sont des objets\nLes fonctions sont des objets\nLes classes sont des objets\nLes modules sont des objets\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\nEn C++, un int ou un float a une taille fixe et prédéfinie\nEn Python, même un simple entier est un objet complet avec des métadonnées\n\n\n\n\n\nOpérations plus coûteuses en Python (plus d’indirections)\nPas de risque d’overflow/underflow pour les entiers en Python (entiers de taille arbitraire)\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\nLes variables n’ont pas de type fixe\nLe type est lié à l’objet, pas à la variable\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nComme tout est objet, Python offre de puissantes capacités d’introspection.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\n\n\nSyntaxe cohérente pour manipuler différents types d’objets\nFacilite l’apprentissage et l’utilisation du langage\n\n\n\n\n\nPossibilité de créer des types personnalisés qui se comportent comme des types intégrés\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\n\nLa nature “tout objet” de Python simplifie de nombreux concepts\nCependant, cela a un coût en termes de performance et d’utilisation mémoire\nPython privilégie la lisibilité et la facilité de développement sur la performance brute\n\n\n\n\nL’approche “tout est objet” de Python offre une grande cohérence et flexibilité, mais avec un compromis sur les performances. Cette philosophie permet aux développeurs de se concentrer sur la logique de leur programme plutôt que sur les détails de bas niveau, rendant Python particulièrement adapté au prototypage rapide et au développement d’applications où la vitesse de développement prime sur l’efficacité d’exécution.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#le-concept-tout-est-objet-en-python",
    "href": "content/Cours_1/4-all_is_object.html#le-concept-tout-est-objet-en-python",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "En Python, absolument tout est un objet. Cette philosophie est fondamentale et distingue Python de nombreux autres langages de programmation.\n\n\n\nMême les types de base (int, float, str) sont des objets\nLes fonctions sont des objets\nLes classes sont des objets\nLes modules sont des objets\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#objets-de-base-vs-objets-en-c",
    "href": "content/Cours_1/4-all_is_object.html#objets-de-base-vs-objets-en-c",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "En C++, un int ou un float a une taille fixe et prédéfinie\nEn Python, même un simple entier est un objet complet avec des métadonnées\n\n\n\n\n\nOpérations plus coûteuses en Python (plus d’indirections)\nPas de risque d’overflow/underflow pour les entiers en Python (entiers de taille arbitraire)\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#flexibilité-et-dynamisme",
    "href": "content/Cours_1/4-all_is_object.html#flexibilité-et-dynamisme",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "Les variables n’ont pas de type fixe\nLe type est lié à l’objet, pas à la variable\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#introspection-et-réflexion",
    "href": "content/Cours_1/4-all_is_object.html#introspection-et-réflexion",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "Comme tout est objet, Python offre de puissantes capacités d’introspection.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#implications-sur-la-programmation",
    "href": "content/Cours_1/4-all_is_object.html#implications-sur-la-programmation",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "Syntaxe cohérente pour manipuler différents types d’objets\nFacilite l’apprentissage et l’utilisation du langage\n\n\n\n\n\nPossibilité de créer des types personnalisés qui se comportent comme des types intégrés\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#compromis-simplicité-vs-performance",
    "href": "content/Cours_1/4-all_is_object.html#compromis-simplicité-vs-performance",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "La nature “tout objet” de Python simplifie de nombreux concepts\nCependant, cela a un coût en termes de performance et d’utilisation mémoire\nPython privilégie la lisibilité et la facilité de développement sur la performance brute",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/4-all_is_object.html#conclusion",
    "href": "content/Cours_1/4-all_is_object.html#conclusion",
    "title": "Python: tout n’est qu’objet",
    "section": "",
    "text": "L’approche “tout est objet” de Python offre une grande cohérence et flexibilité, mais avec un compromis sur les performances. Cette philosophie permet aux développeurs de se concentrer sur la logique de leur programme plutôt que sur les détails de bas niveau, rendant Python particulièrement adapté au prototypage rapide et au développement d’applications où la vitesse de développement prime sur l’efficacité d’exécution.",
    "crumbs": [
      "Python: tout n'est qu'objet"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html",
    "href": "content/Cours_1/1-Histoire.html",
    "title": "Histoire de la programmation",
    "section": "",
    "text": "Les premiers ordinateurs étaient programmés directement en langage machine, c’est-à-dire en code binaire. Cette méthode présentait plusieurs caractéristiques :\n\nComplexité extrême : Les programmeurs devaient écrire des séquences de 0 et de 1 pour chaque instruction.\nSpécificité au matériel : Chaque type de processeur avait son propre jeu d’instructions en langage machine.\nDifficulté de maintenance : Le code était pratiquement illisible pour les humains, rendant les corrections et les mises à jour très difficiles.\n\nExemple simplifié d’addition en langage machine (fictif) :\n10110000 01100011 00000001  // Charger la valeur du registre 1 dans l'accumulateur\n10110001 01100011 00000010  // Ajouter la valeur du registre 2 à l'accumulateur\n10110010 01100011 00000011  // Stocker le résultat dans le registre 3\n\n\n\nPour faciliter la programmation, le langage assembleur a été développé. Il présentait plusieurs avantages :\n\nLisibilité améliorée : Utilisation de mnémoniques (ADD, MOV, JMP) au lieu de codes binaires.\nCorrespondance directe : Chaque instruction assembleur correspondait généralement à une instruction en langage machine.\nIntroduction des étiquettes : Permettait de nommer des points dans le programme, facilitant les sauts et les boucles.\n\nExemple du même calcul en assembleur (syntaxe simplifiée) :\nLOAD R1    ; Charger la valeur du registre 1 dans l'accumulateur\nADD R2     ; Ajouter la valeur du registre 2 à l'accumulateur\nSTORE R3   ; Stocker le résultat dans le registre 3\n\n\n\n\n\n\nDéveloppé par IBM en 1957, FORTRAN a révolutionné la programmation :\n\nPremier langage de haut niveau largement adopté\nConçu pour les calculs scientifiques et l’ingénierie\nIntroduction de concepts comme les boucles et les fonctions\n\nExemple de calcul d’intérêt composé en FORTRAN :\nPROGRAM INTERET_COMPOSE\n    REAL PRINCIPAL, TAUX, MONTANT\n    INTEGER ANNEES, I\n\n    PRINT *, 'Entrez le principal, le taux (en decimal) et les annees:'\n    READ *, PRINCIPAL, TAUX, ANNEES\n\n    MONTANT = PRINCIPAL\n    DO I = 1, ANNEES\n        MONTANT = MONTANT * (1 + TAUX)\n    END DO\n\n    PRINT *, 'Montant final:', MONTANT\nEND PROGRAM INTERET_COMPOSE\n\n\n\nCréé en 1959, COBOL visait les applications commerciales :\n\nSyntaxe proche de l’anglais pour faciliter la compréhension\nGestion efficace des fichiers et des données structurées\nLargement utilisé dans les systèmes bancaires et financiers\n\nExemple simplifié de calcul de salaire en COBOL :\nIDENTIFICATION DIVISION.\nPROGRAM-ID. CALCUL-SALAIRE.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT EMPLOYE-FICHIER ASSIGN TO \"employes.dat\"\n        ORGANIZATION IS LINE SEQUENTIAL.\n\nDATA DIVISION.\nFILE SECTION.\nFD EMPLOYE-FICHIER.\n01 EMPLOYE-ENREG.\n    05 EMP-NOM PIC X(20).\n    05 EMP-HEURES PIC 9(3).\n    05 EMP-TAUX PIC 9(3)V99.\n\nWORKING-STORAGE SECTION.\n01 WS-SALAIRE PIC 9(5)V99.\n01 WS-EOF PIC A(1).\n\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\n    OPEN INPUT EMPLOYE-FICHIER\n    PERFORM UNTIL WS-EOF = 'Y'\n        READ EMPLOYE-FICHIER\n            AT END\n                MOVE 'Y' TO WS-EOF\n            NOT AT END\n                PERFORM CALCUL-AFFICHAGE\n        END-READ\n    END-PERFORM\n    CLOSE EMPLOYE-FICHIER\n    STOP RUN.\n\nCALCUL-AFFICHAGE.\n    COMPUTE WS-SALAIRE = EMP-HEURES * EMP-TAUX\n    DISPLAY EMP-NOM \" Salaire: $\" WS-SALAIRE.\n\n\n\n\nLa programmation procédurale, illustrée par ces langages, se caractérise par :\n\nSéquence d’instructions : Le programme est une suite d’étapes à exécuter.\nProcédures et fonctions : Le code est organisé en blocs réutilisables.\nVariables globales et locales : Gestion de l’état du programme.\nFlux de contrôle linéaire : Utilisation de structures comme les boucles et les conditions.\n\n\n\n\nSimplicité relative par rapport au langage machine\nPossibilité de créer des programmes complexes\nFacilité d’apprentissage pour les débutants\n\n\n\n\n\nDifficulté à gérer des projets très larges\nRisque élevé d’effets de bord avec les variables globales\nManque de représentation naturelle pour certains problèmes du monde réel\n\nCette approche a dominé la programmation pendant plusieurs décennies, posant les bases pour l’évolution future vers des paradigmes plus avancés, notamment la programmation orientée objet.",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#lère-du-langage-machine-et-de-lassembleur",
    "href": "content/Cours_1/1-Histoire.html#lère-du-langage-machine-et-de-lassembleur",
    "title": "Histoire de la programmation",
    "section": "",
    "text": "Les premiers ordinateurs étaient programmés directement en langage machine, c’est-à-dire en code binaire. Cette méthode présentait plusieurs caractéristiques :\n\nComplexité extrême : Les programmeurs devaient écrire des séquences de 0 et de 1 pour chaque instruction.\nSpécificité au matériel : Chaque type de processeur avait son propre jeu d’instructions en langage machine.\nDifficulté de maintenance : Le code était pratiquement illisible pour les humains, rendant les corrections et les mises à jour très difficiles.\n\nExemple simplifié d’addition en langage machine (fictif) :\n10110000 01100011 00000001  // Charger la valeur du registre 1 dans l'accumulateur\n10110001 01100011 00000010  // Ajouter la valeur du registre 2 à l'accumulateur\n10110010 01100011 00000011  // Stocker le résultat dans le registre 3\n\n\n\nPour faciliter la programmation, le langage assembleur a été développé. Il présentait plusieurs avantages :\n\nLisibilité améliorée : Utilisation de mnémoniques (ADD, MOV, JMP) au lieu de codes binaires.\nCorrespondance directe : Chaque instruction assembleur correspondait généralement à une instruction en langage machine.\nIntroduction des étiquettes : Permettait de nommer des points dans le programme, facilitant les sauts et les boucles.\n\nExemple du même calcul en assembleur (syntaxe simplifiée) :\nLOAD R1    ; Charger la valeur du registre 1 dans l'accumulateur\nADD R2     ; Ajouter la valeur du registre 2 à l'accumulateur\nSTORE R3   ; Stocker le résultat dans le registre 3",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#lémergence-des-langages-de-haut-niveau",
    "href": "content/Cours_1/1-Histoire.html#lémergence-des-langages-de-haut-niveau",
    "title": "Histoire de la programmation",
    "section": "",
    "text": "Développé par IBM en 1957, FORTRAN a révolutionné la programmation :\n\nPremier langage de haut niveau largement adopté\nConçu pour les calculs scientifiques et l’ingénierie\nIntroduction de concepts comme les boucles et les fonctions\n\nExemple de calcul d’intérêt composé en FORTRAN :\nPROGRAM INTERET_COMPOSE\n    REAL PRINCIPAL, TAUX, MONTANT\n    INTEGER ANNEES, I\n\n    PRINT *, 'Entrez le principal, le taux (en decimal) et les annees:'\n    READ *, PRINCIPAL, TAUX, ANNEES\n\n    MONTANT = PRINCIPAL\n    DO I = 1, ANNEES\n        MONTANT = MONTANT * (1 + TAUX)\n    END DO\n\n    PRINT *, 'Montant final:', MONTANT\nEND PROGRAM INTERET_COMPOSE\n\n\n\nCréé en 1959, COBOL visait les applications commerciales :\n\nSyntaxe proche de l’anglais pour faciliter la compréhension\nGestion efficace des fichiers et des données structurées\nLargement utilisé dans les systèmes bancaires et financiers\n\nExemple simplifié de calcul de salaire en COBOL :\nIDENTIFICATION DIVISION.\nPROGRAM-ID. CALCUL-SALAIRE.\n\nENVIRONMENT DIVISION.\nINPUT-OUTPUT SECTION.\nFILE-CONTROL.\n    SELECT EMPLOYE-FICHIER ASSIGN TO \"employes.dat\"\n        ORGANIZATION IS LINE SEQUENTIAL.\n\nDATA DIVISION.\nFILE SECTION.\nFD EMPLOYE-FICHIER.\n01 EMPLOYE-ENREG.\n    05 EMP-NOM PIC X(20).\n    05 EMP-HEURES PIC 9(3).\n    05 EMP-TAUX PIC 9(3)V99.\n\nWORKING-STORAGE SECTION.\n01 WS-SALAIRE PIC 9(5)V99.\n01 WS-EOF PIC A(1).\n\nPROCEDURE DIVISION.\nMAIN-PROCEDURE.\n    OPEN INPUT EMPLOYE-FICHIER\n    PERFORM UNTIL WS-EOF = 'Y'\n        READ EMPLOYE-FICHIER\n            AT END\n                MOVE 'Y' TO WS-EOF\n            NOT AT END\n                PERFORM CALCUL-AFFICHAGE\n        END-READ\n    END-PERFORM\n    CLOSE EMPLOYE-FICHIER\n    STOP RUN.\n\nCALCUL-AFFICHAGE.\n    COMPUTE WS-SALAIRE = EMP-HEURES * EMP-TAUX\n    DISPLAY EMP-NOM \" Salaire: $\" WS-SALAIRE.",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "content/Cours_1/1-Histoire.html#caractéristiques-de-la-programmation-procédurale",
    "href": "content/Cours_1/1-Histoire.html#caractéristiques-de-la-programmation-procédurale",
    "title": "Histoire de la programmation",
    "section": "",
    "text": "La programmation procédurale, illustrée par ces langages, se caractérise par :\n\nSéquence d’instructions : Le programme est une suite d’étapes à exécuter.\nProcédures et fonctions : Le code est organisé en blocs réutilisables.\nVariables globales et locales : Gestion de l’état du programme.\nFlux de contrôle linéaire : Utilisation de structures comme les boucles et les conditions.\n\n\n\n\nSimplicité relative par rapport au langage machine\nPossibilité de créer des programmes complexes\nFacilité d’apprentissage pour les débutants\n\n\n\n\n\nDifficulté à gérer des projets très larges\nRisque élevé d’effets de bord avec les variables globales\nManque de représentation naturelle pour certains problèmes du monde réel\n\nCette approche a dominé la programmation pendant plusieurs décennies, posant les bases pour l’évolution future vers des paradigmes plus avancés, notamment la programmation orientée objet.",
    "crumbs": [
      "Histoire de la programmation"
    ]
  },
  {
    "objectID": "content/Cours_5/1-Project_layout.html",
    "href": "content/Cours_5/1-Project_layout.html",
    "title": "Organizing Python Projects",
    "section": "",
    "text": "Python’s import system is fundamental to how we organize and use code across multiple files and directories. Understanding it is crucial for structuring projects effectively.\n\nWhen you use an import statement, Python searches for the module in several locations:\n\nThe directory containing the script\nPYTHONPATH (if set)\nStandard library directories\nSite-packages directory (for installed third-party packages)\n\n\n\n\n\n\nPATH: An environment variable that tells the operating system where to look for executables. It’s not directly related to Python imports but is important for running Python from the command line.\nPYTHONPATH: An environment variable that you can set to add additional directories where Python will look for modules and packages.\n\n\n\n\nTo import modules from the current directory, you have several options:\n\nRun Python from the directory containing your modules:\npython my_script.py\nAdd the current directory to PYTHONPATH:\nexport PYTHONPATH=$PYTHONPATH:.\nModify sys.path in your script:\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.realpath(__file__)))\n\n\n\n\nYou can view the current module search path using:\nimport sys\nprint(sys.path)\n\n\n\n\nAbsolute imports use the full path from the project’s root:\n\nfrom mypackage.submodule import myfunction\n\nRelative imports use dots to refer to the current and parent packages:\n\nfrom . import sibling_module\nfrom .. import parent_package_module\n\nGenerally, absolute imports are preferred for clarity and to avoid confusion.\n\n\n\n\n\nA well-organized project structure enhances readability and maintainability. Here’s a common layout:\nmy_project/\n│\n├── my_package/\n│   ├── __init__.py\n│   ├── module1.py\n│   └── module2.py\n│\n├── tests/\n│   ├── test_module1.py\n│   └── test_module2.py\n│\n├── docs/\n│   └── index.md\n│\n├── pyproject.toml\n└── README.md\nNote: Some projects use a src/ directory (e.g., src/my_package/) to separate package code. While this can be beneficial for larger projects or when building distributions, it’s not mandatory and can add complexity for smaller projects.\n\n\n\n\nSource Code (my_package/): Contains the actual package code\nTests (tests/): Keeps tests separate from source code\nDocumentation (docs/): Separates documentation from code\nProject Files: pyproject.toml for project configuration, README.md for project overview\n\n\n\n\nLet’s create a simple project structure:\n# Create project directory\nmkdir my_project\ncd my_project\n\n# Create package directory\nmkdir my_package\ntouch my_package/__init__.py\ntouch my_package/module1.py\n\n# Create tests directory\nmkdir tests\ntouch tests/test_module1.py\n\n# Create docs directory\nmkdir docs\ntouch docs/index.md\n\n# Create project files\ntouch pyproject.toml README.md\nThis structure sets the foundation for a well-organized Python project, making it easier to develop, test, and maintain your code.",
    "crumbs": [
      "Organizing Python Projects"
    ]
  },
  {
    "objectID": "content/Cours_5/1-Project_layout.html#understanding-python-imports-and-project-structure-45-minutes",
    "href": "content/Cours_5/1-Project_layout.html#understanding-python-imports-and-project-structure-45-minutes",
    "title": "Organizing Python Projects",
    "section": "",
    "text": "Python’s import system is fundamental to how we organize and use code across multiple files and directories. Understanding it is crucial for structuring projects effectively.\n\nWhen you use an import statement, Python searches for the module in several locations:\n\nThe directory containing the script\nPYTHONPATH (if set)\nStandard library directories\nSite-packages directory (for installed third-party packages)\n\n\n\n\n\n\nPATH: An environment variable that tells the operating system where to look for executables. It’s not directly related to Python imports but is important for running Python from the command line.\nPYTHONPATH: An environment variable that you can set to add additional directories where Python will look for modules and packages.\n\n\n\n\nTo import modules from the current directory, you have several options:\n\nRun Python from the directory containing your modules:\npython my_script.py\nAdd the current directory to PYTHONPATH:\nexport PYTHONPATH=$PYTHONPATH:.\nModify sys.path in your script:\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.realpath(__file__)))\n\n\n\n\nYou can view the current module search path using:\nimport sys\nprint(sys.path)\n\n\n\n\nAbsolute imports use the full path from the project’s root:\n\nfrom mypackage.submodule import myfunction\n\nRelative imports use dots to refer to the current and parent packages:\n\nfrom . import sibling_module\nfrom .. import parent_package_module\n\nGenerally, absolute imports are preferred for clarity and to avoid confusion.\n\n\n\n\n\nA well-organized project structure enhances readability and maintainability. Here’s a common layout:\nmy_project/\n│\n├── my_package/\n│   ├── __init__.py\n│   ├── module1.py\n│   └── module2.py\n│\n├── tests/\n│   ├── test_module1.py\n│   └── test_module2.py\n│\n├── docs/\n│   └── index.md\n│\n├── pyproject.toml\n└── README.md\nNote: Some projects use a src/ directory (e.g., src/my_package/) to separate package code. While this can be beneficial for larger projects or when building distributions, it’s not mandatory and can add complexity for smaller projects.\n\n\n\n\nSource Code (my_package/): Contains the actual package code\nTests (tests/): Keeps tests separate from source code\nDocumentation (docs/): Separates documentation from code\nProject Files: pyproject.toml for project configuration, README.md for project overview\n\n\n\n\nLet’s create a simple project structure:\n# Create project directory\nmkdir my_project\ncd my_project\n\n# Create package directory\nmkdir my_package\ntouch my_package/__init__.py\ntouch my_package/module1.py\n\n# Create tests directory\nmkdir tests\ntouch tests/test_module1.py\n\n# Create docs directory\nmkdir docs\ntouch docs/index.md\n\n# Create project files\ntouch pyproject.toml README.md\nThis structure sets the foundation for a well-organized Python project, making it easier to develop, test, and maintain your code.",
    "crumbs": [
      "Organizing Python Projects"
    ]
  },
  {
    "objectID": "content/Cours_5/index.html",
    "href": "content/Cours_5/index.html",
    "title": "Project and Package",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nOrganizing Python Projects\n\n\nLearn how to organize Python projects effectively and create packages for distribution.\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython Package Management and Virtual Environments\n\n\nLearn to create a package and manage virtual environment\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP\n\n\n\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnderstanding imports\n\n\n\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nUnit Testing in Python\n\n\nLearn how to write and run unit tests in Python using the pytest framework.\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Project and Package"
    ]
  },
  {
    "objectID": "content/Cours_5/2-Import.html",
    "href": "content/Cours_5/2-Import.html",
    "title": "Understanding imports",
    "section": "",
    "text": "When you use an import statement, Python searches for the module or package in several locations:\n\nThe directory containing the script\nPYTHONPATH (if set)\nStandard library directories\nSite-packages directory (for installed third-party packages)\n\nYou can view the current module search path using:\nimport sys\nprint(sys.path)\n\n\n\n\nPATH: An environment variable that tells the operating system where to look for executables.\nPYTHONPATH: An environment variable that adds additional directories to Python’s module search path.\n\n\n\n\nTo import modules from the current directory:\n\nRun Python from the directory containing your modules:\npython my_script.py\nAdd the current directory to PYTHONPATH:\nexport PYTHONPATH=$PYTHONPATH:.\nNB: $PYTHONPATH is the current value of PYTHONPATH, doing like this will append the current directory (which is defined by . in bash) to the existing PYTHONPATH.\nModify sys.path in your script:\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.realpath(__file__)))\n\n\n\n\n\nAbsolute imports use the full path from the project’s root:\nfrom mypackage.submodule import myfunction\nRelative imports use dots to refer to the current and parent packages:\nfrom . import sibling_module\nfrom .. import parent_package_module\n\nAbsolute imports are generally preferred for clarity.\nCertainly! I’ll enhance the section on importing modules vs specific items to include this important detail. Here’s an improved version of that section:\n\n\n\nWhen importing in Python, it’s important to understand the difference between importing entire modules and importing specific items from modules. This distinction affects not only how you use the imported elements but also how Python executes the import process.\n\nImporting a module:\nimport mymodule\nmymodule.my_function()\nImporting specific items:\nfrom mymodule import my_function\nmy_function()\n\nKey points to understand:\n\nModule Execution: When you import a module (either the entire module or specific items), Python first executes the entire module from top to bottom. This happens regardless of whether you’re importing the whole module or just specific functions or classes.\nNamespace Differences:\n\nWhen importing the entire module, you need to use the module name as a prefix to access its contents (e.g., mymodule.my_function()).\nWhen importing specific items, they are brought directly into the current namespace, allowing you to use them without the module prefix (e.g., my_function()).\n\nImport Process:\n\nFor import mymodule:\n\nPython executes all code in mymodule.\nIt creates a namespace for mymodule in the current scope.\nYou access items through this namespace (e.g., mymodule.my_function()).\n\nFor from mymodule import my_function:\n\nPython executes all code in mymodule.\nIt locates my_function within mymodule.\nIt creates a reference to my_function in the current namespace.\n\n\nPerformance and Memory:\n\nImporting specific items doesn’t save on initial execution time or memory, as the entire module is still executed.\nHowever, it can make your code slightly faster when accessing the imported items, as there’s no need to go through the module namespace.\n\nPotential Pitfalls:\n\nImporting specific items can lead to naming conflicts if you import items with the same name from different modules.\nIt can also make it less clear where a function or class is coming from when reading the code.\n\n\n\n\n\nThe __init__.py file marks a directory as a Python package. It can be empty or contain initialization code. When you import a package, the __init__.py file is executed.\n\n\n\nSimplifying imports for package users:\n\n# mypackage/__init__.py\n\nfrom .database import Database\nfrom .models import User, Product\nfrom .utils import format_currency\n\n__all__ = ['Database', 'User', 'Product', 'format_currency']\nThis allows users to do:\nfrom mypackage import Database, User, Product\nInstead of:\nfrom mypackage.database import Database\nfrom mypackage.models import User, Product\n\nInitializing package-level resources:\n\n# mypackage/__init__.py\n\nimport logging\n\n# Set up package-level logger\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\n# Initialize package-wide configurations\nCONFIG = {\n    'API_VERSION': 'v1',\n    'BASE_URL': 'https://api.example.com'\n}\n\n# Perform any necessary package initialization\ndef initialize():\n    logger.info(\"Initializing mypackage...\")\n    # Perform any startup tasks here\n\ninitialize()\n\nVersion information and metadata:\n\n# mypackage/__init__.py\n\n__version__ = \"1.0.0\"\n__author__ = \"Your Name\"\n__license__ = \"MIT\"\n\n# You can even load version from a separate file\nfrom .version import __version__\n\n\n\n\n\nPython first looks for built-in modules.\nIf not found, it searches in the directories listed in sys.path.\nFor a package, Python executes the __init__.py file.\nFor a module, Python executes the entire file.\n\n\n\n\n\nImporting a module:\nimport mymodule\nmymodule.my_function()\nImporting specific items:\nfrom mymodule import my_function\nmy_function()\n\nImporting the entire module executes it but requires using the module name as a prefix. Importing specific items brings them directly into the current namespace.\n\n\n\nCircular imports occur when two modules import each other, directly or indirectly. Here’s a realistic example and how to resolve it:\nProject structure:\nmyproject/\n├── __init__.py\n├── models.py\n├── services.py\n└── utils.py\n# models.py\nfrom .services import DataService\n\nclass User:\n    def __init__(self, username):\n        self.username = username\n    \n    def get_data(self):\n        return DataService.fetch_user_data(self.username)\n\n# services.py\nfrom .models import User\nfrom .utils import format_data\n\nclass DataService:\n    @staticmethod\n    def fetch_user_data(username):\n        # Simulate fetching data\n        data = {username: \"some data\"}\n        return format_data(data)\n\n    @staticmethod\n    def create_user(username):\n        return User(username)\n\n# utils.py\ndef format_data(data):\n    return str(data).upper()\nThis creates a circular import between models.py and services.py. Resolve it using __init__.py:\n# __init__.py\n\n# First, import modules that don't have dependencies\nfrom . import utils\n\n# Then import modules with dependencies, but don't use them yet\nfrom . import models\nfrom . import services\n\n# Now set up the references\nmodels.DataService = services.DataService\nservices.User = models.User\n\n# Optionally, clean up the namespace\ndel models, services\n\n# Expose what you want at the package level\nfrom .models import User\nfrom .services import DataService\nfrom .utils import format_data\n\n__all__ = ['User', 'DataService', 'format_data']\nNow, users can simply do:\nfrom myproject import User, DataService\n\nuser = User(\"alice\")\ndata = user.get_data()\nnew_user = DataService.create_user(\"bob\")\nThis approach: 1. Breaks the circular dependency by importing modules in a specific order. 2. Sets up the necessary references after all modules are loaded. 3. Provides a clean, easy-to-use interface for the package users.\n\n\n\nUnderstanding Python’s import system is crucial for structuring projects effectively. Proper use of __init__.py files, careful management of imports, and awareness of potential circular dependencies will help you create well-organized, maintainable Python packages.",
    "crumbs": [
      "Understanding imports"
    ]
  },
  {
    "objectID": "content/Cours_5/2-Import.html#understanding-python-imports-and-package-structure",
    "href": "content/Cours_5/2-Import.html#understanding-python-imports-and-package-structure",
    "title": "Understanding imports",
    "section": "",
    "text": "When you use an import statement, Python searches for the module or package in several locations:\n\nThe directory containing the script\nPYTHONPATH (if set)\nStandard library directories\nSite-packages directory (for installed third-party packages)\n\nYou can view the current module search path using:\nimport sys\nprint(sys.path)\n\n\n\n\nPATH: An environment variable that tells the operating system where to look for executables.\nPYTHONPATH: An environment variable that adds additional directories to Python’s module search path.\n\n\n\n\nTo import modules from the current directory:\n\nRun Python from the directory containing your modules:\npython my_script.py\nAdd the current directory to PYTHONPATH:\nexport PYTHONPATH=$PYTHONPATH:.\nNB: $PYTHONPATH is the current value of PYTHONPATH, doing like this will append the current directory (which is defined by . in bash) to the existing PYTHONPATH.\nModify sys.path in your script:\nimport sys\nimport os\nsys.path.append(os.path.dirname(os.path.realpath(__file__)))\n\n\n\n\n\nAbsolute imports use the full path from the project’s root:\nfrom mypackage.submodule import myfunction\nRelative imports use dots to refer to the current and parent packages:\nfrom . import sibling_module\nfrom .. import parent_package_module\n\nAbsolute imports are generally preferred for clarity.\nCertainly! I’ll enhance the section on importing modules vs specific items to include this important detail. Here’s an improved version of that section:\n\n\n\nWhen importing in Python, it’s important to understand the difference between importing entire modules and importing specific items from modules. This distinction affects not only how you use the imported elements but also how Python executes the import process.\n\nImporting a module:\nimport mymodule\nmymodule.my_function()\nImporting specific items:\nfrom mymodule import my_function\nmy_function()\n\nKey points to understand:\n\nModule Execution: When you import a module (either the entire module or specific items), Python first executes the entire module from top to bottom. This happens regardless of whether you’re importing the whole module or just specific functions or classes.\nNamespace Differences:\n\nWhen importing the entire module, you need to use the module name as a prefix to access its contents (e.g., mymodule.my_function()).\nWhen importing specific items, they are brought directly into the current namespace, allowing you to use them without the module prefix (e.g., my_function()).\n\nImport Process:\n\nFor import mymodule:\n\nPython executes all code in mymodule.\nIt creates a namespace for mymodule in the current scope.\nYou access items through this namespace (e.g., mymodule.my_function()).\n\nFor from mymodule import my_function:\n\nPython executes all code in mymodule.\nIt locates my_function within mymodule.\nIt creates a reference to my_function in the current namespace.\n\n\nPerformance and Memory:\n\nImporting specific items doesn’t save on initial execution time or memory, as the entire module is still executed.\nHowever, it can make your code slightly faster when accessing the imported items, as there’s no need to go through the module namespace.\n\nPotential Pitfalls:\n\nImporting specific items can lead to naming conflicts if you import items with the same name from different modules.\nIt can also make it less clear where a function or class is coming from when reading the code.\n\n\n\n\n\nThe __init__.py file marks a directory as a Python package. It can be empty or contain initialization code. When you import a package, the __init__.py file is executed.\n\n\n\nSimplifying imports for package users:\n\n# mypackage/__init__.py\n\nfrom .database import Database\nfrom .models import User, Product\nfrom .utils import format_currency\n\n__all__ = ['Database', 'User', 'Product', 'format_currency']\nThis allows users to do:\nfrom mypackage import Database, User, Product\nInstead of:\nfrom mypackage.database import Database\nfrom mypackage.models import User, Product\n\nInitializing package-level resources:\n\n# mypackage/__init__.py\n\nimport logging\n\n# Set up package-level logger\nlogger = logging.getLogger(__name__)\nlogger.setLevel(logging.INFO)\n\n# Initialize package-wide configurations\nCONFIG = {\n    'API_VERSION': 'v1',\n    'BASE_URL': 'https://api.example.com'\n}\n\n# Perform any necessary package initialization\ndef initialize():\n    logger.info(\"Initializing mypackage...\")\n    # Perform any startup tasks here\n\ninitialize()\n\nVersion information and metadata:\n\n# mypackage/__init__.py\n\n__version__ = \"1.0.0\"\n__author__ = \"Your Name\"\n__license__ = \"MIT\"\n\n# You can even load version from a separate file\nfrom .version import __version__\n\n\n\n\n\nPython first looks for built-in modules.\nIf not found, it searches in the directories listed in sys.path.\nFor a package, Python executes the __init__.py file.\nFor a module, Python executes the entire file.\n\n\n\n\n\nImporting a module:\nimport mymodule\nmymodule.my_function()\nImporting specific items:\nfrom mymodule import my_function\nmy_function()\n\nImporting the entire module executes it but requires using the module name as a prefix. Importing specific items brings them directly into the current namespace.\n\n\n\nCircular imports occur when two modules import each other, directly or indirectly. Here’s a realistic example and how to resolve it:\nProject structure:\nmyproject/\n├── __init__.py\n├── models.py\n├── services.py\n└── utils.py\n# models.py\nfrom .services import DataService\n\nclass User:\n    def __init__(self, username):\n        self.username = username\n    \n    def get_data(self):\n        return DataService.fetch_user_data(self.username)\n\n# services.py\nfrom .models import User\nfrom .utils import format_data\n\nclass DataService:\n    @staticmethod\n    def fetch_user_data(username):\n        # Simulate fetching data\n        data = {username: \"some data\"}\n        return format_data(data)\n\n    @staticmethod\n    def create_user(username):\n        return User(username)\n\n# utils.py\ndef format_data(data):\n    return str(data).upper()\nThis creates a circular import between models.py and services.py. Resolve it using __init__.py:\n# __init__.py\n\n# First, import modules that don't have dependencies\nfrom . import utils\n\n# Then import modules with dependencies, but don't use them yet\nfrom . import models\nfrom . import services\n\n# Now set up the references\nmodels.DataService = services.DataService\nservices.User = models.User\n\n# Optionally, clean up the namespace\ndel models, services\n\n# Expose what you want at the package level\nfrom .models import User\nfrom .services import DataService\nfrom .utils import format_data\n\n__all__ = ['User', 'DataService', 'format_data']\nNow, users can simply do:\nfrom myproject import User, DataService\n\nuser = User(\"alice\")\ndata = user.get_data()\nnew_user = DataService.create_user(\"bob\")\nThis approach: 1. Breaks the circular dependency by importing modules in a specific order. 2. Sets up the necessary references after all modules are loaded. 3. Provides a clean, easy-to-use interface for the package users.\n\n\n\nUnderstanding Python’s import system is crucial for structuring projects effectively. Proper use of __init__.py files, careful management of imports, and awareness of potential circular dependencies will help you create well-organized, maintainable Python packages.",
    "crumbs": [
      "Understanding imports"
    ]
  },
  {
    "objectID": "content/Cours_2/4-Dunder.html",
    "href": "content/Cours_2/4-Dunder.html",
    "title": "Méthodes Dunder en Python",
    "section": "",
    "text": "Les méthodes dunder en Python\n\nLes méthodes dunder sont encadrées par des doubles tirets bas (__) et sont appelées automatiquement par Python dans certaines circonstances.\n\n1. Initialisation et destruction\n\ninit(self, …)\n\nAppelée lors de la création d’une instance.\nInitialise les attributs de l’objet.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\ndel(self)\n\nAppelée lorsque l’objet est sur le point d’être détruit.\nUtile pour le nettoyage de ressources.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n2. Représentation des objets\n\nstr(self)\n\nRetourne une représentation lisible de l’objet.\nUtilisée par str() et print().\n\n\n\nrepr(self)\n\nRetourne une représentation “officielle” de l’objet.\nUtilisée par repr() et dans l’interpréteur interactif.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n3. Opérations mathématiques\n\nadd(self, other), sub(self, other), mul(self, other), truediv(self, other)\n\nDéfinissent les opérations +, -, *, / respectivement.\n\n\n\nfloordiv(self, other), mod(self, other), pow(self, other)\n\nDéfinissent les opérations //, %, ** respectivement.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n4. Comparaisons\n\neq(self, other), ne(self, other)\n\nDéfinissent == et != respectivement.\n\n\n\nlt(self, other), le(self, other), gt(self, other), ge(self, other)\n\nDéfinissent &lt;, &lt;=, &gt;, &gt;= respectivement.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n5. Conteneurs et séquences\n\nlen(self)\n\nRetourne la longueur de l’objet.\nUtilisée par la fonction len().\n\n\n\ngetitem(self, key)\n\nPermet l’accès par index ou clé.\nUtilisée pour l’indexation obj[key].\n\n\n\nsetitem(self, key, value)\n\nPermet l’assignation par index ou clé.\n\n\n\niter(self)\n\nRetourne un itérateur pour l’objet.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n6. Gestion des attributs\n\ngetattr(self, name)\n\nAppelée lorsqu’un attribut non trouvé est accédé.\n\n\n\nsetattr(self, name, value)\n\nAppelée lors de l’assignation d’un attribut.\n\n\n\ndelattr(self, name)\n\nAppelée lors de la suppression d’un attribut.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n7. Appel de l’objet comme une fonction\n\ncall(self, …)\n\nPermet d’appeler l’objet comme une fonction.\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n8. Gestion du contexte\n\nenter(self), exit(self, exc_type, exc_value, traceback)\n\nUtilisées pour le gestionnaire de contexte (with statement).\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n9. Autres méthodes dunder utiles\n\nbool(self): Définit le comportement pour bool().\nhash(self): Permet à l’objet d’être utilisé comme clé de dictionnaire.\nformat(self, format_spec): Personnalise le formatage de chaînes.\n\nCette liste, bien que non exhaustive, couvre la plupart des méthodes dunder couramment utilisées en Python. Chacune de ces méthodes permet de personnaliser le comportement des objets dans différents contextes, rendant le langage extrêmement flexible et puissant.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Méthodes Dunder en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/TP.html",
    "href": "content/Cours_2/TP.html",
    "title": "TP",
    "section": "",
    "text": "TODO\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "TP"
    ]
  },
  {
    "objectID": "content/Cours_2/3-Composition.html",
    "href": "content/Cours_2/3-Composition.html",
    "title": "Héritage vs Composition",
    "section": "",
    "text": "Héritage vs Composition\n\n\nDéfinitions\n\nHéritage : Une relation “est-un” où une classe dérive d’une autre, héritant de ses attributs et méthodes.\nComposition : Une relation “a-un” où une classe contient une instance d’une autre classe comme attribut.\n\n\n\nComparaison\n\nHéritage\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nComposition\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nAvantages et inconvénients\n\nHéritage\nAvantages : - Permet une réutilisation directe du code - Représente bien les relations hiérarchiques naturelles - Facilite le polymorphisme\nInconvénients : - Peut créer un couplage fort entre les classes - Peut devenir complexe avec l’héritage multiple - Peut violer le principe de substitution de Liskov si mal utilisé\n\n\nComposition\nAvantages : - Offre une plus grande flexibilité - Permet une meilleure encapsulation - Facilite les changements de comportement à l’exécution\nInconvénients : - Peut nécessiter plus de code initial - Peut être moins intuitif pour représenter certaines relations\n\n\n\nQuand utiliser l’un ou l’autre ?\n\nUtilisez l’héritage quand :\n\nIl existe une relation “est-un” claire et logique\nVous voulez réutiliser le code dans plusieurs classes dérivées\nLe comportement de la classe de base ne change pas souvent\n\nExemple : Chien est un Animal, Carré est une Forme\nUtilisez la composition quand :\n\nIl existe une relation “a-un” ou “utilise-un”\nVous voulez une plus grande flexibilité pour changer les comportements\nVous voulez éviter les problèmes liés à l’héritage multiple\n\nExemple : Voiture a un Moteur, Ordinateur a une CPU\n\n\n\nPrincipe de conception : “Favoriser la composition sur l’héritage”\nCe principe suggère d’utiliser la composition comme première approche, car elle offre généralement plus de flexibilité et un couplage plus faible. L’héritage devrait être utilisé judicieusement, lorsqu’il représente vraiment une relation “est-un”.\n\n\nExemple combinant héritage et composition\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nDans cet exemple : - Epee hérite de Arme (relation “est-un”) - Guerrier hérite de Personnage (relation “est-un”) - Personnage utilise la composition avec Arme (relation “a-un”)\nCette approche combine les avantages de l’héritage et de la composition, permettant une structure flexible et extensible.\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Héritage vs Composition"
    ]
  },
  {
    "objectID": "content/Cours_2/1-Encapsulation.html",
    "href": "content/Cours_2/1-Encapsulation.html",
    "title": "Encapsulation en Python",
    "section": "",
    "text": "Encapsulation en Python\n\nL’encapsulation est l’un des principes fondamentaux de la programmation orientée objet. Elle consiste à regrouper les données et les méthodes qui les manipulent au sein d’une même unité (la classe) et à contrôler l’accès à ces données depuis l’extérieur de la classe.\n\nNotion de public et privé en Python\nContrairement à certains langages comme Java ou C++, Python n’a pas de mécanisme strict pour définir des attributs ou des méthodes comme “privés” ou “publics”. Cependant, Python suit une convention basée sur le nommage pour indiquer l’intention du développeur quant à l’utilisation des attributs et méthodes.\n\nAttributs et méthodes publics :\n\nNommés normalement, sans underscore.\nExemple : self.attribut, def methode(self):\nConsidérés comme faisant partie de l’interface publique de la classe.\n\nAttributs et méthodes “privés” (convention) :\n\nPréfixés par un simple underscore _.\nExemple : self._attribut, def _methode(self):\nIndique que ces éléments sont destinés à un usage interne et ne devraient pas être accédés directement depuis l’extérieur de la classe.\nCette convention est basée sur la confiance : techniquement, ces éléments restent accessibles.\n\nAttributs et méthodes “name mangling” :\n\nPréfixés par un double underscore __ (sans underscore à la fin).\nExemple : self.__attribut, def __methode(self):\nPython applique le “name mangling” : le nom est modifié en interne pour inclure le nom de la classe.\nRend l’accès depuis l’extérieur plus difficile, mais pas impossible.\n\n\n\n\nExemple d’encapsulation en Python\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\nPoints importants à retenir :\n\nL’encapsulation en Python est basée sur des conventions plutôt que sur des restrictions strictes.\nLes attributs et méthodes préfixés par un underscore _ sont considérés comme internes à la classe.\nLe double underscore __ déclenche le name mangling, rendant l’accès externe plus difficile mais pas impossible.\nL’encapsulation est une question de conception et de discipline de programmation en Python.\nUtilisez des méthodes publiques (getters/setters) pour contrôler l’accès aux données internes si nécessaire.\n\n\n\nAvantages de l’encapsulation :\n\nContrôle de l’accès aux données\nFlexibilité pour modifier l’implémentation interne sans affecter le code qui utilise la classe\nPrévention des modifications accidentelles des données internes\nClarté du code en distinguant l’interface publique des détails d’implémentation\n\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Encapsulation en Python"
    ]
  },
  {
    "objectID": "content/Cours_2/index.html",
    "href": "content/Cours_2/index.html",
    "title": "Encapsulation, Heritage, Composition et Dunder",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEncapsulation en Python\n\n\nComprendre l’encapsulation en Python et les conventions pour définir des attributs et méthodes publics et privés.\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHéritage en Python : Concept et intérêt\n\n\nDécouvrez le concept d’héritage en Python, son intérêt et son application dans la création de hiérarchies de classes. Apprenez comment Python gère l’héritage implicite de la…\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHéritage vs Composition\n\n\nDécouvrez les différences entre l’héritage et la composition en programmation orientée objet, leurs avantages et inconvénients, et comment choisir la meilleure approche pour…\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nMéthodes Dunder en Python\n\n\nDécouvrez les méthodes dunder en Python, des méthodes spéciales encadrées par des doubles tirets bas (__), qui permettent de personnaliser le comportement des objets dans…\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP\n\n\n\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Encapsulation, Heritage, Composition et Dunder"
    ]
  },
  {
    "objectID": "content/Cours_2/2-Heritage.html",
    "href": "content/Cours_2/2-Heritage.html",
    "title": "Héritage en Python : Concept et intérêt",
    "section": "",
    "text": "L’héritage est un mécanisme fondamental de la programmation orientée objet qui permet à une classe de baser sa définition sur celle d’une autre classe. Cela favorise la réutilisation du code et permet de créer des hiérarchies de classes.\n\n\n\nRéutilisation du code : L’héritage permet d’éviter la duplication de code en définissant des comportements communs dans une classe parente.\nOrganisation logique : Il permet de créer des hiérarchies de classes qui reflètent des relations logiques entre concepts.\nExtensibilité : Les classes dérivées peuvent étendre ou modifier le comportement des classes parentes, rendant le code plus flexible.\nPolymorphisme : L’héritage est à la base du polymorphisme, permettant de traiter des objets de classes différentes de manière uniforme.\n\n\n\n\nEn Python, toutes les classes héritent implicitement de la classe object, même si ce n’est pas spécifié explicitement.\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nL’héritage de object fournit des méthodes de base comme __init__, __str__, __repr__, etc. C’est pourquoi toutes les classes en Python ont certaines méthodes en commun.\n\n\n\nPython supporte l’héritage multiple, ce qui signifie qu’une classe peut hériter de plusieurs classes parentes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nCombinaison de fonctionnalités : Permet de combiner des fonctionnalités de différentes classes en une seule.\nRéutilisation de code provenant de sources multiples : Utile lorsqu’une classe doit hériter de comportements de plusieurs classes non liées.\nImplémentation de designs complexes : Permet de créer des structures de classes plus flexibles et adaptables.\n\nExemple concret :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, Canard hérite des capacités de Nageur et Volant, combinant ainsi ces deux comportements.\n\n\n\n\nLa MRO est cruciale pour comprendre comment Python gère l’héritage, en particulier l’héritage multiple.\n\n\nLa MRO définit l’ordre dans lequel Python recherche les méthodes et les attributs dans une hiérarchie de classes. Elle est particulièrement importante en cas d’héritage multiple, où plusieurs classes parentes peuvent définir la même méthode.\n\n\n\nPython utilise l’algorithme C3 pour déterminer la MRO. Cet algorithme garantit que :\n\nLes sous-classes apparaissent avant les classes parentes.\nL’ordre de déclaration des classes parentes est respecté.\nLa MRO est monotone (une classe apparaît toujours avant ses parents).\n\n\n\n\nOn peut visualiser la MRO d’une classe avec la méthode mro() ou l’attribut __mro__ :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nConsidérons cet exemple pour illustrer comment la MRO fonctionne :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, D hérite de B et C. Lorsque d.methode() est appelé, Python suit la MRO : D -&gt; B -&gt; C -&gt; A -&gt; object. Il trouve d’abord la méthode dans B, donc c’est celle-ci qui est exécutée.\n\n\n\nLa compréhension de la MRO est cruciale pour : - Éviter les conflits de noms dans l’héritage multiple. - Comprendre l’ordre d’exécution des méthodes. - Concevoir des hiérarchies de classes cohérentes et prévisibles.",
    "crumbs": [
      "Héritage en Python : Concept et intérêt"
    ]
  },
  {
    "objectID": "content/Cours_2/2-Heritage.html#héritage-multiple-en-python",
    "href": "content/Cours_2/2-Heritage.html#héritage-multiple-en-python",
    "title": "Héritage en Python : Concept et intérêt",
    "section": "",
    "text": "Python supporte l’héritage multiple, ce qui signifie qu’une classe peut hériter de plusieurs classes parentes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nCombinaison de fonctionnalités : Permet de combiner des fonctionnalités de différentes classes en une seule.\nRéutilisation de code provenant de sources multiples : Utile lorsqu’une classe doit hériter de comportements de plusieurs classes non liées.\nImplémentation de designs complexes : Permet de créer des structures de classes plus flexibles et adaptables.\n\nExemple concret :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, Canard hérite des capacités de Nageur et Volant, combinant ainsi ces deux comportements.",
    "crumbs": [
      "Héritage en Python : Concept et intérêt"
    ]
  },
  {
    "objectID": "content/Cours_2/2-Heritage.html#method-resolution-order-mro-en-détail",
    "href": "content/Cours_2/2-Heritage.html#method-resolution-order-mro-en-détail",
    "title": "Héritage en Python : Concept et intérêt",
    "section": "",
    "text": "La MRO est cruciale pour comprendre comment Python gère l’héritage, en particulier l’héritage multiple.\n\n\nLa MRO définit l’ordre dans lequel Python recherche les méthodes et les attributs dans une hiérarchie de classes. Elle est particulièrement importante en cas d’héritage multiple, où plusieurs classes parentes peuvent définir la même méthode.\n\n\n\nPython utilise l’algorithme C3 pour déterminer la MRO. Cet algorithme garantit que :\n\nLes sous-classes apparaissent avant les classes parentes.\nL’ordre de déclaration des classes parentes est respecté.\nLa MRO est monotone (une classe apparaît toujours avant ses parents).\n\n\n\n\nOn peut visualiser la MRO d’une classe avec la méthode mro() ou l’attribut __mro__ :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nConsidérons cet exemple pour illustrer comment la MRO fonctionne :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIci, D hérite de B et C. Lorsque d.methode() est appelé, Python suit la MRO : D -&gt; B -&gt; C -&gt; A -&gt; object. Il trouve d’abord la méthode dans B, donc c’est celle-ci qui est exécutée.\n\n\n\nLa compréhension de la MRO est cruciale pour : - Éviter les conflits de noms dans l’héritage multiple. - Comprendre l’ordre d’exécution des méthodes. - Concevoir des hiérarchies de classes cohérentes et prévisibles.",
    "crumbs": [
      "Héritage en Python : Concept et intérêt"
    ]
  },
  {
    "objectID": "content/Cours_5/3-Packaging_and_environment.html",
    "href": "content/Cours_5/3-Packaging_and_environment.html",
    "title": "Python Package Management and Virtual Environments",
    "section": "",
    "text": "When developing Python projects, managing dependencies and isolating environments are crucial. There are several tools available for these tasks:\n\n\n\npip: The standard package installer for Python.\nPoetry: A modern dependency management and packaging tool.\nConda: A package, dependency, and environment management system (popular in data science).\n\n\n\n\n\nvenv: Built-in Python module for creating virtual environments.\npyenv: Allows you to easily switch between multiple versions of Python.\nvirtualenv: A tool to create isolated Python environments (precursor to venv).\n\nLet’s focus on pip, venv, and an introduction to Poetry.\n\n\n\n\nCreate a virtual environment:\npython -m venv myenv\nActivate the environment:\n\nWindows: myenv\\Scripts\\activate\nmacOS/Linux: source myenv/bin/activate\n\nInstall packages:\npip install package_name\nCreate a requirements.txt file:\npip freeze &gt; requirements.txt\nInstall from requirements.txt:\npip install -r requirements.txt\n\n\n\n\nPoetry is a more modern tool that combines dependency management, package building, and publishing.\n\nInstall Poetry:\npip install poetry\nCreate a new project or initialize an existing one:\npoetry new myproject\n# or\npoetry init\nAdd dependencies:\npoetry add package_name\nInstall dependencies:\npoetry install\n\n\n\n\nPoetry uses pyproject.toml for project configuration. Here’s a simple example:\n[tool.poetry]\nname = \"myproject\"\nversion = \"0.1.0\"\ndescription = \"A sample Python project\"\nauthors = [\"Your Name &lt;you@example.com&gt;\"]\n\n[tool.poetry.dependencies]\npython = \"^3.9\"\nrequests = \"^2.26.0\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^6.2.5\"\nThis file defines your project’s metadata and dependencies.\n\n\n\nBuilding a package means creating a distribution that can be installed by pip. Publishing means uploading this distribution to a package index like PyPI.\n\nBuild your package:\npoetry build\nThis creates distribution files in the dist/ directory.\nPublish to PyPI:\npoetry publish\nThis uploads your built package to PyPI, making it available for others to install.\n\nPoetry simplifies these processes, handling the complexities of building and publishing for you.",
    "crumbs": [
      "Python Package Management and Virtual Environments"
    ]
  },
  {
    "objectID": "content/Cours_5/3-Packaging_and_environment.html#python-package-management-and-virtual-environments",
    "href": "content/Cours_5/3-Packaging_and_environment.html#python-package-management-and-virtual-environments",
    "title": "Python Package Management and Virtual Environments",
    "section": "",
    "text": "When developing Python projects, managing dependencies and isolating environments are crucial. There are several tools available for these tasks:\n\n\n\npip: The standard package installer for Python.\nPoetry: A modern dependency management and packaging tool.\nConda: A package, dependency, and environment management system (popular in data science).\n\n\n\n\n\nvenv: Built-in Python module for creating virtual environments.\npyenv: Allows you to easily switch between multiple versions of Python.\nvirtualenv: A tool to create isolated Python environments (precursor to venv).\n\nLet’s focus on pip, venv, and an introduction to Poetry.\n\n\n\n\nCreate a virtual environment:\npython -m venv myenv\nActivate the environment:\n\nWindows: myenv\\Scripts\\activate\nmacOS/Linux: source myenv/bin/activate\n\nInstall packages:\npip install package_name\nCreate a requirements.txt file:\npip freeze &gt; requirements.txt\nInstall from requirements.txt:\npip install -r requirements.txt\n\n\n\n\nPoetry is a more modern tool that combines dependency management, package building, and publishing.\n\nInstall Poetry:\npip install poetry\nCreate a new project or initialize an existing one:\npoetry new myproject\n# or\npoetry init\nAdd dependencies:\npoetry add package_name\nInstall dependencies:\npoetry install\n\n\n\n\nPoetry uses pyproject.toml for project configuration. Here’s a simple example:\n[tool.poetry]\nname = \"myproject\"\nversion = \"0.1.0\"\ndescription = \"A sample Python project\"\nauthors = [\"Your Name &lt;you@example.com&gt;\"]\n\n[tool.poetry.dependencies]\npython = \"^3.9\"\nrequests = \"^2.26.0\"\n\n[tool.poetry.dev-dependencies]\npytest = \"^6.2.5\"\nThis file defines your project’s metadata and dependencies.\n\n\n\nBuilding a package means creating a distribution that can be installed by pip. Publishing means uploading this distribution to a package index like PyPI.\n\nBuild your package:\npoetry build\nThis creates distribution files in the dist/ directory.\nPublish to PyPI:\npoetry publish\nThis uploads your built package to PyPI, making it available for others to install.\n\nPoetry simplifies these processes, handling the complexities of building and publishing for you.",
    "crumbs": [
      "Python Package Management and Virtual Environments"
    ]
  },
  {
    "objectID": "content/Cours_5/4-Tests.html",
    "href": "content/Cours_5/4-Tests.html",
    "title": "Unit Testing in Python",
    "section": "",
    "text": "Unit testing is a software development practice where individual components or functions of a program are tested in isolation. The primary goals of unit testing are:\n\nTo verify that each part of the program works correctly on its own.\nTo catch and fix bugs early in the development process.\nTo facilitate refactoring and maintenance of code.\nTo serve as documentation for how components should behave.\n\nA unit test typically follows this pattern: 1. Set up the test conditions. 2. Call the function or method being tested. 3. Assert that the output or behavior matches the expected result.\nPython offers several frameworks to help write and run unit tests efficiently. While the built-in unittest module is available, many developers prefer pytest for its simplicity and powerful features.\n\n\n\nunittest: Python’s built-in testing framework.\npytest: A more advanced, feature-rich testing framework.\nnose: An extension of unittest (less common nowadays).\n\nWe’ll focus on pytest due to its popularity and ease of use, especially when integrated with modern Python project management tools like Poetry.\n\n\n\n\nInstall pytest:\npip install pytest\nWrite a test file (e.g., test_example.py):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nRun tests:\npytest\n\n\n\n\n\nAdd pytest to your project’s dev-dependencies:\npoetry add --dev pytest\nUpdate your pyproject.toml:\n[tool.poetry.dev-dependencies]\npytest = \"^7.4.0\"\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\nThis configuration tells pytest to look for tests in the tests directory.\nOrganize your project structure:\nmyproject/\n├── src/\n│   └── mypackage/\n│       └── example.py\n├── tests/\n│   └── test_example.py\n└── pyproject.toml\nWrite your tests in the tests directory.\nRun tests using Poetry:\npoetry run pytest\n\n\n\n\nYou can add more options to your pyproject.toml:\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\naddopts = \"-v --cov=src\"\nThis configuration: - Runs tests verbosely (-v) - Includes coverage reporting (--cov=src)\n\n\n\nTo make running tests easier, you can add a script to your pyproject.toml:\n[tool.poetry.scripts]\ntest = \"pytest\"\nNow you can run tests with:\npoetry run test\n\n\n\nFor CI/CD pipelines, you can use Poetry to install dependencies and run tests:\n# Example GitHub Actions workflow\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: 3.9\n    - name: Install dependencies\n      run: |\n        pip install poetry\n        poetry install\n    - name: Run tests\n      run: poetry run pytest\nThis setup ensures your tests are run automatically on every push or pull request.\n\n\n\n\nWrite tests for all new features and bug fixes.\nAim for high test coverage, but focus on critical paths.\nUse meaningful test names that describe the behavior being tested.\nKeep tests independent and avoid dependencies between tests.\nUse fixtures and parametrization to reduce code duplication in tests.\n\nBy integrating pytest with Poetry, you create a streamlined development workflow where dependency management, building, and testing are all handled by a single tool.",
    "crumbs": [
      "Unit Testing in Python"
    ]
  },
  {
    "objectID": "content/Cours_5/4-Tests.html#unit-testing-in-python",
    "href": "content/Cours_5/4-Tests.html#unit-testing-in-python",
    "title": "Unit Testing in Python",
    "section": "",
    "text": "Unit testing is a software development practice where individual components or functions of a program are tested in isolation. The primary goals of unit testing are:\n\nTo verify that each part of the program works correctly on its own.\nTo catch and fix bugs early in the development process.\nTo facilitate refactoring and maintenance of code.\nTo serve as documentation for how components should behave.\n\nA unit test typically follows this pattern: 1. Set up the test conditions. 2. Call the function or method being tested. 3. Assert that the output or behavior matches the expected result.\nPython offers several frameworks to help write and run unit tests efficiently. While the built-in unittest module is available, many developers prefer pytest for its simplicity and powerful features.\n\n\n\nunittest: Python’s built-in testing framework.\npytest: A more advanced, feature-rich testing framework.\nnose: An extension of unittest (less common nowadays).\n\nWe’ll focus on pytest due to its popularity and ease of use, especially when integrated with modern Python project management tools like Poetry.\n\n\n\n\nInstall pytest:\npip install pytest\nWrite a test file (e.g., test_example.py):\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nRun tests:\npytest\n\n\n\n\n\nAdd pytest to your project’s dev-dependencies:\npoetry add --dev pytest\nUpdate your pyproject.toml:\n[tool.poetry.dev-dependencies]\npytest = \"^7.4.0\"\n\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\nThis configuration tells pytest to look for tests in the tests directory.\nOrganize your project structure:\nmyproject/\n├── src/\n│   └── mypackage/\n│       └── example.py\n├── tests/\n│   └── test_example.py\n└── pyproject.toml\nWrite your tests in the tests directory.\nRun tests using Poetry:\npoetry run pytest\n\n\n\n\nYou can add more options to your pyproject.toml:\n[tool.pytest.ini_options]\ntestpaths = [\"tests\"]\naddopts = \"-v --cov=src\"\nThis configuration: - Runs tests verbosely (-v) - Includes coverage reporting (--cov=src)\n\n\n\nTo make running tests easier, you can add a script to your pyproject.toml:\n[tool.poetry.scripts]\ntest = \"pytest\"\nNow you can run tests with:\npoetry run test\n\n\n\nFor CI/CD pipelines, you can use Poetry to install dependencies and run tests:\n# Example GitHub Actions workflow\njobs:\n  test:\n    runs-on: ubuntu-latest\n    steps:\n    - uses: actions/checkout@v2\n    - name: Set up Python\n      uses: actions/setup-python@v2\n      with:\n        python-version: 3.9\n    - name: Install dependencies\n      run: |\n        pip install poetry\n        poetry install\n    - name: Run tests\n      run: poetry run pytest\nThis setup ensures your tests are run automatically on every push or pull request.\n\n\n\n\nWrite tests for all new features and bug fixes.\nAim for high test coverage, but focus on critical paths.\nUse meaningful test names that describe the behavior being tested.\nKeep tests independent and avoid dependencies between tests.\nUse fixtures and parametrization to reduce code duplication in tests.\n\nBy integrating pytest with Poetry, you create a streamlined development workflow where dependency management, building, and testing are all handled by a single tool.",
    "crumbs": [
      "Unit Testing in Python"
    ]
  },
  {
    "objectID": "content/Cours_5/TP.html",
    "href": "content/Cours_5/TP.html",
    "title": "TP",
    "section": "",
    "text": "TODO\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "TP"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html",
    "href": "content/Cours_1/2-Structuration_des_donnees.html",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Au début de la programmation, les données étaient stockées de manière simple, souvent sous forme de variables individuelles. Avec la complexification des problèmes, le besoin de regrouper et d’organiser les données est devenu évident.\nExemple simple en C++ :\nstring nom = \"Dubois\";\nstring prenom = \"Marie\";\nint age = 20;\nfloat moyenne = 15.5;\nCette approche devient vite difficile à gérer pour de nombreux étudiants ou plus d’informations.\n\n\n\n\n\nUn tableau est une collection d’éléments de même type, accessibles par un index.\n\n\n\nint notes[5] = {12, 15, 18, 10, 14};\ncout &lt;&lt; \"La troisième note est : \" &lt;&lt; notes[2] &lt;&lt; endl;  // Affiche 18\n\n\n\n\nStockage efficace de multiples éléments de même type\nAccès rapide aux éléments par leur position\nTous les éléments doivent être du même type\nTaille souvent fixe à la compilation en C++\n\n\n\n\n\nLes structures permettent de regrouper des données de types différents qui sont logiquement liées.\n\n\nstruct Etudiant {\n    string nom;\n    string prenom;\n    int age;\n    float moyenne;\n};\n\nEtudiant marie = {\"Dubois\", \"Marie\", 20, 15.5};\ncout &lt;&lt; marie.prenom &lt;&lt; \" \" &lt;&lt; marie.nom &lt;&lt; \" a \" &lt;&lt; marie.age &lt;&lt; \" ans\" &lt;&lt; endl;\n\n\n\n\nReprésentation d’entités complexes de manière plus naturelle\nRegroupement logique des données liées\nAmélioration de la lisibilité et de l’organisation du code\n\n\n\n\n\nPascal a introduit le concept de “record”, similaire aux structures en C++, mais avec quelques différences syntaxiques et conceptuelles.\n\n\ntype\n  Etudiant = record\n    nom: string[50];\n    prenom: string[50];\n    age: integer;\n    moyenne: real;\n  end;\n\nvar\n  marie: Etudiant;\n\nbegin\n  marie.nom := 'Dubois';\n  marie.prenom := 'Marie';\n  marie.age := 20;\n  marie.moyenne := 15.5;\n  \n  writeln(marie.prenom, ' ', marie.nom, ' a ', marie.age, ' ans');\nend.\n\n\n\n\nTypage fort : Pascal est connu pour son système de typage strict\nDéclaration explicite des types : Améliore la clarté et la sécurité du code\nUtilisé dans un langage conçu pour l’enseignement : Syntax claire et lisible\n\n\n\n\n\nModula-2, successeur de Pascal, a introduit le concept de modules, une étape importante vers l’encapsulation.\n\n\nUn module en Modula-2 est une unité de programme qui regroupe des définitions de types, des variables et des procédures liées.\n\n\n\nMODULE GestionEtudiants;\n\nEXPORT Etudiant, CreerEtudiant, AfficherEtudiant;\n\nTYPE\n  Etudiant = RECORD\n    nom: ARRAY[0..49] OF CHAR;\n    prenom: ARRAY[0..49] OF CHAR;\n    age: INTEGER;\n    moyenne: REAL;\n  END;\n\nPROCEDURE CreerEtudiant(VAR e: Etudiant; n, p: ARRAY OF CHAR; a: INTEGER; m: REAL);\nBEGIN\n  (* Code pour initialiser un étudiant *)\nEND CreerEtudiant;\n\nPROCEDURE AfficherEtudiant(e: Etudiant);\nBEGIN\n  (* Code pour afficher les informations d'un étudiant *)\nEND AfficherEtudiant;\n\nEND GestionEtudiants.\n\n\n\n\nEncapsulation : Regroupement des données et des opérations liées\nSéparation interface/implémentation : Distinction entre ce qui est public et privé\nRéutilisabilité : Facilite la réutilisation du code dans différents programmes\n\n\n\n\n\nCes évolutions dans la structuration des données ont eu plusieurs effets positifs :\n\nModélisation plus fidèle du monde réel\nAmélioration de la lisibilité et de la maintenabilité du code\nIntroduction de l’abstraction des données\nPrémices de l’encapsulation (particulièrement avec les modules)\n\n\n\n\nMalgré ces avancées, certaines limitations persistaient : - Manque de mécanismes pour l’extension et la spécialisation des structures - Absence de polymorphisme\nCes limitations ont ouvert la voie à la programmation orientée objet, qui intégrera ces concepts de manière plus complète et flexible.\n\n\n\nLa structuration des données, à travers les tableaux, les structures, les records et les modules, a posé les bases conceptuelles nécessaires à l’émergence de la programmation orientée objet. Cette évolution a permis de mieux organiser et représenter l’information, préparant le terrain pour des paradigmes plus avancés.",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#le-besoin-de-structurer-les-données",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#le-besoin-de-structurer-les-données",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Au début de la programmation, les données étaient stockées de manière simple, souvent sous forme de variables individuelles. Avec la complexification des problèmes, le besoin de regrouper et d’organiser les données est devenu évident.\nExemple simple en C++ :\nstring nom = \"Dubois\";\nstring prenom = \"Marie\";\nint age = 20;\nfloat moyenne = 15.5;\nCette approche devient vite difficile à gérer pour de nombreux étudiants ou plus d’informations.",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#les-tableaux-première-forme-de-structuration",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#les-tableaux-première-forme-de-structuration",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Un tableau est une collection d’éléments de même type, accessibles par un index.\n\n\n\nint notes[5] = {12, 15, 18, 10, 14};\ncout &lt;&lt; \"La troisième note est : \" &lt;&lt; notes[2] &lt;&lt; endl;  // Affiche 18\n\n\n\n\nStockage efficace de multiples éléments de même type\nAccès rapide aux éléments par leur position\nTous les éléments doivent être du même type\nTaille souvent fixe à la compilation en C++",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#les-structures-en-c",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#les-structures-en-c",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Les structures permettent de regrouper des données de types différents qui sont logiquement liées.\n\n\nstruct Etudiant {\n    string nom;\n    string prenom;\n    int age;\n    float moyenne;\n};\n\nEtudiant marie = {\"Dubois\", \"Marie\", 20, 15.5};\ncout &lt;&lt; marie.prenom &lt;&lt; \" \" &lt;&lt; marie.nom &lt;&lt; \" a \" &lt;&lt; marie.age &lt;&lt; \" ans\" &lt;&lt; endl;\n\n\n\n\nReprésentation d’entités complexes de manière plus naturelle\nRegroupement logique des données liées\nAmélioration de la lisibilité et de l’organisation du code",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#les-records-en-pascal",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#les-records-en-pascal",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Pascal a introduit le concept de “record”, similaire aux structures en C++, mais avec quelques différences syntaxiques et conceptuelles.\n\n\ntype\n  Etudiant = record\n    nom: string[50];\n    prenom: string[50];\n    age: integer;\n    moyenne: real;\n  end;\n\nvar\n  marie: Etudiant;\n\nbegin\n  marie.nom := 'Dubois';\n  marie.prenom := 'Marie';\n  marie.age := 20;\n  marie.moyenne := 15.5;\n  \n  writeln(marie.prenom, ' ', marie.nom, ' a ', marie.age, ' ans');\nend.\n\n\n\n\nTypage fort : Pascal est connu pour son système de typage strict\nDéclaration explicite des types : Améliore la clarté et la sécurité du code\nUtilisé dans un langage conçu pour l’enseignement : Syntax claire et lisible",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#les-modules-en-modula-2",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#les-modules-en-modula-2",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Modula-2, successeur de Pascal, a introduit le concept de modules, une étape importante vers l’encapsulation.\n\n\nUn module en Modula-2 est une unité de programme qui regroupe des définitions de types, des variables et des procédures liées.\n\n\n\nMODULE GestionEtudiants;\n\nEXPORT Etudiant, CreerEtudiant, AfficherEtudiant;\n\nTYPE\n  Etudiant = RECORD\n    nom: ARRAY[0..49] OF CHAR;\n    prenom: ARRAY[0..49] OF CHAR;\n    age: INTEGER;\n    moyenne: REAL;\n  END;\n\nPROCEDURE CreerEtudiant(VAR e: Etudiant; n, p: ARRAY OF CHAR; a: INTEGER; m: REAL);\nBEGIN\n  (* Code pour initialiser un étudiant *)\nEND CreerEtudiant;\n\nPROCEDURE AfficherEtudiant(e: Etudiant);\nBEGIN\n  (* Code pour afficher les informations d'un étudiant *)\nEND AfficherEtudiant;\n\nEND GestionEtudiants.\n\n\n\n\nEncapsulation : Regroupement des données et des opérations liées\nSéparation interface/implémentation : Distinction entre ce qui est public et privé\nRéutilisabilité : Facilite la réutilisation du code dans différents programmes",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#impact-sur-la-programmation",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#impact-sur-la-programmation",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Ces évolutions dans la structuration des données ont eu plusieurs effets positifs :\n\nModélisation plus fidèle du monde réel\nAmélioration de la lisibilité et de la maintenabilité du code\nIntroduction de l’abstraction des données\nPrémices de l’encapsulation (particulièrement avec les modules)",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#vers-la-programmation-orientée-objet",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#vers-la-programmation-orientée-objet",
    "title": "Première Structuration des données",
    "section": "",
    "text": "Malgré ces avancées, certaines limitations persistaient : - Manque de mécanismes pour l’extension et la spécialisation des structures - Absence de polymorphisme\nCes limitations ont ouvert la voie à la programmation orientée objet, qui intégrera ces concepts de manière plus complète et flexible.",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/2-Structuration_des_donnees.html#conclusion",
    "href": "content/Cours_1/2-Structuration_des_donnees.html#conclusion",
    "title": "Première Structuration des données",
    "section": "",
    "text": "La structuration des données, à travers les tableaux, les structures, les records et les modules, a posé les bases conceptuelles nécessaires à l’émergence de la programmation orientée objet. Cette évolution a permis de mieux organiser et représenter l’information, préparant le terrain pour des paradigmes plus avancés.",
    "crumbs": [
      "Première Structuration des données"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html",
    "href": "content/Cours_1/3-NaissancePOO.html",
    "title": "Naissance de la POO",
    "section": "",
    "text": "Après l’émergence des concepts de la POO avec Simula et Smalltalk, de nombreux langages de programmation ont adopté et adapté ces principes. Nous allons nous concentrer sur deux langages majeurs : C++ et Python.\n\n\n\nC++, développé par Bjarne Stroustrup dans les années 1980, a été conçu comme une extension du langage C intégrant les concepts de la POO.\n\n\n\nCompatibilité avec C : Permet une transition en douceur pour les programmeurs C\nSupport de la POO : Classes, héritage, polymorphisme\nGénéricité : Templates pour une programmation générique\nGestion manuelle de la mémoire : Offre un contrôle précis mais exige plus de responsabilité du programmeur\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Vehicule {\nprotected:\n    std::string marque;\n    std::string modele;\n\npublic:\n    Vehicule(std::string m, std::string mod) : marque(m), modele(mod) {}\n    \n    virtual void afficher() const {\n        std::cout &lt;&lt; \"Vehicule: \" &lt;&lt; marque &lt;&lt; \" \" &lt;&lt; modele &lt;&lt; std::endl;\n    }\n};\n\nclass Voiture : public Vehicule {\nprivate:\n    int nombrePortes;\n\npublic:\n    Voiture(std::string m, std::string mod, int portes) \n        : Vehicule(m, mod), nombrePortes(portes) {}\n    \n    void afficher() const override {\n        std::cout &lt;&lt; \"Voiture: \" &lt;&lt; marque &lt;&lt; \" \" &lt;&lt; modele \n                  &lt;&lt; \" (\" &lt;&lt; nombrePortes &lt;&lt; \" portes)\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Vehicule* v1 = new Vehicule(\"Générique\", \"Modèle X\");\n    Vehicule* v2 = new Voiture(\"Renault\", \"Clio\", 5);\n    \n    v1-&gt;afficher();  // Affiche: Vehicule: Générique Modèle X\n    v2-&gt;afficher();  // Affiche: Voiture: Renault Clio (5 portes)\n    \n    delete v1;\n    delete v2;\n    return 0;\n}\n\n\n\n\nHéritage multiple : Permet à une classe d’hériter de plusieurs classes\nPolymorphisme par pointeurs et références : Utilisation de pointeurs pour le polymorphisme\nSurcharge d’opérateurs : Permet de définir le comportement des opérateurs pour les classes personnalisées\n\n\n\n\n\nPython, créé par Guido van Rossum à la fin des années 1980, a adopté la POO d’une manière plus souple et accessible.\n\n\n\nSyntaxe simple et lisible : Facilite l’apprentissage et la lecture du code\nTypage dynamique : Les types sont déterminés à l’exécution\n“Tout est objet” : Même les fonctions sont des objets de première classe\nGestion automatique de la mémoire : Garbage collection intégré\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDuck Typing : “Si ça marche comme un canard et ça caquète comme un canard, alors c’est un canard”\nMéthodes spéciales : Permettent de définir le comportement des objets (ex: __str__, __len__)\nPropriétés : Permettent de contrôler l’accès aux attributs de manière élégante\nHéritage multiple : Supporté, mais avec une résolution de méthode (MRO) spécifique\n\n\n\n\n\n\n\n\nC++ : Syntaxe plus verbeuse, types explicites\nPython : Syntaxe concise, types inférés\n\n\n\n\n\nC++ : Généralement plus rapide, contrôle précis de la mémoire\nPython : Plus lent, mais développement plus rapide\n\n\n\n\n\nC++ : Manuelle (new/delete), risque de fuites mémoire\nPython : Automatique (garbage collection)\n\n\n\n\n\nC++ : Statiquement typé, compilation nécessaire\nPython : Dynamiquement typé, interprété\n\n\n\n\n\nL’adoption de la POO dans ces langages modernes a eu plusieurs effets :\n\nStandardisation des pratiques : Concepts POO communs entre les langages\nAmélioration de la réutilisabilité : Bibliothèques et frameworks basés sur la POO\nFacilitation du développement à grande échelle : Meilleure organisation du code pour les grands projets\nAdaptation à différents domaines : Du développement système (C++) au scripting et à l’analyse de données (Python)\n\n\n\n\nL’intégration de la POO dans des langages comme C++ et Python a démocratisé son utilisation et a fourni aux développeurs des outils puissants pour créer des logiciels complexes et maintenables. Chaque langage a adapté les principes de la POO à sa philosophie, offrant ainsi une diversité d’approches pour résoudre les problèmes de programmation.",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#introduction",
    "href": "content/Cours_1/3-NaissancePOO.html#introduction",
    "title": "Naissance de la POO",
    "section": "",
    "text": "Après l’émergence des concepts de la POO avec Simula et Smalltalk, de nombreux langages de programmation ont adopté et adapté ces principes. Nous allons nous concentrer sur deux langages majeurs : C++ et Python.",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#c-lévolution-du-c-vers-la-poo",
    "href": "content/Cours_1/3-NaissancePOO.html#c-lévolution-du-c-vers-la-poo",
    "title": "Naissance de la POO",
    "section": "",
    "text": "C++, développé par Bjarne Stroustrup dans les années 1980, a été conçu comme une extension du langage C intégrant les concepts de la POO.\n\n\n\nCompatibilité avec C : Permet une transition en douceur pour les programmeurs C\nSupport de la POO : Classes, héritage, polymorphisme\nGénéricité : Templates pour une programmation générique\nGestion manuelle de la mémoire : Offre un contrôle précis mais exige plus de responsabilité du programmeur\n\n\n\n\n#include &lt;iostream&gt;\n#include &lt;string&gt;\n\nclass Vehicule {\nprotected:\n    std::string marque;\n    std::string modele;\n\npublic:\n    Vehicule(std::string m, std::string mod) : marque(m), modele(mod) {}\n    \n    virtual void afficher() const {\n        std::cout &lt;&lt; \"Vehicule: \" &lt;&lt; marque &lt;&lt; \" \" &lt;&lt; modele &lt;&lt; std::endl;\n    }\n};\n\nclass Voiture : public Vehicule {\nprivate:\n    int nombrePortes;\n\npublic:\n    Voiture(std::string m, std::string mod, int portes) \n        : Vehicule(m, mod), nombrePortes(portes) {}\n    \n    void afficher() const override {\n        std::cout &lt;&lt; \"Voiture: \" &lt;&lt; marque &lt;&lt; \" \" &lt;&lt; modele \n                  &lt;&lt; \" (\" &lt;&lt; nombrePortes &lt;&lt; \" portes)\" &lt;&lt; std::endl;\n    }\n};\n\nint main() {\n    Vehicule* v1 = new Vehicule(\"Générique\", \"Modèle X\");\n    Vehicule* v2 = new Voiture(\"Renault\", \"Clio\", 5);\n    \n    v1-&gt;afficher();  // Affiche: Vehicule: Générique Modèle X\n    v2-&gt;afficher();  // Affiche: Voiture: Renault Clio (5 portes)\n    \n    delete v1;\n    delete v2;\n    return 0;\n}\n\n\n\n\nHéritage multiple : Permet à une classe d’hériter de plusieurs classes\nPolymorphisme par pointeurs et références : Utilisation de pointeurs pour le polymorphisme\nSurcharge d’opérateurs : Permet de définir le comportement des opérateurs pour les classes personnalisées",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#python-la-poo-simplifiée-et-dynamique",
    "href": "content/Cours_1/3-NaissancePOO.html#python-la-poo-simplifiée-et-dynamique",
    "title": "Naissance de la POO",
    "section": "",
    "text": "Python, créé par Guido van Rossum à la fin des années 1980, a adopté la POO d’une manière plus souple et accessible.\n\n\n\nSyntaxe simple et lisible : Facilite l’apprentissage et la lecture du code\nTypage dynamique : Les types sont déterminés à l’exécution\n“Tout est objet” : Même les fonctions sont des objets de première classe\nGestion automatique de la mémoire : Garbage collection intégré\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDuck Typing : “Si ça marche comme un canard et ça caquète comme un canard, alors c’est un canard”\nMéthodes spéciales : Permettent de définir le comportement des objets (ex: __str__, __len__)\nPropriétés : Permettent de contrôler l’accès aux attributs de manière élégante\nHéritage multiple : Supporté, mais avec une résolution de méthode (MRO) spécifique",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#comparaison-c-vs-python-en-poo",
    "href": "content/Cours_1/3-NaissancePOO.html#comparaison-c-vs-python-en-poo",
    "title": "Naissance de la POO",
    "section": "",
    "text": "C++ : Syntaxe plus verbeuse, types explicites\nPython : Syntaxe concise, types inférés\n\n\n\n\n\nC++ : Généralement plus rapide, contrôle précis de la mémoire\nPython : Plus lent, mais développement plus rapide\n\n\n\n\n\nC++ : Manuelle (new/delete), risque de fuites mémoire\nPython : Automatique (garbage collection)\n\n\n\n\n\nC++ : Statiquement typé, compilation nécessaire\nPython : Dynamiquement typé, interprété",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#impact-sur-le-développement-logiciel",
    "href": "content/Cours_1/3-NaissancePOO.html#impact-sur-le-développement-logiciel",
    "title": "Naissance de la POO",
    "section": "",
    "text": "L’adoption de la POO dans ces langages modernes a eu plusieurs effets :\n\nStandardisation des pratiques : Concepts POO communs entre les langages\nAmélioration de la réutilisabilité : Bibliothèques et frameworks basés sur la POO\nFacilitation du développement à grande échelle : Meilleure organisation du code pour les grands projets\nAdaptation à différents domaines : Du développement système (C++) au scripting et à l’analyse de données (Python)",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/3-NaissancePOO.html#conclusion",
    "href": "content/Cours_1/3-NaissancePOO.html#conclusion",
    "title": "Naissance de la POO",
    "section": "",
    "text": "L’intégration de la POO dans des langages comme C++ et Python a démocratisé son utilisation et a fourni aux développeurs des outils puissants pour créer des logiciels complexes et maintenables. Chaque langage a adapté les principes de la POO à sa philosophie, offrant ainsi une diversité d’approches pour résoudre les problèmes de programmation.",
    "crumbs": [
      "Naissance de la POO"
    ]
  },
  {
    "objectID": "content/Cours_1/index.html",
    "href": "content/Cours_1/index.html",
    "title": "Introduction: Histoire et Concepts",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nClasses en Python : Concepts fondamentaux\n\n\nDécouvrez les concepts fondamentaux des classes en Python, y compris les attributs de classe vs d’instance, le rôle de ‘self’, et les conventions de codage.\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nConstruire son propre DataFrame\n\n\n\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nHistoire de la programmation\n\n\nDu binaire à la POO\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nNaissance de la POO\n\n\nL’adoption de la POO dans les langages modernes comme C++ et Python a révolutionné la programmation. Découvrez comment ces langages ont intégré les concepts de la POO et…\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPremière Structuration des données\n\n\nDécouvrez comment les tableaux, les structures et les records ont permis de structurer les données dans les premiers langages de programmation.\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython : Simplicité des objets et performance sous-jacente\n\n\nDécouvrez comment Python peut combiner la simplicité des objets avec des performances élevées grâce à l’intégration de code C et Rust.\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython: tout n’est qu’objet\n\n\nExplorer la notion de PATH, un élément essentiel dans la configuration des environnements de développement.\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Introduction: Histoire et Concepts"
    ]
  },
  {
    "objectID": "content/Cours_1/5-Simplicity_and_performance.html",
    "href": "content/Cours_1/5-Simplicity_and_performance.html",
    "title": "Python : Simplicité des objets et performance sous-jacente",
    "section": "",
    "text": "Python est réputé pour sa courbe d’apprentissage douce, en grande partie grâce à son approche orientée objet intuitive.\n\n\nImaginons que vous vouliez lire un fichier CSV et analyser ses données :\nimport pandas as pd\n\n# Lecture d'un fichier CSV\ndf = pd.read_csv(\"donnees.csv\")\n\n# Affichage des premières lignes\nprint(df.head())\n\n# Calcul de la moyenne d'une colonne\nmoyenne = df['colonne_numerique'].mean()\n\n# Filtrage des données\nresultats = df[df['categorie'] == 'A']\nDans cet exemple : - Vous n’avez pas besoin de comprendre comment Pandas lit le fichier ou stocke les données. - Les méthodes comme head(), mean(), et le filtrage sont intuitives et faciles à utiliser. - Vous manipulez des objets complexes (DataFrame) avec une syntaxe simple.\n\n\n\n\nLes objets en Python cachent la complexité sous-jacente.\nVous utilisez des méthodes sans vous soucier de leur implémentation interne.\nCette approche permet aux débutants de se concentrer sur la logique de leur programme plutôt que sur les détails techniques.\n\n\n\n\n\nBien que Python soit généralement considéré comme plus lent que les langages de bas niveau, il offre des solutions pour obtenir des performances élevées.\n\n\n\nPython lui-même est implémenté en C (CPython, l’implémentation de référence).\nDe nombreuses bibliothèques Python populaires sont écrites en C ou ont des composants en C.\n\n\n\n\nNumPy est un excellent exemple de cette approche :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nNumPy utilise des tableaux optimisés en C.\nLes opérations sont effectuées en C, offrant des performances proches du matériel.\nL’interface Python reste simple et intuitive.\n\n\n\n\nRécemment, Python a étendu cette approche à d’autres langages performants comme Rust :\n\nDes bibliothèques comme PyO3 permettent d’écrire des extensions Python en Rust.\nCela combine la sécurité mémoire de Rust avec la facilité d’utilisation de Python.\n\n\n\n\n\nLes objets Python agissent comme une couche d’abstraction conviviale au-dessus de code performant :\n\nFacilité d’utilisation : L’interface orientée objet en Python est intuitive.\nAbstraction : Les détails complexes sont cachés à l’utilisateur.\nPerformance sous-jacente : Le code critique en termes de performance est écrit dans des langages compilés.\nFlexibilité : Les développeurs peuvent choisir entre la simplicité de Python pur ou l’optimisation avec C/Rust selon leurs besoins.\n\n\n\n\nPython réussit à offrir le meilleur des deux mondes : - Une interface orientée objet simple et intuitive, idéale pour l’apprentissage et le développement rapide. - La possibilité d’obtenir des performances élevées grâce à l’intégration de code C ou Rust.\nCette approche fait de Python un langage polyvalent, capable de s’adapter à une grande variété de besoins, du script simple à l’application haute performance, tout en maintenant une syntaxe accessible et une philosophie centrée sur la lisibilité du code.",
    "crumbs": [
      "Python : Simplicité des objets et performance sous-jacente"
    ]
  },
  {
    "objectID": "content/Cours_1/5-Simplicity_and_performance.html#la-simplicité-des-objets-en-python-pour-les-débutants",
    "href": "content/Cours_1/5-Simplicity_and_performance.html#la-simplicité-des-objets-en-python-pour-les-débutants",
    "title": "Python : Simplicité des objets et performance sous-jacente",
    "section": "",
    "text": "Python est réputé pour sa courbe d’apprentissage douce, en grande partie grâce à son approche orientée objet intuitive.\n\n\nImaginons que vous vouliez lire un fichier CSV et analyser ses données :\nimport pandas as pd\n\n# Lecture d'un fichier CSV\ndf = pd.read_csv(\"donnees.csv\")\n\n# Affichage des premières lignes\nprint(df.head())\n\n# Calcul de la moyenne d'une colonne\nmoyenne = df['colonne_numerique'].mean()\n\n# Filtrage des données\nresultats = df[df['categorie'] == 'A']\nDans cet exemple : - Vous n’avez pas besoin de comprendre comment Pandas lit le fichier ou stocke les données. - Les méthodes comme head(), mean(), et le filtrage sont intuitives et faciles à utiliser. - Vous manipulez des objets complexes (DataFrame) avec une syntaxe simple.\n\n\n\n\nLes objets en Python cachent la complexité sous-jacente.\nVous utilisez des méthodes sans vous soucier de leur implémentation interne.\nCette approche permet aux débutants de se concentrer sur la logique de leur programme plutôt que sur les détails techniques.",
    "crumbs": [
      "Python : Simplicité des objets et performance sous-jacente"
    ]
  },
  {
    "objectID": "content/Cours_1/5-Simplicity_and_performance.html#performance-le-meilleur-des-deux-mondes",
    "href": "content/Cours_1/5-Simplicity_and_performance.html#performance-le-meilleur-des-deux-mondes",
    "title": "Python : Simplicité des objets et performance sous-jacente",
    "section": "",
    "text": "Bien que Python soit généralement considéré comme plus lent que les langages de bas niveau, il offre des solutions pour obtenir des performances élevées.\n\n\n\nPython lui-même est implémenté en C (CPython, l’implémentation de référence).\nDe nombreuses bibliothèques Python populaires sont écrites en C ou ont des composants en C.\n\n\n\n\nNumPy est un excellent exemple de cette approche :\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\nNumPy utilise des tableaux optimisés en C.\nLes opérations sont effectuées en C, offrant des performances proches du matériel.\nL’interface Python reste simple et intuitive.\n\n\n\n\nRécemment, Python a étendu cette approche à d’autres langages performants comme Rust :\n\nDes bibliothèques comme PyO3 permettent d’écrire des extensions Python en Rust.\nCela combine la sécurité mémoire de Rust avec la facilité d’utilisation de Python.",
    "crumbs": [
      "Python : Simplicité des objets et performance sous-jacente"
    ]
  },
  {
    "objectID": "content/Cours_1/5-Simplicity_and_performance.html#lobjet-python-comme-interface-conviviale",
    "href": "content/Cours_1/5-Simplicity_and_performance.html#lobjet-python-comme-interface-conviviale",
    "title": "Python : Simplicité des objets et performance sous-jacente",
    "section": "",
    "text": "Les objets Python agissent comme une couche d’abstraction conviviale au-dessus de code performant :\n\nFacilité d’utilisation : L’interface orientée objet en Python est intuitive.\nAbstraction : Les détails complexes sont cachés à l’utilisateur.\nPerformance sous-jacente : Le code critique en termes de performance est écrit dans des langages compilés.\nFlexibilité : Les développeurs peuvent choisir entre la simplicité de Python pur ou l’optimisation avec C/Rust selon leurs besoins.",
    "crumbs": [
      "Python : Simplicité des objets et performance sous-jacente"
    ]
  },
  {
    "objectID": "content/Cours_1/5-Simplicity_and_performance.html#conclusion",
    "href": "content/Cours_1/5-Simplicity_and_performance.html#conclusion",
    "title": "Python : Simplicité des objets et performance sous-jacente",
    "section": "",
    "text": "Python réussit à offrir le meilleur des deux mondes : - Une interface orientée objet simple et intuitive, idéale pour l’apprentissage et le développement rapide. - La possibilité d’obtenir des performances élevées grâce à l’intégration de code C ou Rust.\nCette approche fait de Python un langage polyvalent, capable de s’adapter à une grande variété de besoins, du script simple à l’application haute performance, tout en maintenant une syntaxe accessible et une philosophie centrée sur la lisibilité du code.",
    "crumbs": [
      "Python : Simplicité des objets et performance sous-jacente"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html",
    "href": "content/Cours_4/3-Decorator_practically.html",
    "title": "Decorator Practically",
    "section": "",
    "text": "In Python, decorators are implemented using the @ symbol, followed by the decorator function name, placed above the function definition they’re decorating.\nLet’s start with a simple example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, uppercase_decorator is a function that takes another function as an argument, modifies its behavior (by converting the result to uppercase), and returns the modified function.\n\n\n\nDecorators can also work with functions that accept arguments:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator logs the name of the function being called before executing it.\n\n\n\nDecorators can also be applied to classes. Here’s a simple example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator adds a greet method to the Person class.\n\n\n\nWe can create decorators that accept parameters:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis repeat decorator takes an argument specifying how many times the decorated function should be called.\n\n\n\nThese examples demonstrate the basic usage of decorators in Python. They allow for modifying or enhancing the behavior of functions and classes without changing their source code. Decorators provide a clean and reusable way to extend functionality, making code more modular and easier to maintain.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html#basic-function-decorators",
    "href": "content/Cours_4/3-Decorator_practically.html#basic-function-decorators",
    "title": "Decorator Practically",
    "section": "",
    "text": "In Python, decorators are implemented using the @ symbol, followed by the decorator function name, placed above the function definition they’re decorating.\nLet’s start with a simple example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, uppercase_decorator is a function that takes another function as an argument, modifies its behavior (by converting the result to uppercase), and returns the modified function.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html#function-decorators-with-arguments",
    "href": "content/Cours_4/3-Decorator_practically.html#function-decorators-with-arguments",
    "title": "Decorator Practically",
    "section": "",
    "text": "Decorators can also work with functions that accept arguments:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator logs the name of the function being called before executing it.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html#simple-class-decorator",
    "href": "content/Cours_4/3-Decorator_practically.html#simple-class-decorator",
    "title": "Decorator Practically",
    "section": "",
    "text": "Decorators can also be applied to classes. Here’s a simple example:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis decorator adds a greet method to the Person class.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html#decorators-with-parameters",
    "href": "content/Cours_4/3-Decorator_practically.html#decorators-with-parameters",
    "title": "Decorator Practically",
    "section": "",
    "text": "We can create decorators that accept parameters:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThis repeat decorator takes an argument specifying how many times the decorated function should be called.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/3-Decorator_practically.html#conclusion",
    "href": "content/Cours_4/3-Decorator_practically.html#conclusion",
    "title": "Decorator Practically",
    "section": "",
    "text": "These examples demonstrate the basic usage of decorators in Python. They allow for modifying or enhancing the behavior of functions and classes without changing their source code. Decorators provide a clean and reusable way to extend functionality, making code more modular and easier to maintain.",
    "crumbs": [
      "Decorator Practically"
    ]
  },
  {
    "objectID": "content/Cours_4/index.html",
    "href": "content/Cours_4/index.html",
    "title": "Decorators",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBuilt-in Decorators and Standard Library Decorators in Python\n\n\nLearn about built-in decorators and standard library decorators in Python, including @property, @classmethod, @staticmethod, @dataclass, and decorators from the functools…\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDecorator Practically\n\n\nLearn about decorators in Python with concrete examples, including basic function decorators, decorators with arguments, class decorators, decorators with parameters, and…\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nDesign Patterns\n\n\nLearn about design patterns in software development, their purpose, benefits, and common categories, and understand how they provide reusable solutions to common problems in…\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP\n\n\n\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nThe decorator pattern\n\n\nLearn about the origins and evolution of the decorator pattern in programming, its key concepts, advantages over traditional inheritance, and its impact on modern…\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top"
  },
  {
    "objectID": "content/Cours_4/TP.html",
    "href": "content/Cours_4/TP.html",
    "title": "TP",
    "section": "",
    "text": "TODO\n\n\n\n\n\n Back to top",
    "crumbs": [
      "Travaux Pratiques",
      "TP"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Protocol.html",
    "href": "content/Cours_3/5-Protocol.html",
    "title": "Protocol Classes",
    "section": "",
    "text": "Protocols, introduced in Python 3.8, provide a way to define structural subtyping (often called “duck typing”). They allow you to define interfaces in a more flexible and Pythonic way compared to abstract base classes.\n\n\n\n\nStructural Subtyping: An object is considered a subtype if it has the required methods and attributes, regardless of inheritance.\nNo Runtime Enforcement: Protocols are primarily used for static type checking and don’t enforce method implementation at runtime.\nFlexibility: Classes don’t need to explicitly inherit from a Protocol to be considered compatible.\n\n\n\n\nTo use Protocols, you need to import from the typing module:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - Drawable is a Protocol that defines an interface with a draw method. - Circle is compatible with Drawable because it has a draw method, even though it doesn’t explicitly inherit from Drawable.\n\n\n\n\nFlexibility: You can define interfaces for existing classes without modifying them.\nDuck Typing: Aligns well with Python’s “duck typing” philosophy.\nStatic Type Checking: Provides benefits of static typing without runtime overhead.\nBackwards Compatibility: Can be used with existing codebases without modification.\n\n\n\n\nLet’s look at a more comprehensive example using Protocols:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - We define multiple Protocols: Sized, Appendable, and StringContainer. - StringContainer combines multiple Protocols. - MyList is compatible with StringContainer because it implements all required methods. - process_data can work with any object that satisfies the StringContainer Protocol.\n\n\n\nWhile Protocols are primarily for static type checking, you can make them runtime-checkable:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe @runtime_checkable decorator allows isinstance() checks, but be cautious as it only checks for the existence of the methods, not their signatures.\n\n\n\nProtocols in Python provide a flexible and powerful way to define interfaces. They offer the benefits of static typing and interface definition while maintaining Python’s dynamic and duck-typed nature. Protocols are especially useful in large codebases, for defining clear contracts between different parts of a system, and for working with existing code that can’t be modified to inherit from specific base classes.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Protocol.html#introduction-to-protocols",
    "href": "content/Cours_3/5-Protocol.html#introduction-to-protocols",
    "title": "Protocol Classes",
    "section": "",
    "text": "Protocols, introduced in Python 3.8, provide a way to define structural subtyping (often called “duck typing”). They allow you to define interfaces in a more flexible and Pythonic way compared to abstract base classes.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Protocol.html#key-concepts",
    "href": "content/Cours_3/5-Protocol.html#key-concepts",
    "title": "Protocol Classes",
    "section": "",
    "text": "Structural Subtyping: An object is considered a subtype if it has the required methods and attributes, regardless of inheritance.\nNo Runtime Enforcement: Protocols are primarily used for static type checking and don’t enforce method implementation at runtime.\nFlexibility: Classes don’t need to explicitly inherit from a Protocol to be considered compatible.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Protocol.html#basic-usage-of-protocols",
    "href": "content/Cours_3/5-Protocol.html#basic-usage-of-protocols",
    "title": "Protocol Classes",
    "section": "",
    "text": "To use Protocols, you need to import from the typing module:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - Drawable is a Protocol that defines an interface with a draw method. - Circle is compatible with Drawable because it has a draw method, even though it doesn’t explicitly inherit from Drawable.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Protocol.html#advantages-of-protocols",
    "href": "content/Cours_3/5-Protocol.html#advantages-of-protocols",
    "title": "Protocol Classes",
    "section": "",
    "text": "Flexibility: You can define interfaces for existing classes without modifying them.\nDuck Typing: Aligns well with Python’s “duck typing” philosophy.\nStatic Type Checking: Provides benefits of static typing without runtime overhead.\nBackwards Compatibility: Can be used with existing codebases without modification.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Protocol.html#more-complex-example",
    "href": "content/Cours_3/5-Protocol.html#more-complex-example",
    "title": "Protocol Classes",
    "section": "",
    "text": "Let’s look at a more comprehensive example using Protocols:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - We define multiple Protocols: Sized, Appendable, and StringContainer. - StringContainer combines multiple Protocols. - MyList is compatible with StringContainer because it implements all required methods. - process_data can work with any object that satisfies the StringContainer Protocol.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Protocol.html#runtime-checkable-protocols",
    "href": "content/Cours_3/5-Protocol.html#runtime-checkable-protocols",
    "title": "Protocol Classes",
    "section": "",
    "text": "While Protocols are primarily for static type checking, you can make them runtime-checkable:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nThe @runtime_checkable decorator allows isinstance() checks, but be cautious as it only checks for the existence of the methods, not their signatures.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/5-Protocol.html#conclusion",
    "href": "content/Cours_3/5-Protocol.html#conclusion",
    "title": "Protocol Classes",
    "section": "",
    "text": "Protocols in Python provide a flexible and powerful way to define interfaces. They offer the benefits of static typing and interface definition while maintaining Python’s dynamic and duck-typed nature. Protocols are especially useful in large codebases, for defining clear contracts between different parts of a system, and for working with existing code that can’t be modified to inherit from specific base classes.",
    "crumbs": [
      "Protocol Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/index.html",
    "href": "content/Cours_3/index.html",
    "title": "Les Librairies Python",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nAbstract Classes\n\n\nLearn about abstract classes in Python, how to define and use them, and the benefits of using abstract classes for creating a common interface and enforcing method…\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPolymorphism in Object-Oriented Programming\n\n\nLearn about polymorphism in object-oriented programming (OOP), including method overriding, runtime polymorphism, and how it enables flexible and extensible code structures.\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPolymorphism in Python: Function Overloading and Type Checking\n\n\nLearn how to achieve polymorphism in Python through function overloading, type checking, and class-based polymorphism\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProtocol Classes\n\n\nLearn about Protocol classes in Python, how to define and use them, and the advantages of using Protocols for defining interfaces and structural subtyping.\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP\n\n\n\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nType Hinting, Typing Module, and Linters in Python\n\n\nLearn about type hinting in Python, the typing module, and how to use linters for static type checking to improve code quality and maintainability.\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Les Librairies Python"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Abstract_class.html",
    "href": "content/Cours_3/4-Abstract_class.html",
    "title": "Abstract Classes",
    "section": "",
    "text": "An abstract class is a class that is designed to be inherited from, but not instantiated directly. It often contains one or more abstract methods - methods that are declared, but don’t have an implementation in the abstract class.\n\n\n\nCannot be instantiated directly\nMay contain abstract methods (methods without a body)\nMay contain concrete methods (methods with an implementation)\nSubclasses must implement all abstract methods\n\n\n\n\n\nTo define a common interface for a set of subclasses\nTo enforce certain methods to be implemented by subclasses\nTo share code among several closely related classes\n\n\n\n\n\nPython provides the abc module to work with abstract base classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - Animal is an abstract base class - make_sound is an abstract method - move is a concrete method\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nThe @abstractmethod decorator marks a method as abstract\nSubclasses must implement all abstract methods\nAbstract classes can have both abstract and concrete methods\nTrying to instantiate an abstract class directly will raise a TypeError\n\n\n\n\n\n\nEnforcing a common interface: Abstract classes ensure that all subclasses implement certain methods, guaranteeing a common interface.\nCode reuse: You can implement common functionality in the abstract base class, which all subclasses can use.\nDesigning frameworks: Abstract classes are useful when designing large frameworks where you want to provide default behaviors but require specific implementations in subclasses.\n\n\n\n\nHere’s a more practical example using shapes:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, Shape is an abstract base class that defines the common interface for all shapes. Circle and Rectangle are concrete implementations of Shape.\n\n\n\nAbstract base classes in Python provide a powerful way to define interfaces and ensure that derived classes implement certain methods. They’re useful for creating frameworks and libraries, ensuring consistency across related classes, and defining clear contracts for subclasses to follow.\nBy using abstract classes, you can create more robust and well-structured code, especially when dealing with complex hierarchies of related classes.",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Abstract_class.html#concept-and-purpose",
    "href": "content/Cours_3/4-Abstract_class.html#concept-and-purpose",
    "title": "Abstract Classes",
    "section": "",
    "text": "An abstract class is a class that is designed to be inherited from, but not instantiated directly. It often contains one or more abstract methods - methods that are declared, but don’t have an implementation in the abstract class.\n\n\n\nCannot be instantiated directly\nMay contain abstract methods (methods without a body)\nMay contain concrete methods (methods with an implementation)\nSubclasses must implement all abstract methods\n\n\n\n\n\nTo define a common interface for a set of subclasses\nTo enforce certain methods to be implemented by subclasses\nTo share code among several closely related classes",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Abstract_class.html#abstract-base-classes-abc-in-python",
    "href": "content/Cours_3/4-Abstract_class.html#abstract-base-classes-abc-in-python",
    "title": "Abstract Classes",
    "section": "",
    "text": "Python provides the abc module to work with abstract base classes.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example: - Animal is an abstract base class - make_sound is an abstract method - move is a concrete method\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nThe @abstractmethod decorator marks a method as abstract\nSubclasses must implement all abstract methods\nAbstract classes can have both abstract and concrete methods\nTrying to instantiate an abstract class directly will raise a TypeError",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Abstract_class.html#why-use-abstract-classes",
    "href": "content/Cours_3/4-Abstract_class.html#why-use-abstract-classes",
    "title": "Abstract Classes",
    "section": "",
    "text": "Enforcing a common interface: Abstract classes ensure that all subclasses implement certain methods, guaranteeing a common interface.\nCode reuse: You can implement common functionality in the abstract base class, which all subclasses can use.\nDesigning frameworks: Abstract classes are useful when designing large frameworks where you want to provide default behaviors but require specific implementations in subclasses.",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Abstract_class.html#example-shape-hierarchy",
    "href": "content/Cours_3/4-Abstract_class.html#example-shape-hierarchy",
    "title": "Abstract Classes",
    "section": "",
    "text": "Here’s a more practical example using shapes:\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\nIn this example, Shape is an abstract base class that defines the common interface for all shapes. Circle and Rectangle are concrete implementations of Shape.",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/4-Abstract_class.html#conclusion",
    "href": "content/Cours_3/4-Abstract_class.html#conclusion",
    "title": "Abstract Classes",
    "section": "",
    "text": "Abstract base classes in Python provide a powerful way to define interfaces and ensure that derived classes implement certain methods. They’re useful for creating frameworks and libraries, ensuring consistency across related classes, and defining clear contracts for subclasses to follow.\nBy using abstract classes, you can create more robust and well-structured code, especially when dealing with complex hierarchies of related classes.",
    "crumbs": [
      "Abstract Classes"
    ]
  },
  {
    "objectID": "content/Cours_3/3-Type_Hinting.html",
    "href": "content/Cours_3/3-Type_Hinting.html",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "Type hinting, introduced in Python 3.5 (PEP 484), allows developers to indicate the expected types of variables, function parameters, and return values. While Python remains dynamically typed, type hints provide several benefits:\n\nImproved code readability\nBetter IDE support (autocomplete, error detection)\nEasier maintenance, especially for large codebases\nCatch certain types of errors before runtime\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nThe typing module provides support for type hints. It includes a collection of types and tools for working with type annotations.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nWhile Python doesn’t enforce type hints at runtime, various tools can perform static type checking:\n\n\nMypy is a static type checker for Python. It can catch many type-related errors before runtime.\nInstallation:\npip install mypy\nUsage:\nmypy your_script.py\n\n\n\nPylint is a linter that can check for coding standards, errors, and code smells. It also supports type checking.\nInstallation:\npip install pylint\nUsage:\npylint your_script.py\n\n\n\nPopular IDEs like PyCharm and VS Code have built-in support for type checking and can highlight type-related issues in real-time.\n\n\n\n\n\nStart with critical or complex functions\nUse type hints consistently throughout a module or project\nUtilize tools like Mypy to catch type-related errors\nDon’t overuse Any - it defeats the purpose of type hinting\nConsider using type hints in combination with docstrings for comprehensive documentation\n\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\nType hinting, along with the typing module and linters, provides a powerful set of tools for improving code quality, readability, and maintainability in Python. While not enforced at runtime, these features can catch many errors early in the development process and provide better documentation and IDE support. As Python projects grow in size and complexity, incorporating type hints and static type checking becomes increasingly valuable.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/3-Type_Hinting.html#introduction-to-type-hinting",
    "href": "content/Cours_3/3-Type_Hinting.html#introduction-to-type-hinting",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "Type hinting, introduced in Python 3.5 (PEP 484), allows developers to indicate the expected types of variables, function parameters, and return values. While Python remains dynamically typed, type hints provide several benefits:\n\nImproved code readability\nBetter IDE support (autocomplete, error detection)\nEasier maintenance, especially for large codebases\nCatch certain types of errors before runtime\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/3-Type_Hinting.html#the-typing-module",
    "href": "content/Cours_3/3-Type_Hinting.html#the-typing-module",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "The typing module provides support for type hints. It includes a collection of types and tools for working with type annotations.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/3-Type_Hinting.html#type-checking-and-linters",
    "href": "content/Cours_3/3-Type_Hinting.html#type-checking-and-linters",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "While Python doesn’t enforce type hints at runtime, various tools can perform static type checking:\n\n\nMypy is a static type checker for Python. It can catch many type-related errors before runtime.\nInstallation:\npip install mypy\nUsage:\nmypy your_script.py\n\n\n\nPylint is a linter that can check for coding standards, errors, and code smells. It also supports type checking.\nInstallation:\npip install pylint\nUsage:\npylint your_script.py\n\n\n\nPopular IDEs like PyCharm and VS Code have built-in support for type checking and can highlight type-related issues in real-time.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/3-Type_Hinting.html#best-practices-for-type-hinting",
    "href": "content/Cours_3/3-Type_Hinting.html#best-practices-for-type-hinting",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "Start with critical or complex functions\nUse type hints consistently throughout a module or project\nUtilize tools like Mypy to catch type-related errors\nDon’t overuse Any - it defeats the purpose of type hinting\nConsider using type hints in combination with docstrings for comprehensive documentation",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/3-Type_Hinting.html#example-putting-it-all-together",
    "href": "content/Cours_3/3-Type_Hinting.html#example-putting-it-all-together",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "Please enable JavaScript to experience the dynamic code cell content on this page.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Cours_3/3-Type_Hinting.html#conclusion",
    "href": "content/Cours_3/3-Type_Hinting.html#conclusion",
    "title": "Type Hinting, Typing Module, and Linters in Python",
    "section": "",
    "text": "Type hinting, along with the typing module and linters, provides a powerful set of tools for improving code quality, readability, and maintainability in Python. While not enforced at runtime, these features can catch many errors early in the development process and provide better documentation and IDE support. As Python projects grow in size and complexity, incorporating type hints and static type checking becomes increasingly valuable.",
    "crumbs": [
      "Type Hinting, Typing Module, and Linters in Python"
    ]
  },
  {
    "objectID": "content/Projets/index.html",
    "href": "content/Projets/index.html",
    "title": "Projets",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nProjets Introduction à Python - Millésime 2024\n\n\n\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "Projets"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html",
    "href": "content/Cours_6/4-behavioral_patterns.html",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "Behavioral patterns are concerned with algorithms and the assignment of responsibilities between objects. They characterize complex control flow that’s difficult to follow at run-time.\n\n\nThe Observer pattern lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSupports the principle of loose coupling between objects\nAllows sending data to many objects efficiently\nDynamic relationships can be established between objects at runtime\n\n\n\n\n\nThe Strategy pattern lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAllows switching algorithms used inside an object at runtime\nIsolates the implementation details of an algorithm from the code that uses it\nReplaces inheritance with composition\n\n\n\n\n\nThe Command pattern turns a request into a stand-alone object that contains all information about the request.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDecouples classes that invoke operations from classes that perform these operations\nAllows creating sequences of commands with a macro command\nSupports undo operations\n\n\n\n\n\nThe State pattern lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nOrganizes code related to particular states into separate classes\nMakes state transitions explicit\nSimplifies the code by eliminating bulky state machine conditional statements\n\n\n\n\n\nThe Chain of Responsibility pattern lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nReduces coupling between components\nIncreases flexibility in assigning responsibilities to objects\nAllows adding or removing responsibilities dynamically\n\n\n\n\n\nThe Template Method pattern defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLets subclasses implement varying behavior\nAvoids code duplication\nAllows fine-grained control over the steps of an algorithm\n\n\n\n\n\nBehavioral design patterns are crucial for managing algorithms, relationships, and responsibilities between objects. They improve communication between objects, make complex control flows more manageable, and help distribute responsibilities efficiently. By applying these patterns, developers can create more flexible and maintainable code structures that are easier to understand and modify.",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#observer-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#observer-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The Observer pattern lets you define a subscription mechanism to notify multiple objects about any events that happen to the object they’re observing.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSupports the principle of loose coupling between objects\nAllows sending data to many objects efficiently\nDynamic relationships can be established between objects at runtime",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#strategy-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#strategy-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The Strategy pattern lets you define a family of algorithms, put each of them into a separate class, and make their objects interchangeable.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAllows switching algorithms used inside an object at runtime\nIsolates the implementation details of an algorithm from the code that uses it\nReplaces inheritance with composition",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#command-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#command-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The Command pattern turns a request into a stand-alone object that contains all information about the request.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDecouples classes that invoke operations from classes that perform these operations\nAllows creating sequences of commands with a macro command\nSupports undo operations",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#state-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#state-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The State pattern lets an object alter its behavior when its internal state changes. It appears as if the object changed its class.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nOrganizes code related to particular states into separate classes\nMakes state transitions explicit\nSimplifies the code by eliminating bulky state machine conditional statements",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#chain-of-responsibility-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#chain-of-responsibility-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The Chain of Responsibility pattern lets you pass requests along a chain of handlers. Upon receiving a request, each handler decides either to process the request or to pass it to the next handler in the chain.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nReduces coupling between components\nIncreases flexibility in assigning responsibilities to objects\nAllows adding or removing responsibilities dynamically",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#template-method-pattern",
    "href": "content/Cours_6/4-behavioral_patterns.html#template-method-pattern",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "The Template Method pattern defines the skeleton of an algorithm in the superclass but lets subclasses override specific steps of the algorithm without changing its structure.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nLets subclasses implement varying behavior\nAvoids code duplication\nAllows fine-grained control over the steps of an algorithm",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/4-behavioral_patterns.html#conclusion",
    "href": "content/Cours_6/4-behavioral_patterns.html#conclusion",
    "title": "Behavioral Design Pattern",
    "section": "",
    "text": "Behavioral design patterns are crucial for managing algorithms, relationships, and responsibilities between objects. They improve communication between objects, make complex control flows more manageable, and help distribute responsibilities efficiently. By applying these patterns, developers can create more flexible and maintainable code structures that are easier to understand and modify.",
    "crumbs": [
      "Behavioral Design Pattern"
    ]
  },
  {
    "objectID": "content/Cours_6/index.html",
    "href": "content/Cours_6/index.html",
    "title": "OOP Design Patterns",
    "section": "",
    "text": "Les cours de cette partie sont:\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nBehavioral Design Pattern\n\n\nDécouvrir les design paterns, et connaitre les plus standards\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCreation Design Patterns\n\n\nLearn creational design pattern\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nPython-Specific Design Patterns\n\n\nLearn about Python-specific design patterns, including context managers and descriptors, to write more efficient and Pythonic code.\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nStructural Design Patterns\n\n\nDécouvrir les design paterns, et connaitre les plus standards\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTP\n\n\n\n\n\n\nRemi Genet\n\n\n2024-07-29\n\n\n\n\n\n\n\n\nNo matching items\n\n Back to top",
    "crumbs": [
      "OOP Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html",
    "href": "content/Cours_6/3-Structural_patterns.html",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "Structural patterns explain how to assemble objects and classes into larger structures while keeping these structures flexible and efficient.\n\n\nThe Adapter pattern allows objects with incompatible interfaces to collaborate.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nIntegrates incompatible interfaces\nImproves reusability of existing code\nEnhances flexibility in system design\n\n\n\n\n\nThe Bridge pattern separates an object’s abstraction from its implementation, allowing them to vary independently.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDecouples abstraction from implementation\nImproves extensibility\nHides implementation details from clients\n\n\n\n\n\nThe Composite pattern lets you compose objects into tree structures and then work with these structures as if they were individual objects.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSimplifies client code when working with complex hierarchies\nMakes it easy to add new types of components\nProvides flexibility in structuring data\n\n\n\n\n\nThe Decorator pattern lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAdds responsibilities to objects dynamically\nProvides a flexible alternative to subclassing\nAllows for a mix-and-match approach to adding features\n\n\n\n\n\nThe Facade pattern provides a simplified interface to a complex subsystem.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSimplifies interface to a complex subsystem\nDecouples client code from subsystem\nProvides a context for usage\n\n\n\n\n\nThe Flyweight pattern lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nReduces memory usage when dealing with a large number of similar objects\nImproves performance in applications with many objects\nCentralizes state for many virtual objects\n\n\n\n\n\nThe Proxy pattern lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nControls access to the original object\nCan manage the lifecycle of the original object\nAdds a level of indirection for distributed, controlled, or intelligent access\n\n\n\n\n\nStructural design patterns provide various ways to organize code for better structure, flexibility, and efficiency. They help in creating relationships between entities, making systems easier to maintain and extend. By understanding and applying these patterns, developers can create more robust and scalable software architectures.",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#adapter-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#adapter-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Adapter pattern allows objects with incompatible interfaces to collaborate.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nIntegrates incompatible interfaces\nImproves reusability of existing code\nEnhances flexibility in system design",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#bridge-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#bridge-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Bridge pattern separates an object’s abstraction from its implementation, allowing them to vary independently.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nDecouples abstraction from implementation\nImproves extensibility\nHides implementation details from clients",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#composite-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#composite-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Composite pattern lets you compose objects into tree structures and then work with these structures as if they were individual objects.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSimplifies client code when working with complex hierarchies\nMakes it easy to add new types of components\nProvides flexibility in structuring data",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#decorator-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#decorator-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Decorator pattern lets you attach new behaviors to objects by placing these objects inside special wrapper objects that contain the behaviors.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nAdds responsibilities to objects dynamically\nProvides a flexible alternative to subclassing\nAllows for a mix-and-match approach to adding features",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#facade-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#facade-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Facade pattern provides a simplified interface to a complex subsystem.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nSimplifies interface to a complex subsystem\nDecouples client code from subsystem\nProvides a context for usage",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#flyweight-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#flyweight-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Flyweight pattern lets you fit more objects into the available amount of RAM by sharing common parts of state between multiple objects instead of keeping all of the data in each object.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nReduces memory usage when dealing with a large number of similar objects\nImproves performance in applications with many objects\nCentralizes state for many virtual objects",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#proxy-pattern",
    "href": "content/Cours_6/3-Structural_patterns.html#proxy-pattern",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "The Proxy pattern lets you provide a substitute or placeholder for another object. A proxy controls access to the original object, allowing you to perform something either before or after the request gets through to the original object.\n\n\n\nPlease enable JavaScript to experience the dynamic code cell content on this page.\n\n\n\n\nControls access to the original object\nCan manage the lifecycle of the original object\nAdds a level of indirection for distributed, controlled, or intelligent access",
    "crumbs": [
      "Structural Design Patterns"
    ]
  },
  {
    "objectID": "content/Cours_6/3-Structural_patterns.html#conclusion",
    "href": "content/Cours_6/3-Structural_patterns.html#conclusion",
    "title": "Structural Design Patterns",
    "section": "",
    "text": "Structural design patterns provide various ways to organize code for better structure, flexibility, and efficiency. They help in creating relationships between entities, making systems easier to maintain and extend. By understanding and applying these patterns, developers can create more robust and scalable software architectures.",
    "crumbs": [
      "Structural Design Patterns"
    ]
  }
]